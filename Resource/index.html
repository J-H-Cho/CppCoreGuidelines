



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++ 핵심 가이드라인 한글화 프로젝트">
      
      
        <link rel="canonical" href="http://www.cppkorea.org/CppCoreGuidelines/Resource/">
      
      
        <meta name="author" content="C++ Korea">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Resource - C++ 핵심 가이드라인</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.1b62728e.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7CNanum+Gothic+Coding&display=fallback">
        <style>body,input{font-family:"Nanum Gothic","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Nanum Gothic Coding","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#reason" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-header-nav__button md-logo">
          
            <img src="../images/logo.svg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              C++ 핵심 가이드라인
            </span>
            <span class="md-header-nav__topic">
              
                Resource
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Introduction/" class="md-tabs__link">
          Introduction
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../References/" class="md-tabs__link">
          References
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Architecture/" class="md-tabs__link md-tabs__link--active">
          Sections
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../appendix/Modernizing/" class="md-tabs__link">
          Appendix
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-nav__button md-logo">
      
        <img src="../images/logo.svg" width="48" height="48">
      
    </a>
    C++ 핵심 가이드라인
  </label>
  
    <div class="md-nav__source">
      


  

<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../home/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Introduction
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Introduction
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Introduction/" title="In: 소개" class="md-nav__link">
      <a name="S-introduction"></a>In: 소개
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      References
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        References
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../References/" title="RF: 레퍼런스" class="md-nav__link">
      <a name="S-references"></a>RF: 레퍼런스
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Sections
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Sections
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Architecture/" title="Architecture" class="md-nav__link">
      Architecture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Class/" title="Class" class="md-nav__link">
      Class
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Concurrency/" title="Concurrency" class="md-nav__link">
      Concurrency
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Const/" title="Const" class="md-nav__link">
      Const
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CPL/" title="C-Style" class="md-nav__link">
      C-Style
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Enum/" title="Enum" class="md-nav__link">
      Enum
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Errors/" title="Errors" class="md-nav__link">
      Errors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Expr/" title="Expr" class="md-nav__link">
      Expr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Functions/" title="Functions" class="md-nav__link">
      Functions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../GSL/" title="GSL" class="md-nav__link">
      GSL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interfaces/" title="Interfaces" class="md-nav__link">
      Interfaces
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Naming/" title="Naming" class="md-nav__link">
      Naming
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Not/" title="Not-Rule" class="md-nav__link">
      Not-Rule
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Performance/" title="Performance" class="md-nav__link">
      Performance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Philosophy/" title="Philosophy" class="md-nav__link">
      Philosophy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Profile/" title="Profile" class="md-nav__link">
      Profile
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Resource" class="md-nav__link md-nav__link--active">
      Resource
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../SL/" title="Standard Library" class="md-nav__link">
      Standard Library
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Source/" title="Source" class="md-nav__link">
      Source
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Templates/" title="Templates" class="md-nav__link">
      Templates
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Unclassified/" title="Unclassified" class="md-nav__link">
      Unclassified
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Appendix
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Appendix
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Modernizing/" title="Modernizing" class="md-nav__link">
      Modernizing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Tools/" title="Tools" class="md-nav__link">
      Tools
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="http://github.com/CppKorea/CppCoreGuidelines/edit/master/docs/Resource.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="r"><a name="S-resource"></a>R: 자원 관리</h1>
<p>이 장은 자원과 관련된 규칙을 포함하고 있다. 
자원이란 획득해야만 하고, (명시적 혹은 묵시적으로) 해제된다. 주로 메모리, 파일 핸들, 소켓, 잠금(lock) 같은 것들이다. 
반드시 해체되어야 하는 이유는 자원 부족인데, 지연된 형태의 해체조차도 이런 문제를 야기할 수 있다.
기본적인 목표는 어떤 자원도 누수가 발생하지 않고, 필요 이상으로 자원을 소유하지 않는 것이다.
자원을 해체하는 책임을 가지는 주체를 우리는 소유자(owner)라고 한다.</p>
<p>드물게 자원 누수가 용인되거나 최선인 경우가 있다:
입력을 기반으로 단순히 출력하는 프로그램을 구현하고 입력에 비례하여 필요한 메모리 양이 증가한다면, (성능과 프로그래밍을 용이하게 하기 위한) 최선의 전략은 어떤 자원도 삭제하지 않는 것이다.
가장 큰 입력을 처리하기 위해서 충분한 메모리를 가졌다면 자원이 소비되도록 내버려 둬라. 다만 뭔가 잘못을 했다면 상황에 알맞는 에러 메시지를 주도록 해라. 이런 경우는 더 이상 언급하지 않겠다.</p>
<p>자원 관리 규칙 요약:</p>
<ul>
<li><a href="#Rr-raii">R.1: 자원 핸들과 RAII(자원 획득시 초기화)를 사용해서 자동적으로 관리되도록 하라</a></li>
<li><a href="#Rr-use-ptr">R.2: 인터페이스에서는, 포인터는 서로 다른 개체들을 표시하기 위해서만 사용하라</a></li>
<li><a href="#Rr-ptr">R.3: 원시 포인터(<code>T*</code>)는 소유를 의미하지 않는다</a></li>
<li><a href="#Rr-ref">R.4: 참조(<code>T&amp;</code>)는 소유를 의미하지 않는다</a></li>
<li><a href="#Rr-scoped">R.5: 유효 범위 안의 개체를 선호하라. 불필요한 동적할당을 하지 마라</a></li>
<li><a href="#Rr-global">R.6: <code>const</code>가 아닌 전역 변수를 지양하라</a></li>
</ul>
<p>할당과 해제 규칙 요약:</p>
<ul>
<li><a href="#Rr-mallocfree">R.10: <code>malloc()</code>과 <code>free()</code>의 사용을 피하라</a></li>
<li><a href="#Rr-newdelete">R.11: 명시적인 <code>new</code>와 <code>delete</code> 호출을 지양하라</a></li>
<li><a href="#Rr-immediate-alloc">R.12: 명시적인 할당의 결과는 즉시 관리 개체에 전달하라</a></li>
<li><a href="#Rr-single-alloc">R.13: 하나의 표현식 구문에서 명시적 자원 할당은 최대 한번만 수행하라</a></li>
<li><a href="#Rr-ap">R.14: ??? 배열 vs. 포인터 매개변수</a></li>
<li><a href="#Rr-pair">R.15: 할당/해제가 짝을 이루도록 중복정의하라</a></li>
</ul>
<p><a name="Rr-summary-smartptrs"></a>스마트 포인터 규칙 요약:</p>
<ul>
<li><a href="#Rr-owner">R.20: 소유권을 나타내기 위해 <code>unique_ptr</code> 혹은 <code>shared_ptr</code>를 사용하라</a></li>
<li><a href="#Rr-unique">R.21: 소유권을 공유할 필요가 없다면 <code>shared_ptr</code>보다는 <code>unique_ptr</code>를 선호하라</a></li>
<li><a href="#Rr-make_shared">R.22: <code>shared_ptr</code>를 만들때는 <code>make_shared()</code>를 사용하라</a></li>
<li><a href="#Rr-make_unique">R.23: <code>unique_ptr</code>를 만들때는 <code>make_unique()</code>를 사용하라</a></li>
<li><a href="#Rr-weak_ptr">R.24: <code>shared_ptr</code>의 순환참조를 부수기 위해 <code>weak_ptr</code>를 사용하라</a></li>
<li><a href="#Rr-smartptrparam">R.30: 수명주기 의미구조를 표현하기 위해서만 스마트 포인터를 매개변수로 사용하라</a></li>
<li><a href="#Rr-smart">R.31: 표준 스마트 포인터를 사용하지 않고 있다면, 표준에서 사용하는 기본 패턴을 사용하라</a></li>
<li><a href="#Rr-uniqueptrparam">R.32: 함수가 <code>widget</code>의 소유권을 맡는다는 것을 표현하기 위해 <code>unique_ptr&lt;widget&gt;</code>를 매개변수로 사용하라</a></li>
<li><a href="#Rr-reseat">R.33: 함수가 <code>widget</code>을 새로 설정한다는 것을 표현하기 위해 <code>unique_ptr&lt;widget&gt;&amp;</code>를 사용하라</a></li>
<li><a href="#Rr-sharedptrparam-owner">R.34: 함수가 소유자 중 하나라는 것을 표현하기 위해 <code>shared_ptr&lt;widget&gt;</code>를 매개변수로 사용하라</a></li>
<li><a href="#Rr-sharedptrparam">R.35: 함수가 공유 포인터를 재설정한다는 것을 표현하기 위해 <code>shared_ptr&lt;widget&gt;&amp;</code>를 매개변수로 사용하라</a></li>
<li><a href="#Rr-sharedptrparam-const">R.36: 함수가 개체에 대한 참조 카운트를 유지한다는 것을 표현하기 위해 <code>const shared_ptr&lt;widget&gt;&amp;</code>을 매개변수로 사용하라 ???</a></li>
<li><a href="#Rr-smartptrget">R.37: 재명명(aliased)된 스마트 포인터에서 획득한 포인터 혹은 참조를 전달하지 마라</a></li>
</ul>
<h3 id="r1-raii"><a name="Rr-raii"></a>R.1: 자원 핸들과 RAII(자원 획득시 초기화)를 사용해서 자동적으로 관리되도록 하라</h3>
<h5 id="reason">Reason</h5>
<p>수동 자원 관리의 복잡성과 누출을 피하기 위한 방법을 알아본다. 
C++ 언어적 강제인 생성자 소멸자 대칭은 <code>fopen</code>/<code>fclose</code>,  그리고 <code>lock</code>/<code>unlock</code>, <code>new</code>/<code>delete</code>과 같은 자원 획득/해체 함수의 짝과 같은 구조를 가진다.</p>
<p>이 특징을 사용해서 자원의 획득/해체시 짝 함수 호출이 필요한 자원을 다룰 때는 생성자에서 자원을 획득하고 소멸자에서 해체가 강제되도록 개체로 리소스를 캡슐화해라.</p>
<h5 id="example-bad">Example, bad</h5>
<p>다음과 같은 경우를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="n">X</span><span class="o">*</span> <span class="n">x</span><span class="p">,</span> <span class="n">cstring_span</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">port</span> <span class="o">=</span> <span class="n">open_port</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
        <span class="n">my_mutex</span><span class="p">.</span><span class="n">lock</span><span class="p">();</span>
        <span class="c1">// ...</span>
        <span class="n">send</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="n">my_mutex</span><span class="p">.</span><span class="n">unlock</span><span class="p">();</span>
        <span class="n">close_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span>
        <span class="k">delete</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>이 코드에서는 모든 경우에 <code>unlock</code>, <code>close_port</code>, <code>delete</code>가 정확히 순서대로 호출되어야 한다는 점을 고려해야 한다. 만약 <code>...</code>로 표시된 코드에서 예외가 던져지면, 그로인해 <code>x</code>는 누출되고 <code>my_mutex</code>는 잠금을 해제하지 않게 된다.</p>
<h5 id="example">Example</h5>
<p>다음과 같은 경우를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">send</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">x</span><span class="p">,</span> <span class="n">cstring_span</span> <span class="n">destination</span><span class="p">)</span>  <span class="c1">// x owns the X</span>
    <span class="p">{</span>
        <span class="n">Port</span> <span class="n">port</span><span class="p">{</span><span class="n">destination</span><span class="p">};</span>            <span class="c1">// port owns the PortHandle</span>
        <span class="n">lock_guard</span><span class="o">&lt;</span><span class="n">mutex</span><span class="o">&gt;</span> <span class="n">guard</span><span class="p">{</span><span class="n">my_mutex</span><span class="p">};</span> <span class="c1">// guard owns the lock</span>
        <span class="c1">// ...</span>
        <span class="n">send</span><span class="p">(</span><span class="n">port</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="c1">// automatically unlocks my_mutex and deletes the pointer in x</span>
</pre></div>


<p>모든 자원 관리가 자동화되었고 예외와 상관없이 모든 경로에서 한번 수행된다. 추가적으로 함수가 포인터 소유권을 가져간 것도 보여주고 있다.</p>
<p><code>Port</code>는 어떻게 구현할 수 있을까? 자원을 캡슐화하는 간단한 래퍼로 구현할 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Port</span> <span class="p">{</span>
        <span class="n">PortHandle</span> <span class="n">port</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Port</span><span class="p">(</span><span class="n">cstring_span</span> <span class="n">destination</span><span class="p">)</span> <span class="o">:</span> <span class="n">port</span><span class="p">{</span><span class="n">open_port</span><span class="p">(</span><span class="n">destination</span><span class="p">)}</span> <span class="p">{</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">Port</span><span class="p">()</span> <span class="p">{</span> <span class="n">close_port</span><span class="p">(</span><span class="n">port</span><span class="p">);</span> <span class="p">}</span>
        <span class="k">operator</span> <span class="n">PortHandle</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">port</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">// port handles can&#39;t usually be cloned, so disable copying and assignment if necessary</span>
        <span class="n">Port</span><span class="p">(</span><span class="k">const</span> <span class="n">Port</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">Port</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Port</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note">Note</h5>
<p>소멸자를 가진 클래스로 표현되지 않고 다루기 힘든 자원인 경우 클래스로 감싸서 자원을 관리하거나 <a href="#S-GSL"><code>finally</code></a>를 사용하라.</p>
<h5 id="see-also">See Also</h5>
<p><a href="#Rr-raii">RAII</a></p>
<h3 id="r2"><a name="Rr-use-ptr"></a>R.2: 인터페이스에서는, 포인터는 서로 다른 개체들을 표시하기 위해서만 사용하라</h3>
<h5 id="reason_1">Reason</h5>
<p>배열은 컨테이너 타입(가령, <code>vector</code>(소유)이나 <code>span</code>(비 소유))으로 가장 잘 표현된다. 이런 컨테이너와 뷰는 범위 검사를 위한 충분한 정보를 가지고 있다.</p>
<h5 id="example-bad_1">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>   <span class="c1">// n is the number of elements in p[]</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">p</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// bad: subscript raw pointer</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>컴파일러 주석을 읽지 않는다. 또한 다른 코드를 읽지 않고는 <code>p</code>가 정말로 <code>n</code> 만큼을 가르키는지 알 수 없다. 
대신 <code>span</code>을 사용하라.</p>
<h5 id="example_1">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">fmt</span><span class="p">)</span>   <span class="c1">// print *p using format #fmt</span>
    <span class="p">{</span>
        <span class="c1">// ... uses *p and p[0] only ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="exception">Exception</h5>
<p>C 스타일 문자열은 0으로 끝나는 문자 배열을 포인터로 전달하기도 한다.
관례를 따른다는 것을 보여주기 위해 <code>char*</code>보다는 <code>zstring</code>을 사용하라</p>
<h5 id="note_1">Note</h5>
<p>하나의 원소를 위해서는 참조자를 사용할 수도 있다. 그러나 <code>nullptr</code>이 가능한 경우라면 참조가 좋은 대안은 아니다.</p>
<h5 id="enforcement">Enforcement</h5>
<p>컨테이너 또는 뷰, 반복자(iterator)가 아닌 포인터에서 주소 계산(++ 포함)을 삼가하라.
이 규칙이 오래된 코드에 적용된다면 수많은 false positive를 만들 수 있다.</p>
<ul>
<li>간단한 포인터로 전달하는 배열 이름을 지적하라</li>
<li>컨테이너, 뷰, 반복자가 아닌 포인터 연산을 지적하라. (이는 <code>++</code>를 포함한다)  </li>
<li>배열을 포인터를 사용해 전달할 경우 지적하라</li>
</ul>
<h3 id="r3-t"><a name="Rr-ptr"></a>R.3: 원시 포인터는(<code>T*</code>) 소유를 의미하지 않는다</h3>
<blockquote>
<p>raw pointer: 원시 포인터</p>
</blockquote>
<h5 id="reason_2">Reason</h5>
<p>C++ 표준 뿐만 아니라 대부분의 경우 원시 포인터는 소유를 하지 않는다.
신뢰할 수 있고 효과적인 방법으로 개체를 제거하기 위해서는 개체를 소유하는 포인터가 필요하다.</p>
<h5 id="example_2">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span>           <span class="c1">// bad: raw owning pointer</span>
        <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>  <span class="c1">// OK: the int is owned by a unique pointer</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p><code>unique_ptr</code>는 개체의 제거를 보장하기 때문에 메모리 누수를 차단해준다. (예외 발생에서도 마찬가지다.) <code>T*</code>는 그렇지 않다.</p>
<h5 id="example_3">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// bad: it is unclear whether p is owning or not</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>   <span class="c1">// bad: it is unclear whether q is owning or not</span>
    <span class="p">};</span>
</pre></div>


<p>명시적인 소유권을 만들어 이 문제를 해결할 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">X2</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">owner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// OK: p is owning</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">q</span><span class="p">;</span>         <span class="c1">// OK: q is not owning</span>
    <span class="p">};</span>
</pre></div>


<h5 id="exception_1">Exception</h5>
<p>주요 예외사항은 레거시 코드라고 할 수 있다. 특히 ABI를 통해서 C 혹은 C 스타일 C++ 인터페이스와 호환성을 가져야 하는 경우가 그렇다. <code>T*</code>를 소유하는 방식을 위반하는 억 단위의 코드가 존재한다는 사실을 무시할 수는 없다.
20년 묵은 "레거시" 코드를 최신 C++ 코드로 변환할 수 있는 툴이 있으면 좋을것이다. 이런 툴의 개발과 툴의 사용을 독려할것이고 또한 이 가이드라인이 도움이 되었으면 좋겠다. 
가시적인 성과가 보일때까지 몇 년은 더 걸릴것이다: 최신 코드로 바꿀수 있게 되기전에 "레거시 코드"가 더 빠르게 생성될지도 모른다.</p>
<p>이 모든 코드는 다시 작성 될순 없고 (좋은 코드 변환 소프트웨어가 있더라도) 적어도 당장은 아닐것이다. 이 문제는 모든 포인터를 <code>unique_ptr</code>와 <code>shared_ptr</code>로 대체하는 것으로는 해결할 수 없다. 부분적으로 이는 기초적인 자원 핸들을 구현할때, 마치 내부의 단순한 포인터들처럼 소유하는 원시 포인터들을 사용하고 또 필요로 하기 때문이다.</p>
<p>예를 들어, 일반적인 <code>vector</code>구현은 하나의 소유하는 포인터와 두개의 소유하지 않는 포인터들을 가진다.
많은 ABI들(그리고 특히 C 코드로 이어지는 모든 인터페이스들)은 <code>T*</code>를 사용한다. 어떤 경우는 소유를 의미하기도 한다. C와 호환성을 유지해야 한다면 단순히 <code>owner</code>를 사용할(annotate) 수 없다.
(이런 경우는 <code>owner</code>가 C++에서만 적용되도록 하는 매크로가 좋은 사용이 될 수도 있다).</p>
<h5 id="note_2">Note</h5>
<p><code>owner&lt;T*&gt;</code>에는 <code>T*</code>이상의 의미가 없다. 이를 사용하는 코드를 변경하거나 ABI에 영향을 주지 않으면서 사용할 수 있다. </p>
<p>이 타입은 프로그래머와 분석도구들을 위한 지표일 뿐이다.
예를 들어, <code>owner&lt;T*&gt;</code>가 어떤 클래스의 멤버라면, 그 클래스는 해당 멤버를 <code>delete</code>하는 소멸자를 가지는 것이 나을 것이다. </p>
<h5 id="example-bad_2">Example, bad</h5>
<p>원시 포인터를 반환하는것은 호출자에게 수명 관리에 불확실성을 심어준다; 다시 말해, 누가 포인터를 통해 개체를 제거해야 하는가?</p>
<div class="codehilite"><pre><span></span>    <span class="n">Gadget</span><span class="o">*</span> <span class="nf">make_gadget</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gadget</span><span class="p">{</span><span class="n">n</span><span class="p">};</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">caller</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_gadget</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>   <span class="c1">// remember to delete p</span>
        <span class="c1">// ...</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p><a href="#???">leak</a>으로 인한 고통뿐만 아니라 이는 쓸데없이 많고 미심쩍은 할당과 해제를 야기할 수 있다. 
만약 Gadget을 함수 바깥으로 가져오는 비용이 크지 않다면, 단순히 값으로 반환하는 것도 한 방법이다. (<a href="#Rf-out">"out" 반환</a> 항목을 보라):</p>
<div class="codehilite"><pre><span></span>    <span class="n">Gadget</span> <span class="nf">make_gadget</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Gadget</span> <span class="n">g</span><span class="p">{</span><span class="n">n</span><span class="p">};</span>
        <span class="c1">// ...</span>
        <span class="k">return</span> <span class="n">g</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_3">Note</h5>
<p>이 규칙은 팩토리 함수에 적용될 수 있다.</p>
<h5 id="note_4">Note</h5>
<p>만약 포인터 의미구조가 필요하다면 (상위 클래스(인터페이스)를 참조한다거나), 스마트 포인터를 반환하라</p>
<h5 id="enforcement_1">Enforcement</h5>
<ul>
<li>(쉬움) <code>owner&lt;T&gt;</code>가 아닌 원시 포인터를 <code>delete</code>하면 경고하라.</li>
<li>(중간) Warn on failure to either <code>reset</code> or explicitly <code>delete</code> an <code>owner&lt;T&gt;</code> pointer on every code path.</li>
<li>(쉬움) <code>new</code>의 결과가 원시 포인터에 대입된다면 경고하라.</li>
<li>(쉬움) 함수 안에서 이동 생성이 가능한 개체가 할당되는 경우 경고하라. 대신 값으로 반환하는 것을 고려하도록 제안하라</li>
</ul>
<h3 id="r4-tamp"><a name="Rr-ref"></a>R.4: 참조는(<code>T&amp;</code>) 소유를 의미하지 않는다</h3>
<h5 id="reason_3">Reason</h5>
<p>C++ 표준뿐만 아니라 대부분의 경우 참조는 소유를 하지 않는다. 
신뢰할 수 있고 효과적인 방법으로 개체를 제거하기 위해서는 개체를 소유하는 포인터가 필요하다.</p>
<h5 id="example_4">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="kt">int</span><span class="o">&amp;</span> <span class="n">r</span> <span class="o">=</span> <span class="o">*</span><span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">7</span><span class="p">};</span>  <span class="c1">// bad: raw owning reference</span>
        <span class="c1">// ...</span>
        <span class="k">delete</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">;</span>             <span class="c1">// bad: violated the rule against deleting raw pointers</span>
    <span class="p">}</span>
</pre></div>


<h5 id="see-also_1">See Also</h5>
<p><a href="#Rr-ptr">원시 포인터 규칙들</a></p>
<h5 id="enforcement_2">Enforcement</h5>
<p><a href="#Rr-ptr">원시 포인터 규칙들</a>을 보라</p>
<h3 id="r5"><a name="Rr-scoped"></a>R.5: 유효 범위 안의 개체를 선호하라. 불필요한 동적할당을 하지 마라</h3>
<h5 id="reason_4">Reason</h5>
<p>유효범위 내 개체는 지역 개체, 전역 개체, 혹은 멤버를 의미한다. 이는 해당 시점의 범위 내에서 별도의 할당/해제 비용이 발생하지 않는다는 것을 의미한다.
유효범위 내 개체의 멤버들은 생성자와 소멸자에 의해 수명이 관리된다.</p>
<h5 id="example_5">Example</h5>
<p>다음 예는 불필요한 할당화 해제를 하기 떄문에 비효율적이고, 예외에 취약하며, <code>...</code> 부분에서는 누수가 발생할 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Gadget</span><span class="p">{</span><span class="n">n</span><span class="p">};</span>
        <span class="c1">// ...</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>대신, 지역 변수를 사용하라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Gadget</span> <span class="n">g</span><span class="p">{</span><span class="n">n</span><span class="p">};</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_3">Enforcement</h5>
<ul>
<li>(중간) 함수 내의 모든 경로에서 개체가 할당되고 해제된다면 경고하라. 스택을 사용하는 지역 <code>auto</code> 개체를 사용하도록 제안하라.</li>
<li>(단순) 지역적으로 사용된 <code>unique_ptr</code> 또는 <code>shared_ptr</code>가 이동, 복사, 대입되거나 소멸하기 전에 <code>reset</code>되면 경고하라.</li>
</ul>
<h3 id="r6-const"><a name="Rr-global"></a>R.6: <code>const</code>가 아닌 전역 변수를 지양하라</h3>
<h5 id="reason_5">Reason</h5>
<p>전역 변수는 모든 곳에서 접근될 수 있고 명백히 관련 없는 개체들 사이에 말도 안되는 의존성을 만들 수 있다. 오류의 원인 중 잘 알려진 것이기도 하다.</p>
<p><strong>경고</strong>: 전역 개체의 초기화 순서는 보장되지 않는다. 상수로 전역 개체를 초기화하고 싶다면, <code>const</code> 개체에 대해서도 초기화 순서가 정의되지 않았을 수 있다는 점을 명심하라.</p>
<h5 id="exception_2">Exception</h5>
<p>싱글톤 패턴 보다는 전역 개체가 나을 수도 있다.</p>
<h5 id="exception_3">Exception</h5>
<p>변경할 수 없는(<code>const</code>) 전역 개체는 이런 문제를 발생시키지 않는다.</p>
<h5 id="enforcement_4">Enforcement</h5>
<p>(??? NM: <code>const</code>가 아닌 static 변수들에 대해서도 경고할 수 있을 것 같은데 ... 그렇게 해야 하는가?)</p>
<h2 id="ralloc"><a name="SS-alloc"></a>R.alloc: 할당과 해제</h2>
<h3 id="r10-malloc-free"><a name="Rr-mallocfree"></a>R.10: <code>malloc()</code>과 <code>free()</code>의 사용을 피하라</h3>
<h5 id="reason_6">Reason</h5>
<p><code>malloc()</code>과 <code>free()</code>는 생성자와 소멸자를 지원하지 않는다. <code>new</code> 과 <code>delete</code>와 섞어서 사용하지 마라.</p>
<h5 id="example_6">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Record</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">id</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// p1 may be nullptr</span>
        <span class="c1">// *p1 is not initialized; in particular,</span>
        <span class="c1">// that string isn&#39;t a string, but a string-sized bag of bits</span>
        <span class="n">Record</span><span class="o">*</span> <span class="n">p1</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Record</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Record</span><span class="p">)));</span>

        <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Record</span><span class="p">;</span>

        <span class="c1">// unless an exception is thrown, *p2 is default initialized</span>
        <span class="k">auto</span> <span class="n">p3</span> <span class="o">=</span> <span class="k">new</span><span class="p">(</span><span class="n">nothrow</span><span class="p">)</span> <span class="n">Record</span><span class="p">;</span>
        <span class="c1">// p3 may be nullptr; if not, *p3 is default initialized</span>

        <span class="c1">// ...</span>

        <span class="k">delete</span> <span class="n">p1</span><span class="p">;</span>    <span class="c1">// error: cannot delete object allocated by malloc()</span>
        <span class="n">free</span><span class="p">(</span><span class="n">p2</span><span class="p">);</span>    <span class="c1">// error: cannot free() object allocated by new</span>
    <span class="p">}</span>
</pre></div>


<p><code>delete</code>나 <code>free()</code>가 동작할 수도 있지만, 실행시간 오류를 발생시킬수도 있다.</p>
<h5 id="exception_4">Exception</h5>
<p>예외가 허용되지 않는 응용 프로그램이나 코드 구간이 있다. 생명이 달려있어서 주어진 시간 안에 반응해야 하는(life-critical hard-real-time) 경우가 이에 해당한다.
많은 예외에 대한 금지사항(ban)들이 (나쁜) 미신 혹은 체계적으로 자원을 관리하지 않은(불행하게도, 종종 필요한 경우가 생긴다) 오래된 코드에서 부터 나온 걱정에서 나왔다는 점을 인지하라.
그런 경우, <code>new</code> 연산자의 <code>nothrow</code> 버전을 고려하라</p>
<h5 id="enforcement_5">Enforcement</h5>
<p>명시적인  <code>malloc</code>과 <code>free</code>의 사용을 지적하라</p>
<h3 id="r11-new-delete"><a name="Rr-newdelete"></a>R.11: 명시적인 <code>new</code>와 <code>delete</code> 호출을 지양하라</h3>
<h5 id="reason_7">Reason</h5>
<p><code>new</code>로 반환된 포인터는 리소스 핸들(<code>delete</code>를 호출할 수 있는)에 종속되어야 한다.
<code>new</code>로 반환된 포인터가 원시 포인터에 할당되면 누수가 발생할 수 있다.</p>
<h5 id="note_5">Note</h5>
<p>규모가 큰 프로그램에서, 노출된 <code>delete</code>는 (이는 자원을 관리하는 코드가 아닌 다른 응용 프로그램 코드에 <code>delete</code>가 있는 경우를 의미한다) 버그와 같다: 만약 N번의 <code>delete</code> 호출이 있다면, N+1번 혹은 N-1번이 필요한지 어떻게 확신할 수 있겠는가?</p>
<p>버그가 숨어있을 수도 있다: 유지보수 중에 새롭게 나타날수도 있다.</p>
<p>노출된 <code>new</code>가 있다면, 아마도 어디선가 노출된 <code>delete</code>가 필요할 것이다. 그렇다면 버그가 있을 가능성이 높다.</p>
<h5 id="enforcement_6">Enforcement</h5>
<p>(단순) <code>new</code>와 <code>delete</code>가 명시적으로 사용되면 경고하라. 대신 <code>make_unique</code>를 사용하도록 제안하라.</p>
<h3 id="r12"><a name="Rr-immediate-alloc"></a>R.12: 명시적인 할당의 결과는 즉시 관리 개체에 전달하라</h3>
<h5 id="reason_8">Reason</h5>
<p>그렇지 않으면, 예외나 반환이 자원 누수를 야기할 수 있다.</p>
<h5 id="example-bad_3">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>            <span class="c1">// open the file</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">_</span> <span class="o">=</span> <span class="n">finally</span><span class="p">([</span><span class="n">f</span><span class="p">]</span> <span class="p">{</span> <span class="n">fclose</span><span class="p">(</span><span class="n">f</span><span class="p">);</span> <span class="p">});</span>  <span class="c1">// remember to close the file</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p><code>buf</code>에서의 할당은 실패할 수 있고 그 경우 파일 핸들의 누수가 발생한다.</p>
<h5 id="example_7">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ifstream</span> <span class="n">f</span><span class="p">{</span><span class="n">name</span><span class="p">};</span>   <span class="c1">// open the file</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">buf</span><span class="p">(</span><span class="mi">1024</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>이와 같은 (<code>ifstream</code> 내부의) 파일 핸들 사용은 단순하며, 효과적이고, 안전하다.</p>
<h5 id="enforcement_7">Enforcement</h5>
<ul>
<li>포인터를 초기화하기 위해 명시적인 할당을 했다면 지적하라 (문제: 직접적인 자원 할당을 얼마나 많이 인지할 수 있을 것인가?)</li>
</ul>
<h3 id="r13"><a name="Rr-single-alloc"></a>R.13: 하나의 표현식 구문에서 명시적 자원 할당은 최대 한번만 수행하라</h3>
<h5 id="reason_9">Reason</h5>
<p>한 구문에서 두번의 명시적 자원 할당을 수행하면, 함수 인자를 포함해 하위 표현식의 불특정한 평가 순서에 따라 자원 누수가 발생할수도 있다. </p>
<h5 id="example_8">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">fun</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">,</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp2</span><span class="p">);</span>
</pre></div>


<p>이 <code>fun</code>호출은 아래와 같을 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// BAD: potential leak</span>
    <span class="n">fun</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">)),</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">)));</span>
</pre></div>


<p>이는 예외 안전하지 않은데, 컴파일러가 함수의 두 인자를 생성하면서 순서를 바꿀 수도 있기 때문이다.</p>
<p>특히, 컴파일러는 두 표현식을 뒤섞어(interleave) 수행할수도 있다: (<code>operator new</code>를 호출함으로써) 두 개체의 메모리 할당이 먼저 수행되고, <code>Widget</code>의 생성자를 호출하려는 시도가 이어질 것이다. 만약 둘 중 하나가 예외를 던지면, 다른 한 개체는 해제되지 않는다!</p>
<p>이 미묘한 문제의 해결책은 간단하다: 한 표현식 구문 내에서 명시적 자원 할당을 한번 이상 하지마라.</p>
<p>예를 들어:</p>
<div class="codehilite"><pre><span></span>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span> <span class="n">sp1</span><span class="p">(</span><span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">));</span> <span class="c1">// Better, but messy</span>
    <span class="n">fun</span><span class="p">(</span><span class="n">sp1</span><span class="p">,</span> <span class="k">new</span> <span class="n">Widget</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">));</span>
</pre></div>


<p>최상의 해결책은 소유하는 개체를 반환하는 팩토리 함수를 사용해서 명시적 할당을 완전히 피하는 것이다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">fun</span><span class="p">(</span><span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">),</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Widget</span><span class="o">&gt;</span><span class="p">(</span><span class="n">c</span><span class="p">,</span> <span class="n">d</span><span class="p">));</span> <span class="c1">// Best</span>
</pre></div>


<p>팩토리 함수를 사용하고 있지 않다면 새롭게 작성하라.</p>
<h5 id="enforcement_8">Enforcement</h5>
<ul>
<li>표현식 내에서 여러번의 명시적 자원 할당이 있다면 경고하라(문제: 직접적인 자원 할당을 얼마나 많이 인지할 수 있을 것인가?)</li>
</ul>
<h3 id="r14-vs"><a name="Rr-ap"></a>R.14: ??? 배열 vs. 포인터 매개변수</h3>
<blockquote>
<p>역주:
* Parameter: 매개변수
* Argument: 전달인자</p>
</blockquote>
<h5 id="reason_10">Reason</h5>
<p>배열은 포인터로 축약(decay)되고, 그 결과 길이를 알 수 없게 된다. 이로 인해 범위 오류가 발생할 수 있다.</p>
<h5 id="example_9">Example</h5>
<div class="codehilite"><pre><span></span>    ??? what do we recommend: f(int*[]) or f(int**) ???
</pre></div>


<h5 id="alternative">Alternative</h5>
<p>길이 정보를 유지하기 위해 <code>span</code>을 사용하라</p>
<h5 id="enforcement_9">Enforcement</h5>
<p>매개변수에 <code>[]</code>가 사용되면 지적하라.</p>
<h3 id="r15"><a name="Rr-pair"></a>R.15: 할당/해제가 짝을 이루도록 중복정의하라</h3>
<h5 id="reason_11">Reason</h5>
<p>연산이 불일치하면 혼돈을 겪게 될 것이다.</p>
<h5 id="example_10">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="kt">void</span><span class="o">*</span> <span class="k">operator</span> <span class="k">new</span><span class="p">(</span><span class="kt">size_t</span> <span class="n">s</span><span class="p">);</span>
        <span class="kt">void</span> <span class="k">operator</span> <span class="nf">delete</span><span class="p">(</span><span class="kt">void</span><span class="o">*</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note_6">Note</h5>
<p>할당한 후 해제되지 않는 메모리를 원한다면, 해제 연산에 <code>=delete</code>를 사용하라. 선언이 없는 채로 남겨두지 마라.</p>
<h5 id="enforcement_10">Enforcement</h5>
<p>연산이 짝을 이루지 않으면 지적한다.</p>
<h2 id="rsmart"><a name="SS-smart"></a>R.smart: 스마트 포인터</h2>
<h3 id="r20-unique_ptr-shared_ptr"><a name="Rr-owner"></a>R.20: 소유권을 나타내기 위해 <code>unique_ptr</code> 혹은 <code>shared_ptr</code>를 사용하라</h3>
<h5 id="reason_12">Reason</h5>
<p>자원 누수를 막을 수 있다.</p>
<h5 id="example_11">Example</h5>
<p>다음과 같은 경우를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">X</span><span class="o">*</span> <span class="n">p1</span> <span class="p">{</span> <span class="k">new</span> <span class="n">X</span> <span class="p">};</span>              <span class="c1">// see also ???</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p2</span> <span class="p">{</span> <span class="k">new</span> <span class="n">X</span> <span class="p">};</span>   <span class="c1">// unique ownership; see also ???</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">p3</span> <span class="p">{</span> <span class="k">new</span> <span class="n">X</span> <span class="p">};</span>   <span class="c1">// shared ownership; see also ???</span>
        <span class="k">auto</span> <span class="n">p4</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">();</span>   <span class="c1">// unique_ownership, preferable to the explicit use &quot;new&quot;</span>
        <span class="k">auto</span> <span class="n">p5</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">();</span>   <span class="c1">// shared ownership, preferable to the explicit use &quot;new&quot;</span>
    <span class="p">}</span>
</pre></div>


<p>위 코드는 <code>p1</code>를 초기화하는데 사용된 개체에(만) 누수가 발생한다.</p>
<h5 id="enforcement_11">Enforcement</h5>
<p>(단순) <code>new</code> 혹은 포인터 타입의 반환값이 원시 포인터에 대입되면 경고한다.</p>
<h3 id="r21-shared_ptr-unique_ptr"><a name="Rr-unique"></a>R.21: 소유권을 공유할 필요가 없다면 <code>shared_ptr</code>보다는 <code>unique_ptr</code>를 선호하라</h3>
<h5 id="reason_13">Reason</h5>
<p><code>unique_ptr</code>는 개념적으로 단순하고 예측가능하며(파괴가 일어날 때를 알고) 빠르다 (사용 횟수를 암시적으로 관리하지 않는다).</p>
<h5 id="example-bad_4">Example, bad</h5>
<p>이 코드는 불필요하게 참조 횟수를 증가 및 유지하고 있다.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">base</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// use base locally, without copying it -- refcount never exceeds 1</span>
    <span class="p">}</span> <span class="c1">// destroy base</span>
</pre></div>


<h5 id="example_12">Example</h5>
<p>이 코드가 더 효율적이다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">base</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Derived</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// use base locally</span>
    <span class="p">}</span> <span class="c1">// destroy base</span>
</pre></div>


<h5 id="enforcement_12">Enforcement</h5>
<p>(쉬움) 만약 함수 내에서 개체 할당에 <code>shared_ptr</code>을 사용하지만, <code>shared_ptr</code>을 리턴하지 않거나 <code>shared_ptr&amp;</code>를 필요로 하는 함수에 전달하고 있다면 경고하라. 대신 <code>unique_ptr</code> 사용을 권하라.</p>
<h3 id="r22-shared_ptr-make_shared"><a name="Rr-make_shared"></a>R.22: <code>shared_ptr</code>를 만들때는 <code>make_shared()</code>를 사용하라</h3>
<h5 id="reason_14">Reason</h5>
<p>만약 개체를 처음 만들고 <code>shared_ptr</code>의 생성자에 전달하면, <code>make_shared()</code>를 사용할 때보다 (거의 확실히) 할당(그리고 나중의 해제)을 한번 더 하게 된다. 개체와는 독립적으로 참조 카운트를 할당해야 하기 때문이다.</p>
<h5 id="example_13">Example</h5>
<p>다음과 같은 경우를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span> <span class="n">p1</span> <span class="p">{</span> <span class="k">new</span> <span class="n">X</span><span class="p">{</span><span class="mi">2</span><span class="p">}</span> <span class="p">};</span> <span class="c1">// bad</span>
    <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>    <span class="c1">// good</span>
</pre></div>


<p><code>make_shared()</code> 버전은 <code>X</code>가 단 한 번만 사용되며, 그렇기에 명시적으로 <code>new</code>를 사용하는 버전보다 코드가 짧다(게다가 빠르다).</p>
<h5 id="enforcement_13">Enforcement</h5>
<p>(쉬움) <code>shared_ptr</code>가 <code>make_shared</code>가 아니라 <code>new</code>의 결과에서 생성되면 경고한다.</p>
<h3 id="r23-unique_ptr-make_unique"><a name="Rr-make_unique"></a>R.23: <code>unique_ptr</code>를 만들때는 <code>make_unique()</code>를 사용하라</h3>
<h5 id="reason_15">Reason</h5>
<p>편리하며 <code>shared_ptr</code>와 일관성을 가진다.</p>
<h5 id="note_7">Note</h5>
<p><code>make_unique()</code>는 C++14 에 해당하지만, 별 문제 없이 사용할 수 있다. (쉽게 작성할 수 있다)</p>
<h5 id="enforcement_14">Enforcement</h5>
<p>(쉬움) <code>unique_ptr</code>가 <code>make_unique</code>가 아니라 <code>new</code>의 결과로부터 생성된다면 경고하라</p>
<h3 id="r24-shared_ptr-weak_ptr"><a name="Rr-weak_ptr"></a>R.24: <code>shared_ptr</code>의 순환참조를 부수기 위해 <code>weak_ptr</code>를 사용하라</h3>
<h5 id="reason_16">Reason</h5>
<p><code>shared_ptr</code>은 참조 카운트를 사용하는데, 순환 구조에서 이는 절대로 0이 되지 않는다.  때문에 우리는 순환 구조를 파괴할 수 있는 방법이 필요하다.</p>
<h5 id="example_14">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;memory&gt;</span><span class="cp"></span>

    <span class="k">class</span> <span class="nc">bar</span><span class="p">;</span>

    <span class="k">class</span> <span class="nc">foo</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">explicit</span> <span class="n">foo</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">bar</span><span class="o">&gt;&amp;</span> <span class="n">forward_reference</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">forward_reference_</span><span class="p">(</span><span class="n">forward_reference</span><span class="p">)</span>
      <span class="p">{</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">bar</span><span class="o">&gt;</span> <span class="n">forward_reference_</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">bar</span>
    <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">explicit</span> <span class="n">bar</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;&amp;</span> <span class="n">back_reference</span><span class="p">)</span>
        <span class="o">:</span> <span class="n">back_reference_</span><span class="p">(</span><span class="n">back_reference</span><span class="p">)</span>
      <span class="p">{</span> <span class="p">}</span>
      <span class="kt">void</span> <span class="n">do_something</span><span class="p">()</span>
      <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">shared_back_reference</span> <span class="o">=</span> <span class="n">back_reference_</span><span class="p">.</span><span class="n">lock</span><span class="p">())</span> <span class="p">{</span>
          <span class="c1">// Use *shared_back_reference</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
      <span class="n">std</span><span class="o">::</span><span class="n">weak_ptr</span><span class="o">&lt;</span><span class="n">foo</span><span class="o">&gt;</span> <span class="n">back_reference_</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note_8">Note</h5>
<p>??? (HS: 많은 사람들은 "순환을 끊는"이라고 말하는 반면 나는 "일시적인 임시 공유"가 더 적절하다고 생각한다.) <br />
??? (BS: 순환 끊기는 반드시 해야할 일인데, 어떻게 "일시적인 소유권 공유"를 할 것인가. <code>shared_ptr</code>을 사용함으로써 "일시적으로 소유권 공유"를 할 수 있다.)</p>
<h5 id="enforcement_15">Enforcement</h5>
<p>??? 아마도 불가능하다. 정적으로 순환 구조를 찾아낼 수 있다면, <code>weak_ptr</code>를 사용할 필요가 없다.</p>
<h3 id="r30"><a name="Rr-smartptrparam"></a>R.30: 수명주기 의미구조를 표현하기 위해서만 스마트 포인터를 매개변수로 사용하라</h3>
<h5 id="reason_17">Reason</h5>
<p>그저 <code>widget</code>그 자체만 필요한 함수에서 <code>widget</code>에 대한 스마트 포인터를 받는 것은 잘못된 것이다.
그런 함수는 특정한 종류의 스마트 포인터에 의해서 수명주기가 관리되는 <code>widget</code>이 아니라 어떤 <code>widget</code>개체라도 받을 수 있어야 한다. 
수명주기에 영향을 주지 않는 함수는 원시 포인터 혹은 참조를 사용해야 한다.</p>
<h5 id="example-bad_5">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// callee</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span> <span class="n">w</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">use</span><span class="p">(</span><span class="o">*</span><span class="n">w</span><span class="p">);</span> <span class="c1">// only use of w -- the lifetime is not used at all</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="c1">// caller</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">my_widget</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">my_widget</span><span class="p">);</span>

    <span class="n">widget</span> <span class="n">stack_widget</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">stack_widget</span><span class="p">);</span> <span class="c1">// error</span>
</pre></div>


<h5 id="example-good">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// callee</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">use</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="c1">// caller</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">my_widget</span> <span class="o">=</span> <span class="cm">/* ... */</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">my_widget</span><span class="p">);</span>

    <span class="n">widget</span> <span class="n">stack_widget</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">stack_widget</span><span class="p">);</span> <span class="c1">// ok -- now this works</span>
</pre></div>


<h5 id="enforcement_16">Enforcement</h5>
<ul>
<li>(쉬움) 함수가 복사 가능한 스마트 포인터 타입(<code>operator-&gt;</code> 혹은 <code>operator*</code>를 중복정의한 타입)을 매개변수로 받고, 함수 내에서 <code>operator*</code>, <code>operator-&gt;</code> 혹은 <code>get()</code>만 사용하는 경우 경고하라.<br />
<code>T*</code>혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>스마트 포인터 타입 매개변수를 지적하라. 이때 해당 타입은 복사/이동이 가능하지만 함수 내에서 복사/이동되지 않고, 변경되지 않으며, 다른 함수로 전달되지 않아야 한다. 이는 소유권 의미구조가 사용되지 않는다는 것을 의미한다.<br />
<code>T*</code>혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
</ul>
<h3 id="r31"><a name="Rr-smart"></a>R.31: 표준 스마트 포인터를 사용하지 않고 있다면, 표준에서 사용하는 기본 패턴을 사용하라</h3>
<h5 id="reason_18">Reason</h5>
<p>다음 섹션들의 규칙들 또한 다른 종류의 서드파티 혹은 커스텀 스마트 포인터 등에서도 동작할 것이며 성능과 정확성 문제를 일으키는 흔한 스마트 포인터 에러에 대한 분석에 매우 유용할 것이다. 당신은 사용하고 있는 모든 스마트 포인터에 대해서 이 규칙이 작동해야 한다.</p>
<p>스마트 포인터는 단항 연산자 <code>*</code>와 <code>-&gt;</code>를 오버로드하는 (기본 또는 특수 템플릿을 포함한) 타입을 의미한다:</p>
<ul>
<li>복사할 수 있다면, 참조 카운트를 유지하는 <code>shared_ptr</code>처럼 동작한다</li>
<li>복사할 수 없다면, 고유한 <code>unique_ptr</code>처럼 동작한다</li>
</ul>
<h5 id="example_15">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// use Boost&#39;s intrusive_ptr</span>
    <span class="cp">#include</span> <span class="cpf">&lt;boost/intrusive_ptr.hpp&gt;</span><span class="cp"></span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">boost</span><span class="o">::</span><span class="n">intrusive_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span>  <span class="c1">// error under rule &#39;sharedptrparam&#39;</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="c1">// use Microsoft&#39;s CComPtr</span>
    <span class="cp">#include</span> <span class="cpf">&lt;atlbase.h&gt;</span><span class="cp"></span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">CComPtr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span>               <span class="c1">// error under rule &#39;sharedptrparam&#39;</span>
    <span class="p">{</span>
        <span class="n">p</span><span class="o">-&gt;</span><span class="n">foo</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>


<p>두 경우 모두 <a href="#Rr-smartptrparam"><code>sharedptrparam</code> 가이드라인</a>에 맞지 않는다:<br />
<code>p</code>는 <code>shared_ptr</code>이지만, 공유에 대해서는 아무것도 하지 않고 있으며, 값에 의한 전달은 비효율적이다;
이 함수들이 widget의 생명주기에 영향을 미친다면 스마트 포인터를 넘겨받아야만 한다. 
widget이 <code>nullptr</code>이 될 수 있다면 <code>widget*</code>를 넘겨받아야 하고, 그게 아닌 이상적인 상황은 함수가 <code>widget&amp;</code>를 넘겨받아야 한다.</p>
<p>이 스마트 포인터들은 <code>shared_ptr</code> 개념에 부합한다. 때문에 이 규칙은 고정관념과는 다르게 흔히 발생할 수 있는 비효율을 노출시킨다.</p>
<h3 id="r32-widget-unique_ptrltwidgetgt"><a name="Rr-uniqueptrparam"></a>R.32: 함수가 <code>widget</code>의 소유권을 맡는다는 것을 표현하기 위해 <code>unique_ptr&lt;widget&gt;</code>를 매개변수로 사용하라</h3>
<h5 id="reason_19">Reason</h5>
<p><code>unique_ptr</code>를 사용하는 것은 함수를 문서화하면서 호출할 때 소유권 전달을 강제한다.</p>
<h5 id="example_16">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">sink</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span><span class="p">);</span> <span class="c1">// takes ownership of the widget</span>

    <span class="kt">void</span> <span class="nf">uses</span><span class="p">(</span><span class="n">widget</span><span class="o">*</span><span class="p">);</span>            <span class="c1">// just uses the widget</span>
</pre></div>


<h5 id="example-bad_6">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">thinko</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// usually not what you want</span>
</pre></div>


<h5 id="enforcement_17">Enforcement</h5>
<ul>
<li>(단순) 함수가 <code>unique_ptr&lt;T&gt;</code> 매개변수를 lvalue 참조로 받아 새로운 개체를 대입하거나 최소 한 경로에서 <code>reset()</code>을 호출하지 않으면 경고하라. <code>T*</code>혹은 <code>T&amp;</code>의 사용을 제안하라</li>
<li>(단순) ((기본사항)) 함수가 <code>unique_ptr&lt;T&gt;</code>의 <code>const</code> 참조를 매개변수로 받는다면 경고하라. <code>const T*</code> 혹은 <code>const T&amp;</code>를 대신 사용하도록 제안하라.</li>
</ul>
<h3 id="r33-widget-unique_ptrltwidgetgtamp"><a name="Rr-reseat"></a>R.33: 함수가 <code>widget</code>을 새로 설정한다는 것을 표현하기 위해 <code>unique_ptr&lt;widget&gt;&amp;</code>를 사용하라</h3>
<h5 id="reason_20">Reason</h5>
<p>이렇게 <code>unique_ptr</code>를 사용하는 것은 함수를 문서화하고 함수 호출의 재설정(reseating) 의미구조를 강제한다.</p>
<h5 id="note_9">Note</h5>
<p>재설정(reseat)은 "포인터 혹은 스마트 포인터가 다른 개체를 참조하도록 만드는 것"을 의미한다.</p>
<h5 id="example_17">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">reseat</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// &quot;will&quot; or &quot;might&quot; reseat pointer</span>
</pre></div>


<h5 id="example-bad_7">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">thinko</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// usually not what you want</span>
</pre></div>


<h5 id="enforcement_18">Enforcement</h5>
<ul>
<li>(단순) 함수가 <code>unique_ptr&lt;T&gt;</code> 매개변수를 lvalue 참조로 받아 새로운 개체를 대입하거나 최소 한 경로에서 <code>reset()</code>을 호출하지 않으면 경고하라. <code>T*</code>혹은 <code>T&amp;</code>의 사용을 제안하라</li>
<li>(단순) ((기본사항)) 함수가 <code>unique_ptr&lt;T&gt;</code>의 <code>const</code> 참조를 매개변수로 받는다면 경고하라. <code>const T*</code> 혹은 <code>const T&amp;</code>를 대신 사용하도록 제안하라.</li>
</ul>
<h3 id="r34-shared_ptrltwidgetgt"><a name="Rr-sharedptrparam-owner"></a>R.34: 함수가 소유자 중 하나라는 것을 표현하기 위해 <code>shared_ptr&lt;widget&gt;</code>를 매개변수로 사용하라</h3>
<h5 id="reason_21">Reason</h5>
<p>이는 함수가 소유권을 공유한다는 것을 명시적으로 만든다.</p>
<h5 id="example-good_1">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">share</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span><span class="p">);</span>            <span class="c1">// share -- &quot;will&quot; retain refcount</span>

    <span class="kt">void</span> <span class="nf">may_share</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// &quot;might&quot; retain refcount</span>

    <span class="kt">void</span> <span class="nf">reseat</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span>          <span class="c1">// &quot;might&quot; reseat ptr</span>
</pre></div>


<h5 id="enforcement_19">Enforcement</h5>
<ul>
<li>(쉬움) 함수가 <code>shared_ptr&lt;T&gt;</code>를 lvalue 참조로 받으면서 새로운 개체를 대입하지 않고 최소 한 경로에서 <code>reset()</code>을 호출하지 않는다면 경고하라. 대신 <code>T*</code> 혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>(쉬움) ((기본사항)) 함수가 <code>shared_ptr&lt;T&gt;</code>를 값 혹은 <code>const</code> 참조로 전달 받으면서 최소 한 경로에서 다른 <code>shared_ptr</code>에 복사하거나 이동하지 않으면 경고하라. 대신 <code>T*</code> 혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>(쉬움) ((기본사항)) <code>shared_ptr&lt;T&gt;</code>을 rvalue 참조로 전달받으면 경고하라. 대신 값으로 전달받도록 제안하라.</li>
</ul>
<h3 id="r35-shared_ptrltwidgetgtamp"><a name="Rr-sharedptrparam"></a>R.35: 함수가 공유 포인터를 재설정한다는 것을 표현하기 위해 <code>shared_ptr&lt;widget&gt;&amp;</code>를 매개변수로 사용하라</h3>
<h5 id="reason_22">Reason</h5>
<p>이는 함수가 값을 변경한다는 것을 명시적으로 드러낸다.</p>
<h5 id="note_10">Note</h5>
<p>재설정(reseat)은 "포인터 혹은 스마트 포인터가 다른 개체를 참조하도록 만드는 것"을 의미한다.</p>
<h5 id="example-good_2">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">share</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span><span class="p">);</span>            <span class="c1">// share -- &quot;will&quot; retain refcount</span>

    <span class="kt">void</span> <span class="nf">reseat</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span>          <span class="c1">// &quot;might&quot; reseat ptr</span>

    <span class="kt">void</span> <span class="nf">may_share</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// &quot;might&quot; retain refcount</span>
</pre></div>


<h5 id="enforcement_20">Enforcement</h5>
<ul>
<li>(쉬움) 함수가 <code>shared_ptr&lt;T&gt;</code>를 lvalue 참조로 받으면서 새로운 개체를 대입하지 않고 최소 한 경로에서 <code>reset()</code>을 호출하지 않는다면 경고하라. 대신 <code>T*</code> 혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>(쉬움) ((기본사항)) 함수가 <code>shared_ptr&lt;T&gt;</code>를 값 혹은 <code>const</code> 참조로 전달 받으면서 최소 한 경로에서 다른 <code>shared_ptr</code>에 복사하거나 이동하지 않으면 경고하라. 대신 <code>T*</code> 혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>(쉬움) ((기본사항)) <code>shared_ptr&lt;T&gt;</code>을 rvalue 참조로 전달받으면 경고하라. 대신 값으로 전달받도록 제안하라.</li>
</ul>
<h3 id="r36-const-shared_ptrltwidgetgtamp"><a name="Rr-sharedptrparam-const"></a>R.36: 함수가 개체에 대한 참조 카운트를 유지한다는 것을 표현하기 위해 <code>const shared_ptr&lt;widget&gt;&amp;</code>을 매개변수로 사용하라 ???</h3>
<h5 id="reason_23">Reason</h5>
<p>작성한 함수의 ???를 명시적으로 만든다.</p>
<h5 id="example-good_3">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">share</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span><span class="p">);</span>            <span class="c1">// share -- &quot;will&quot; retain refcount</span>

    <span class="kt">void</span> <span class="nf">reseat</span><span class="p">(</span><span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span>          <span class="c1">// &quot;might&quot; reseat ptr</span>

    <span class="kt">void</span> <span class="nf">may_share</span><span class="p">(</span><span class="k">const</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;&amp;</span><span class="p">);</span> <span class="c1">// &quot;might&quot; retain refcount</span>
</pre></div>


<h5 id="enforcement_21">Enforcement</h5>
<ul>
<li>(쉬움) 함수가 <code>shared_ptr&lt;T&gt;</code>를 lvalue 참조로 받으면서 새로운 개체를 대입하지 않고 최소 한 경로에서 <code>reset()</code>을 호출하지 않는다면 경고하라. 대신 <code>T*</code> 혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>(쉬움) ((기본사항)) 함수가 <code>shared_ptr&lt;T&gt;</code>를 값 혹은 <code>const</code> 참조로 전달 받으면서 최소 한 경로에서 다른 <code>shared_ptr</code>에 복사하거나 이동하지 않으면 경고하라. 대신 <code>T*</code> 혹은 <code>T&amp;</code>를 사용하도록 제안하라.</li>
<li>(쉬움) ((기본사항)) <code>shared_ptr&lt;T&gt;</code>을 rvalue 참조로 전달받으면 경고하라. 대신 값으로 전달받도록 제안하라.</li>
</ul>
<h3 id="r37-aliased"><a name="Rr-smartptrget"></a>R.37: 재명명(aliased)된 스마트 포인터에서 획득한 포인터 혹은 참조를 전달하지 마라</h3>
<blockquote>
<p>역주: <a href="https://en.wikipedia.org/wiki/Pointer_aliasing">Pointer Aliasing</a></p>
</blockquote>
<h5 id="reason_24">Reason</h5>
<p>이 규칙을 위반하는 것은 참조 수를 잃어버리고 허상 포인터가 남도록 만드는 가장 중요한 원인이다.<br />
함수는 호출이 깊어질 때 되도록 원시 포인터나 참조를 전달해야 한다. 스마트 포인터로부터 원시 포인터 혹은 참조를 획득하는 호출 트리의 최상단에서는 개체가 소멸하지 않도록 해야 한다.<br />
프로그래머는 소유권을 가진 스마트 포인터가 우연치 않게 호출 트리의 하단에서 바뀌지 않도록 해야한다.</p>
<h5 id="note_11">Note</h5>
<p>이를 위해서, 스마트 포인터의 지역 사본을 만들어야 할수도 있다. 이 스마트 포인터는 함수와 그 호출 트리가 지속되는 동안 개체가 살아있도록 만든다.</p>
<h5 id="example_18">Example</h5>
<p>다음과 같은 경우를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// global (static or heap), or aliased local ...</span>
    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">widget</span><span class="o">&gt;</span> <span class="n">g_p</span> <span class="o">=</span> <span class="p">...;</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">widget</span><span class="o">&amp;</span> <span class="n">w</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">g</span><span class="p">();</span>
        <span class="n">use</span><span class="p">(</span><span class="n">w</span><span class="p">);</span>  <span class="c1">// A</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">g</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">g_p</span> <span class="o">=</span> <span class="p">...;</span> <span class="c1">// oops, if this was the last shared_ptr to that widget, destroys the widget</span>
    <span class="p">}</span>
</pre></div>


<p>다음과 같은 코드가 허용되어선 안된다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">my_code</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// BAD: passing pointer or reference obtained from a nonlocal smart pointer</span>
        <span class="c1">//      that could be inadvertently reset somewhere inside f or it callees</span>
        <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">g_p</span><span class="p">);</span>

        <span class="c1">// BAD: same reason, just passing it as a &quot;this&quot; pointer</span>
         <span class="n">g_p</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>


<p>이는 쉽게 수정할 수 있다 -- "참조 카운트를 유지하도록" 해당 포인터의 사본을 지역적으로 만드는 것이다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">my_code</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="c1">// cheap: 1 increment covers this entire function and all the call trees below us</span>
        <span class="k">auto</span> <span class="n">pin</span> <span class="o">=</span> <span class="n">g_p</span><span class="p">;</span>

        <span class="c1">// GOOD: passing pointer or reference obtained from a local unaliased smart pointer</span>
        <span class="n">f</span><span class="p">(</span><span class="o">*</span><span class="n">pin</span><span class="p">);</span>

        <span class="c1">// GOOD: same reason</span>
        <span class="n">pin</span><span class="o">-&gt;</span><span class="n">func</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_22">Enforcement</h5>
<ul>
<li>(쉬움) 비지역 스마트 포인터 변수(<code>unique_ptr</code> 혹은 <code>shared_ptr</code>)로부터 포인터가 참조를 획득하면 경고하라. 혹은 스마트 포인터가 다른 개체에 연결(aliased)되었을 수 있을때 함수 호출에 사용되면 경고하라. <code>shared_ptr</code>라면 해당 포인터를 통해 참조하거나 그 포인터의 지역 사본을 만들도록 제안하라.</li>
</ul>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../Profile/" title="Profile" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Profile
              </span>
            </div>
          </a>
        
        
          <a href="../SL/" title="Standard Library" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Standard Library
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright (c) Standard C++ Foundation and its contributors
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>