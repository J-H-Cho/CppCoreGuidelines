



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++ 핵심 가이드라인 한글화 프로젝트">
      
      
        <link rel="canonical" href="http://www.cppkorea.org/CppCoreGuidelines/Philosophy/">
      
      
        <meta name="author" content="C++ Korea">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Philosophy - C++ 핵심 가이드라인</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.1b62728e.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7CNanum+Gothic+Coding&display=fallback">
        <style>body,input{font-family:"Nanum Gothic","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Nanum Gothic Coding","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#reason" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-header-nav__button md-logo">
          
            <img src="../images/logo.svg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              C++ 핵심 가이드라인
            </span>
            <span class="md-header-nav__topic">
              
                Philosophy
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Introduction/" class="md-tabs__link">
          Introduction
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../References/" class="md-tabs__link">
          References
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Architecture/" class="md-tabs__link md-tabs__link--active">
          Sections
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../appendix/Modernizing/" class="md-tabs__link">
          Appendix
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-nav__button md-logo">
      
        <img src="../images/logo.svg" width="48" height="48">
      
    </a>
    C++ 핵심 가이드라인
  </label>
  
    <div class="md-nav__source">
      


  

<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../home/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Introduction
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Introduction
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Introduction/" title="In: 소개" class="md-nav__link">
      <a name="S-introduction"></a>In: 소개
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      References
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        References
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../References/" title="RF: 레퍼런스" class="md-nav__link">
      <a name="S-references"></a>RF: 레퍼런스
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Sections
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Sections
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Architecture/" title="Architecture" class="md-nav__link">
      Architecture
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Class/" title="Class" class="md-nav__link">
      Class
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Concurrency/" title="Concurrency" class="md-nav__link">
      Concurrency
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Const/" title="Const" class="md-nav__link">
      Const
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CPL/" title="C-Style" class="md-nav__link">
      C-Style
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Enum/" title="Enum" class="md-nav__link">
      Enum
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Errors/" title="Errors" class="md-nav__link">
      Errors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Expr/" title="Expr" class="md-nav__link">
      Expr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Functions/" title="Functions" class="md-nav__link">
      Functions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../GSL/" title="GSL" class="md-nav__link">
      GSL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interfaces/" title="Interfaces" class="md-nav__link">
      Interfaces
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Naming/" title="Naming" class="md-nav__link">
      Naming
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Not/" title="Not-Rule" class="md-nav__link">
      Not-Rule
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Performance/" title="Performance" class="md-nav__link">
      Performance
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Philosophy" class="md-nav__link md-nav__link--active">
      Philosophy
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Profile/" title="Profile" class="md-nav__link">
      Profile
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Resource/" title="Resource" class="md-nav__link">
      Resource
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../SL/" title="Standard Library" class="md-nav__link">
      Standard Library
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Source/" title="Source" class="md-nav__link">
      Source
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Templates/" title="Templates" class="md-nav__link">
      Templates
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Unclassified/" title="Unclassified" class="md-nav__link">
      Unclassified
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Appendix
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Appendix
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Modernizing/" title="Modernizing" class="md-nav__link">
      Modernizing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Tools/" title="Tools" class="md-nav__link">
      Tools
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="http://github.com/CppKorea/CppCoreGuidelines/edit/master/docs/Philosophy.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="p"><a name="S-philosophy"></a>P: 철학</h1>
<p>이 장의 규칙들은 매우 일반적이다.</p>
<p>철학 규칙 요약:</p>
<ul>
<li><a href="#Rp-direct">P.1: 아이디어를 직접 코드로 표현하라</a></li>
<li><a href="#Rp-Cplusplus">P.2: ISO 표준 C++로 작성하라</a></li>
<li><a href="#Rp-what">P.3: 의도를 표현하라</a></li>
<li><a href="#Rp-typesafe">P.4: 이상적으로 프로그램은 정적으로 타입 안전해야 한다</a></li>
<li><a href="#Rp-compile-time">P.5: 런타임 검사보다는 컴파일 타임 검사를 선호하라</a></li>
<li><a href="#Rp-run-time">P.6: 컴파일 타임에 검사할 수 없다면 런타임에 검사할 수 있어야 한다</a></li>
<li><a href="#Rp-early">P.7: 런타임 오류는 초기에 잡아라</a></li>
<li><a href="#Rp-leak">P.8: 리소스가 새도록 하지 마라</a></li>
<li><a href="#Rp-waste">P.9: 시간이나 공간을 낭비하지 마라</a></li>
<li><a href="#Rp-mutable">P.10: 변경 가능한 데이터보다 변경 불가능한 데이터를 더 자주 사용하라</a></li>
<li><a href="#Rp-library">P.11: 복잡한 생성과정은 캡슐하라</a></li>
<li><a href="#Rp-tools">P.12: 지원 도구를 적절히 활용하라</a></li>
<li><a href="#Rp-lib">P.13: 지원 라이브러리를 적절히 활용하라</a></li>
</ul>
<p>철학적 규칙은 보통 기계적으로 검사할 수 <strong>없다</strong>.
그러나 철학적인 테마를 반영하는 개별적인 규칙들은 검사할 수 하다.
철학적인 기초가 없이 구체적이고/특수하고/검사 가능한 규칙은 근거가 부족하다.</p>
<h3 id="p1"><a name="Rp-direct"></a>P.1: 아이디어를 직접 코드로 표현하라</h3>
<h5 id="reason">Reason</h5>
<p>컴파일러는 주석문(또는 디자인 문서)을 읽지 않는다. 수많은 프로그래머 또한 주석을 (일관되게) 읽지 않는다.
코드로 표현된 내용이라면 그 의미(의도)를 이미 정의했을 것이며 (대체로) 컴파일러나 다른 툴로 검사할 수 있다.</p>
<h5 id="example">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Month</span> <span class="n">month</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// do</span>
        <span class="kt">int</span> <span class="nf">month</span><span class="p">();</span>          <span class="c1">// don&#39;t</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>첫번째 <code>month</code> 함수는 명확히 <code>Month</code>를 반환하도록 선언되어 있으며, <code>Date</code> 개체의 상태를 변경하지 않을 것처럼 보인다.
두번째 버전은 코드를 읽는 개발자들을 고민하게 만들며, 발견하기 어려운 버그를 유발할 가능성이 있다.</p>
<h5 id="example-bad">Example; bad</h5>
<p>아래의 반복문은 <code>std::find</code>를 이용해 표현 가능하다.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="kt">int</span> <span class="n">index</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>                    <span class="c1">// bad, plus should use gsl::index</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">v</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">val</span><span class="p">)</span> <span class="p">{</span>
                <span class="n">index</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example-good">Example; good</h5>
<p>의도를 더 명확하게 드러내기 위해 아래와 같이 코드를 바꿀 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">string</span> <span class="n">val</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">val</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">find</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">val</span><span class="p">);</span>  <span class="c1">// better</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>언어가 제공하는 기능을 직접 사용하기보다 잘 설계된 라이브러리를 사용해 그 의도(어떻게 수행되는지보다 무엇이 수행되는지를) 표현하는 것이 훨씬 낫다.</p>
<p>C++ 프로그래머는 표준 라이브러리의 기본 내용을 반드시 이해하고 올바른 곳에 사용해야 한다.
어떤 프로그래머든 프로젝트에 기반하고 있는 핵심 라이브러리의 기본 내용을 반드시 이해하고 있어야 하며, 올바르게 사용할 줄 알아야 한다.
이 가이드라인을 사용하는 프로그래머는 <a href="../GSL/#S-gsl">가이드라인 지원 라이브러리</a>을 반드시 알아야 하고 적절히 사용할 줄 알아야 한다.</p>
<h5 id="example_1">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">change_speed</span><span class="p">(</span><span class="kt">double</span> <span class="n">s</span><span class="p">);</span>   <span class="c1">// bad: what does s signify?</span>
    <span class="c1">// ...</span>
    <span class="n">change_speed</span><span class="p">(</span><span class="mf">2.3</span><span class="p">);</span>
</pre></div>


<p>더 좋은 접근법은 <code>double</code>의 의미와 단위(새로운 속도 값인지, 혹은 이전 속도에서의 증분을 의미하는지)를 명확히 하는 것이다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">change_speed</span><span class="p">(</span><span class="n">Speed</span> <span class="n">s</span><span class="p">);</span>    <span class="c1">// better: the meaning of s is specified</span>
    <span class="c1">// ...</span>
    <span class="n">change_speed</span><span class="p">(</span><span class="mf">2.3</span><span class="p">);</span>        <span class="c1">// error: no unit</span>
    <span class="n">change_speed</span><span class="p">(</span><span class="mi">23</span><span class="n">m</span> <span class="o">/</span> <span class="mi">10</span><span class="n">s</span><span class="p">);</span>  <span class="c1">// meters per second</span>
</pre></div>


<p>(단위가 없는) 단순한 <code>double</code>을 변화량(속도의 차)으로 받아들일 수도 있겠지만, 아무래도 오류가 발생하기 쉽다.
속도와 변화량 둘 다 필요하다면, <code>Delta</code> 타입을 정의해야 할 것이다.</p>
<h5 id="enforcement">Enforcement</h5>
<p>일반적으로 매우 어렵다.</p>
<ul>
<li>일관성 있게 <code>const</code>를 사용하라 (멤버 함수가 개체를 변경하는지 확인하라. 그리고 포인터나 레퍼런스로 넘어온 인자를 변경하는지 확인하라)</li>
<li>타입 변환의 사용을 지적하라 (타입 변환은 타입 시스템을 무력화시킨다)</li>
<li>표준 라이브러리를 흉내내는 코드를 찾아라 (찾기 어렵다)</li>
</ul>
<h3 id="p2-iso-c"><a name="Rp-Cplusplus"></a>P.2: ISO 표준 C++로 작성하라</h3>
<h5 id="reason_1">Reason</h5>
<p>이 문서는 ISO 표준 C++로 작성하는 가이드라인들을 모아둔 것이다.</p>
<h5 id="note">Note</h5>
<p>시스템 리소스에 접근하는 등의 작업을 수행하기 위해서 확장 기능이 필요할 수 있다.
이런 경우에는 필요한 확장 기능을 지역적으로 제한해서 사용하고, 핵심 가이드라인이 아닌 다른 코딩 가이드라인을 활용해 관리하라. If possible, build interfaces that encapsulate the extensions so they can be turned off or compiled away on systems that do not support those extensions.</p>
<p>Extensions often do not have rigorously defined semantics.  Even extensions that
are common and implemented by multiple compilers may have slightly different
behaviors and edge case behavior as a direct result of <em>not</em> having a rigorous
standard definition.  With sufficient use of any such extension, expected
portability will be impacted.</p>
<h5 id="note_1">Note</h5>
<p>Using valid ISO C++ does not guarantee portability (let alone correctness).
Avoid dependence on undefined behavior (e.g., <a href="../Expr/#Res-order">undefined order of evaluation</a>)
and be aware of constructs with implementation defined meaning (e.g., <code>sizeof(int)</code>).</p>
<h5 id="note_2">Note</h5>
<p>표준 C++ 언어의 기능이나 라이브러리조차 제한적으로 사용할 수 밖에 없는 환경도 있다.
예를 들면, 항공기 제어 소프트웨어 개발 표준에는 동적 메모리 할당을 피할 것을 주문하고 있다.
이런 경우에는 특정 환경에 맞춘 코딩 가이드라인을 확장해서 사용하거나 사용하지 않아야 하는 기능들을 관리하라.</p>
<h5 id="enforcement_1">Enforcement</h5>
<p>확장을 허용하지 않도록 기능 설정이 가능한 최신 C++ 컴파일러(C++17, C++14 혹은 C++11)를 사용하라.</p>
<h3 id="p3"><a name="Rp-what"></a>P.3: 의도를 표현하라</h3>
<h5 id="reason_2">Reason</h5>
<p>(이름이나 주석을 통해) 코드의 의도를 제대로 드러내지 못한다면, 코드가 제대로 수행되는지조차 말할 수 없을 것이다.</p>
<h5 id="example_2">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">while</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
        <span class="c1">// ... do something with v[i] ...</span>
    <span class="p">}</span>
</pre></div>


<p>위 코드만 보았을 때는 <code>v</code>의 각 요소를 순회하겠다는 의도가 드러나지 않는다.
인덱스에 대한 세부적인 구현부가 노출된다 (따라서 잘못 사용될 지도 모른다). 그리고 의도적인지는 알 수 없지만 <code>i</code>를 반복문 밖에서도 여전히 사용할 수 있다. 이 부분의 코드만 읽어서는 그 의도를 알지 못한다.</p>
<p>개선:</p>
<div class="codehilite"><pre><span></span>    <span class="k">for</span> <span class="p">(</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* do something with the value of x */</span> <span class="p">}</span>
</pre></div>


<p>위 코드를 보면 v에 대한 순회 메커니즘을 명시적으로 언급하지 않는다. 그리고 순회하는 동안 v의 각 <code>const</code> 요소의 레퍼런스에 대해 동작이 일어나기 때문에 각 요소를 수정할 수 없다. 만약 수정이 필요한 경우라면 아래와 같이 코드를 작성해야 한다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">for</span> <span class="p">(</span><span class="k">auto</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">v</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* modify x */</span> <span class="p">}</span>
</pre></div>


<p>For more details about for-statements, see <a href="../Expr/#Res-for-range">ES.71</a>.
Sometimes better still, use a named algorithm. This example uses the <code>for_each</code> from the Ranges TS because it directly expresses the intent:</p>
<div class="codehilite"><pre><span></span>    <span class="n">for_each</span><span class="p">(</span><span class="n">v</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* do something with the value of x */</span> <span class="p">});</span>
    <span class="n">for_each</span><span class="p">(</span><span class="n">par</span><span class="p">,</span> <span class="n">v</span><span class="p">,</span> <span class="p">[](</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* do something with the value of x */</span> <span class="p">});</span>
</pre></div>


<p>마지막 예는 <code>v</code>의 각 요소가 처리되는 순서에 관심이 없다는 점을 명확히 하고 있다.</p>
<p>프로그래머라면 다음에 익숙해져야 한다.</p>
<ul>
<li><a href="../GSL/#S-gsl">가이드라인 지원 라이브러리</a></li>
<li><a href="../SL/#S-stdlib">ISO C++ 표준 라이브러리</a></li>
<li>현재 프로젝트에서 사용되고 있는 모든 기본 라이브러리들</li>
</ul>
<h5 id="note_3">Note</h5>
<p>공식 대안: 어떻게 작업이 수행되는지를 말하지 말고 무엇이 수행될지를 말하라.</p>
<h5 id="note_4">Note</h5>
<p>언어의 기본 요소는 다른 무엇보다도 그 의도를 더 잘 표현한다.</p>
<h5 id="example_3">Example</h5>
<p>2개의 <code>int</code> 값으로 2차원 좌표를 표현하고 싶다면, 다음과 같이 써라:</p>
<div class="codehilite"><pre><span></span>    <span class="n">draw_line</span><span class="p">(</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>  <span class="c1">// obscure</span>
    <span class="n">draw_line</span><span class="p">(</span><span class="n">Point</span><span class="p">,</span> <span class="n">Point</span><span class="p">);</span>        <span class="c1">// clearer</span>
</pre></div>


<h5 id="enforcement_2">Enforcement</h5>
<p>좀 더 나은 대안이 있는 범용적인 패턴을 찾아보라.</p>
<ul>
<li>단순한 <code>for</code>문 대 범위 기반 <code>for</code>문</li>
<li><code>f(T*, int)</code> 인터페이스 대 <code>f(span&lt;T&gt;)</code> 인터페이스</li>
<li>아주 큰 스코프에서 순회하는 변수</li>
<li>그대로 노출된 <code>new</code>와 <code>delete</code></li>
<li>인자로 내장 타입을 여러개 갖는 함수</li>
</ul>
<p>There is a huge scope for cleverness and semi-automated program transformation.</p>
<h3 id="p4"><a name="Rp-typesafe"></a>P.4: 이상적으로 프로그램은 정적으로 타입 안전해야 한다</h3>
<h5 id="reason_3">Reason</h5>
<p>이상적으로 프로그램은 완전히 정적으로 타입 안전해야 한다.
하지만 불행하게도 불가능하다. 왜냐하면 다음처럼 문제가 되는 영역들이 존재하기 때문이다.</p>
<ul>
<li>공용체</li>
<li>타입 변환</li>
<li>배열 붕괴</li>
<li>범위 오류</li>
<li>축소 타입 변환</li>
</ul>
<h5 id="note_5">Note</h5>
<p>이러한 영역들은 심각한 문제의 원인이 된다. (예를 들어, 크래시와 보안 위반)
따라서 다른 기법을 제공하고자 한다.</p>
<h5 id="enforcement_3">Enforcement</h5>
<p>각 프로그램에 대해 필요하고 실현 가능하도록 각 문제 범주를 개별적으로 금지, 억제 또는 탐지할 수 있다.
항상 대안을 제시하라.</p>
<p>예시:</p>
<ul>
<li>공용체 -- (C++17에 있는) <code>variant</code>를 사용하라.</li>
<li>타입 변환 -- 사용을 최소화하라. 템플릿이 도움이 될 수 있다.</li>
<li>배열 붕괴 -- (GSL에 있는) <code>span</code>을 사용하라.</li>
<li>범위 오류 -- <code>span</code>을 사용하라.</li>
<li>축소 타입 변환 -- 사용을 최소화하라. 필요하면 <code>narrow</code>나 (GSL에 있는) <code>narrow_cast</code>를 사용하라.</li>
</ul>
<h3 id="p5"><a name="Rp-compile-time"></a>P.5:런타임 검사보다는 컴파일 타임 검사를 선호하라</h3>
<h5 id="reason_4">Reason</h5>
<p>코드 명확성, 성능 향상.
컴파일 타임에 발견되는 오류에 대해서는 처리하는 부분을 따로 작성할 필요가 없다.</p>
<h5 id="example_4">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// Int is an alias used for integers</span>
    <span class="kt">int</span> <span class="n">bits</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>         <span class="c1">// don&#39;t: avoidable code</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">Int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;&lt;=</span> <span class="mi">1</span><span class="p">)</span>
        <span class="o">++</span><span class="n">bits</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">bits</span> <span class="o">&lt;</span> <span class="mi">32</span><span class="p">)</span>
        <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Int too small</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
</pre></div>


<p>This example fails to achieve what it is trying to achieve (because overflow is undefined) and should be replaced with a simple <code>static_assert</code>:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// Int is an alias used for integers</span>
    <span class="k">static_assert</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="n">Int</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">4</span><span class="p">);</span>    <span class="c1">// do: compile-time check</span>
</pre></div>


<p>Or better still just use the type system and replace <code>Int</code> with <code>int32_t</code>.</p>
<h5 id="example_5">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>   <span class="c1">// read max n integers into *p</span>

    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">read</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="mi">1000</span><span class="p">);</span>    <span class="c1">// bad, off the end</span>
</pre></div>


<p>better</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">r</span><span class="p">);</span> <span class="c1">// read into the range of integers r</span>

    <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
    <span class="n">read</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>        <span class="c1">// better: let the compiler figure out the number of elements</span>
</pre></div>


<p><strong>Alternative formulation</strong>: 컴파일 타임에 할 수 있는 것을 런타임으로 연기하지 마라.</p>
<h5 id="enforcement_4">Enforcement</h5>
<ul>
<li>Look for pointer arguments.</li>
<li>Look for run-time checks for range violations.</li>
</ul>
<h3 id="p6"><a name="Rp-run-time"></a>P.6: 컴파일 타임에 검사할 수 없다면 런타임에 검사할 수 있어야 한다</h3>
<h5 id="reason_5">Reason</h5>
<p>프로그램 안에 찾기 어려운 오류를 남겨둔다면 크래시나 나쁜 결과를 야기한다.</p>
<h5 id="note_6">Note</h5>
<p>이상적으로 우리는 컴파일 타임, 런타임에 (프로그래머의 논리에서는 오류가 아닌) 모든 오류를 찾을 수 있다.
컴파일 타임에 모든 오류를 찾아내는 건 불가능하고 런타임에 남아 있는 모든 오류를 찾는 것도 불가능하다.
그러나 충분한 리소스를 준다면 원론적으로 검사 가능한 프로그램을 작성하려고 노력해야 한다. (분석 프로그램, 런타임 검사, 컴퓨터 리소스, 시간)</p>
<h5 id="example-bad_1">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// separately compiled, possibly dynamically loaded</span>
    <span class="k">extern</span> <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">g</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// bad: the number of elements is not passed to f()</span>
        <span class="n">f</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">]);</span>
    <span class="p">}</span>
</pre></div>


<p>여기서 결정적인 정보(요소의 갯수)가 아주 철저하게 숨겨져 있어서, <code>f()</code>가 ABI의 일부일 때 정적 분석은 아마도 불가능해 보이고 동적 검사는 매우 어려울 수 있다. 따라서 해당 포인터를 "측정"할 수 없다.
도움이 될만한 정보를 남은 공간에 넣을 수 있지만, 이는 시스템이나 컴파일러에게 전반적인 변경을 요구한다.
예제에 있는 코드는 오류 발견을 아주 어렵게 만드는 디자인이다.</p>
<h5 id="example-bad_2">Example, bad</h5>
<p>We can of course pass the number of elements along with the pointer:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// separately compiled, possibly dynamically loaded</span>
    <span class="k">extern</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">g2</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">f2</span><span class="p">(</span><span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">],</span> <span class="n">m</span><span class="p">);</span>  <span class="c1">// bad: a wrong number of elements can be passed to f()</span>
    <span class="p">}</span>
</pre></div>


<p>인자로 요소의 갯수를 전달하는 것은 포인터를 전달하면서 관례에 따라 요소의 갯수를 구하는 것보다 낫다.
그러나, 단순히 철자 하나만 틀려도 심각한 오류를 야기한다. <code>f2()</code>에서 두 인자간의 연결은 구체적이지 않고 관례에 따른 것이다.</p>
<p>게다가 <code>f2()</code>가 인자를 <code>delete</code>할 것인지 알 수 없다. (호출자가 두번째 실수를 한 것인가?)</p>
<h5 id="example-bad_3">Example, bad</h5>
<p>표준 라이브러리에 있는 리소스 관리 포인터는 개체를 가리키고 있을 때 크기를 넘길 수 없다:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// separately compiled, possibly dynamically loaded</span>
    <span class="c1">// NB: this assumes the calling code is ABI-compatible, using a</span>
    <span class="c1">// compatible C++ compiler and the same stdlib implementation</span>
    <span class="k">extern</span> <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>

    <span class="kt">void</span> <span class="nf">g3</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">f3</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">),</span> <span class="n">m</span><span class="p">);</span>    <span class="c1">// bad: pass ownership and size separately</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example_6">Example</h5>
<p>포인터와 요소의 갯수를 하나의 개체로 합쳐서 전달해야 한다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">extern</span> <span class="kt">void</span> <span class="nf">f4</span><span class="p">(</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;&amp;</span><span class="p">);</span>   <span class="c1">// separately compiled, possibly dynamically loaded</span>
    <span class="k">extern</span> <span class="kt">void</span> <span class="nf">f4</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">);</span>      <span class="c1">// separately compiled, possibly dynamically loaded</span>
                                    <span class="c1">// NB: this assumes the calling code is ABI-compatible, using a</span>
                                    <span class="c1">// compatible C++ compiler and the same stdlib implementation</span>

    <span class="kt">void</span> <span class="nf">g3</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="n">f4</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>                     <span class="c1">// pass a reference, retain ownership</span>
        <span class="n">f4</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">{</span><span class="n">v</span><span class="p">});</span>          <span class="c1">// pass a view, retain ownership</span>
    <span class="p">}</span>
</pre></div>


<p>이 디자인은 개체의 필수 부분으로 요소의 갯수를 전달하므로 오류가 발생하지 않고 항상 저렴하지는 않지만 동적(런타임) 검사를 할 수 있다.</p>
<h5 id="example_7">Example</h5>
<p>올바른 사용을 위해 어떻게 소유권과 모든 정보를 전달할 것인가?</p>
<div class="codehilite"><pre><span></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">f5</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>    <span class="c1">// OK: move</span>
    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="c1">// ... initialize v ...</span>
        <span class="k">return</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span> <span class="n">f6</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>    <span class="c1">// bad: loses n</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">[]</span><span class="o">&gt;</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>
        <span class="c1">// ... initialize *p ...</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">owner</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">f7</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>    <span class="c1">// bad: loses n and we might forget to delete</span>
    <span class="p">{</span>
        <span class="n">owner</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">*&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="c1">// ... initialize *p ...</span>
        <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example_8">Example</h5>
<ul>
<li>???</li>
<li>필요한 것을 실제로 알고 있을 때, 다형 기본 클래스를 전달하는 인터페이스가 어떻게 검사를 피할 수 있는지 보여준다.<br />
  또는 "자유형" 옵션으로 문자열이 있다.</li>
</ul>
<h5 id="enforcement_5">Enforcement</h5>
<ul>
<li>(포인터, 갯수)-스타일 인터페이스라면 표시한다. (호환성을 이유로 고칠 수 없는 많은 예제를 표시할 것이다.)</li>
<li>???</li>
</ul>
<h3 id="p7"><a name="Rp-early"></a>P.7: 런타임 오류는 초기에 잡아라</h3>
<h5 id="reason_6">Reason</h5>
<p>"미스터리"한 크래시를 피한다.
(아마 몰랐을 수도 있는) 잘못된 결과를 야기하는 오류를 피한다.</p>
<h5 id="example_9">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">increment1</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span>    <span class="c1">// bad: error-prone</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="o">++</span><span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">use1</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="c1">// ...</span>
        <span class="n">increment1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">);</span>   <span class="c1">// maybe typo, maybe m &lt;= n is supposed</span>
                            <span class="c1">// but assume that m == 20</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>여기서 우리는 <code>use1</code>에 데이터가 손실되거나 크래시를 야기할 수 있는 작은 오류를 범했다.
(포인터, 크기)-스타일 인터페이스는 범위 오류에 대해 <code>increment1()</code>에서 방어할 수 있는 현실적인 방안을 없애버린다.
배열 첨자가 범위를 벗어나는지 검사한다고 가정하면, <code>p[10]</code>까지 오류가 발견되지 않을 것이다.
좀 더 빨리 검사하도록 코드를 개선해 보자:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">increment2</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="nl">x</span> <span class="p">:</span> <span class="n">p</span><span class="p">)</span> <span class="o">++</span><span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">use2</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="c1">// ...</span>
        <span class="n">increment2</span><span class="p">({</span><span class="n">a</span><span class="p">,</span> <span class="n">m</span><span class="p">});</span>    <span class="c1">// maybe typo, maybe m &lt;= n is supposed</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>이제 <code>m&lt;=n</code>은 호출 시점에서 (일찍) 확인할 수 있다.
우리가 가진 모든 것이 오타이므로 <code>n</code>을 범위로 사용한다면, 코드를 더 단순하게 만들 수 있다. (오류의 가능성 제거)</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">use3</span><span class="p">(</span><span class="kt">int</span> <span class="n">m</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">const</span> <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="n">n</span><span class="p">]</span> <span class="o">=</span> <span class="p">{};</span>
        <span class="c1">// ...</span>
        <span class="n">increment2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>   <span class="c1">// the number of elements of a need not be repeated</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example-bad_4">Example, bad</h5>
<p>동일한 값을 반복적으로 검사하지 마라. 구조화된 데이터를 문자열로 넘기지 마라:</p>
<div class="codehilite"><pre><span></span>    <span class="n">Date</span> <span class="nf">read_date</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">);</span>    <span class="c1">// read date from istream</span>

    <span class="n">Date</span> <span class="nf">extract_date</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">s</span><span class="p">);</span>    <span class="c1">// extract date from string</span>

    <span class="kt">void</span> <span class="nf">user1</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">date</span><span class="p">)</span>    <span class="c1">// manipulate date</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">d</span> <span class="o">=</span> <span class="n">extract_date</span><span class="p">(</span><span class="n">date</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">user2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Date</span> <span class="n">d</span> <span class="o">=</span> <span class="n">read_date</span><span class="p">(</span><span class="n">cin</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="n">user1</span><span class="p">(</span><span class="n">d</span><span class="p">.</span><span class="n">to_string</span><span class="p">());</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>(<code>Date</code> 생성자에 의해) 날짜가 두 번 계산되고 (비구조화된 데이터인) 문자열로 전달된다.</p>
<h5 id="example_10">Example</h5>
<p>지나친 검사는 비용이 많이 든다.
값이 필요한지도 모르기 때문에 일찍 검사하는 것이 안 좋은 경우도 있고 전체가 아닌 값의 일부만 검사하는 것이 쉬운 경우도 있다.
Similarly, don't add validity checks that change the asymptotic behavior of your interface (e.g., don't add a <code>O(n)</code> check to an interface with an average complexity of <code>O(1)</code>).</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Jet</span> <span class="p">{</span>    <span class="c1">// Physics says: e * e &lt; x * x + y * y + z * z</span>
        <span class="kt">float</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">y</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">z</span><span class="p">;</span>
        <span class="kt">float</span> <span class="n">e</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Jet</span><span class="p">(</span><span class="kt">float</span> <span class="n">x</span><span class="p">,</span> <span class="kt">float</span> <span class="n">y</span><span class="p">,</span> <span class="kt">float</span> <span class="n">z</span><span class="p">,</span> <span class="kt">float</span> <span class="n">e</span><span class="p">)</span>
            <span class="o">:</span><span class="n">x</span><span class="p">(</span><span class="n">x</span><span class="p">),</span> <span class="n">y</span><span class="p">(</span><span class="n">y</span><span class="p">),</span> <span class="n">z</span><span class="p">(</span><span class="n">z</span><span class="p">),</span> <span class="n">e</span><span class="p">(</span><span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// Should I check here that the values are physically meaningful?</span>
        <span class="p">}</span>

        <span class="kt">float</span> <span class="n">m</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="c1">// Should I handle the degenerate case here?</span>
            <span class="k">return</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">x</span> <span class="o">*</span> <span class="n">x</span> <span class="o">+</span> <span class="n">y</span> <span class="o">*</span> <span class="n">y</span> <span class="o">+</span> <span class="n">z</span> <span class="o">*</span> <span class="n">z</span> <span class="o">-</span> <span class="n">e</span> <span class="o">*</span> <span class="n">e</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="o">???</span>
    <span class="p">};</span>
</pre></div>


<p>제트기에 대한 물리적 법칙(<code>e * e &lt; x * x + y * y + z * z</code>)은 측정 오류의 가능성 때문에 값이 바뀔 수 있다.</p>
<p>???</p>
<h5 id="enforcement_6">Enforcement</h5>
<ul>
<li>포인터와 배열을 찾아라: 범위를 빨리 검사하고 반복되지 않게 하라.</li>
<li>타입 변환을 찾아라: 축소 변환을 표시하거나 제거하라.</li>
<li>입력된 값 중 검사되지 않은 값을 찾아라.</li>
<li>문자열로 변환되고 있는 구조화된 데이터(불변 조건을 갖는 클래스의 개체)를 찾아라.</li>
<li>???</li>
</ul>
<h3 id="p8"><a name="Rp-leak"></a>P.8: 리소스가 새도록 하지 마라</h3>
<h5 id="reason_7">Reason</h5>
<p>Even a slow growth in resources will, over time, exhaust the availability of those resources.
This is particularly important for long-running programs, but is an essential piece of responsible programming behavior.</p>
<h5 id="example-bad_5">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">FILE</span><span class="o">*</span> <span class="n">input</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">something</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>   <span class="c1">// bad: if something == true, a file handle is leaked</span>
        <span class="c1">// ...</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">input</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<p><a href="../Resource/#Rr-raii">RAII</a>를 사용한 개선:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">ifstream</span> <span class="n">input</span> <span class="p">{</span><span class="n">name</span><span class="p">};</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">something</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>   <span class="c1">// OK: no leak</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p><strong>See also</strong>: <a href="../Resource/#S-resource">리소스 관리</a></p>
<h5 id="note_7">Note</h5>
<p>A leak is colloquially "anything that isn't cleaned up."
The more important classification is "anything that can no longer be cleaned up."
For example, allocating an object on the heap and then losing the last pointer that points to that allocation.
This rule should not be taken as requiring that allocations within long-lived objects must be returned during program shutdown.
For example, relying on system guaranteed cleanup such as file closing and memory deallocation upon process shutdown can simplify code.
However, relying on abstractions that implicitly clean up can be as simple, and often safer.</p>
<h5 id="note_8">Note</h5>
<p>Enforcing <a href="../Profile/#SS-lifetime">the lifetime safety profile</a> eliminates leaks.
When combined with resource safety provided by <a href="../Resource/#Rr-raii">RAII</a>, it eliminates the need for "garbage collection" (by generating no garbage).
Combine this with enforcement of <a href="../Profile/#SS-force">the type and bounds profiles</a> and you get complete type- and resource-safety, guaranteed by tools.</p>
<h5 id="enforcement_7">Enforcement</h5>
<ul>
<li>포인터를 살펴봐라: 소유자와 비소유자로 구분해라.
  가능하다면 소유자를 (위의 예제처럼) 표준 라이브러리 리소스 핸들로 바꿔라.
  또는 <a href="#S-gsl">GSL</a>에서 <code>owner</code>를 사용하는 것처럼 소유자를 표시하라.</li>
<li>처리되지 않은 <code>new</code>, <code>delete</code>를 찾아라.</li>
<li>처리되지 않은 포인터를 반환하는 잘 알려진 리소스 할당 함수를 찾아라. (예를 들어, <code>fopen</code>, <code>malloc</code>, <code>strdup</code>)</li>
</ul>
<h3 id="p9"><a name="Rp-waste"></a>P.9: 시간이나 공간을 낭비하지 마라</h3>
<h5 id="reason_8">Reason</h5>
<p>이것이 C++이다.</p>
<h5 id="note_9">Note</h5>
<p>어떤 목표(예를 들어, 개발 속도, 리소스 안전성, 또는 테스트 단순화)를 달성하기 위해 소모하는 시간과 공간은 낭비가 아니다. </p>
<blockquote>
<p>"효율성을 위해 노력할 때 얻을 수 있는 또다른 이점은 그러한 행위가 문제를 더 깊이 이해할 수 있도록 강제한다는 겁니다." - Alex Stepanov</p>
</blockquote>
<h5 id="example-bad_6">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">ch</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">ch2</span><span class="p">;</span>

        <span class="n">X</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
        <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="p">};</span>

    <span class="n">X</span> <span class="nf">waste</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">p</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">p</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Nullptr_error</span><span class="p">{};</span>
        <span class="kt">int</span> <span class="n">n</span> <span class="o">=</span> <span class="n">strlen</span><span class="p">(</span><span class="n">p</span><span class="p">);</span>
        <span class="k">auto</span> <span class="n">buf</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">n</span><span class="p">];</span>
        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">buf</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Allocation_error</span><span class="p">{};</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
        <span class="c1">// ... manipulate buffer ...</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">x</span><span class="p">.</span><span class="n">ch</span> <span class="o">=</span> <span class="sc">&#39;a&#39;</span><span class="p">;</span>
        <span class="n">x</span><span class="p">.</span><span class="n">s</span> <span class="o">=</span> <span class="n">string</span><span class="p">(</span><span class="n">n</span><span class="p">);</span>    <span class="c1">// give x.s space for *p</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">gsl</span><span class="o">::</span><span class="n">index</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">x</span><span class="p">.</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">buf</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>  <span class="c1">// copy buf into x.s</span>
        <span class="k">delete</span><span class="p">[]</span> <span class="n">buf</span><span class="p">;</span>
        <span class="k">return</span> <span class="n">x</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">driver</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="n">x</span> <span class="o">=</span> <span class="n">waste</span><span class="p">(</span><span class="s">&quot;Typical argument&quot;</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>그렇다. 풍자를 위한 예제이기는 하지만, 실제 코드에서 이보다 심각한 실수도 본 적이 있다.
<code>X</code>의 레이아웃에 (더 많을지도 모르지만) 적어도 6바이트의 낭비가 있다는 점을 주목하라.
복사 연산을 그럴싸하게 정의해 두다 보니 이동 연산이 비활성화 됨으로써 반환 연산이 느려졌다(여기에선 반환값 최적화(Return Value Optimization, RVO)가 보장되지 않음에 주목하라).
<code>buf</code>에서 <code>new</code>, <code>delete</code>의 사용이 중복된다. 진짜 지역 문자열을 원했다면, <code>string</code> 지역 변수를 사용했을 것이다.
더 많은 성능 버그와 상황을 더 복잡하게 만드는 불필요한 문제가 있다.</p>
<h5 id="example-bad_7">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">lower</span><span class="p">(</span><span class="n">zstring</span> <span class="n">s</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">strlen</span><span class="p">(</span><span class="n">s</span><span class="p">);</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">=</span> <span class="n">tolower</span><span class="p">(</span><span class="n">s</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="p">}</span>
</pre></div>


<p>그렇다, 이것은 실제 코드로부터 가져온 예제이다.
우리는 이 예제를 독자가 직접 무엇이 낭비되는지 찾게 하기 위해 남겨둔다.</p>
<h5 id="note_10">Note</h5>
<p>낭비에 대한 각 예제는 별로 중요하지 않다. 그리고 중요했다면 이미 전문가들이 쉽게 제거했을 것이다.
그러나 코드 전체에 걸쳐 낭비가 퍼져버리면 중요해 질 수 있고, 낭비를 제거하기 위해서 전문가들을 항상 원하는데로 데려올 수는 없다.
이 규칙(그리고 보다 구체적인 규칙)의 목적은 C++ 사용과 관련된 대부분의 낭비를 발생하기 전에 없애기 위해서다.
그 후에 알고리즘이나 요구 사항과 관련된 낭비를 살펴볼 수 있다. 하지만 그건 이 가이드라인의 범위를 벗어난다.</p>
<h5 id="enforcement_8">Enforcement</h5>
<p>더 많은 특정 규칙들은 쓸데없는 낭비의 단순화와 제거를 전반적인 목표로 하고 있다.
* 사용자가 정의한 기본 정의가 아닌 접미 연산자 ++ 또는 -- 함수의 사용하지 않은 반환값에 표시를 한다. 대신 접두 연산자를 사용하는 것이 좋다. (주의: "사용자가 정의한 기본 정의가 아닌"은 잡음을 줄이려는 의도가 있다. 실사용에서 여전히 너무 잡음이 많을때, 이 시행을 검토하라.)</p>
<h3 id="p10"><a name="Rp-mutable"></a>P.10: 변경 가능한 데이터보다 불변의 데이터를 선호하라</h3>
<h5 id="reason_9">Reason</h5>
<p>변수보다는 상수에 대한 것이 추론을 하기가 더 쉽다.
불변한 것은 예상치 못하게 변하지 않는다.
때때로 불변성은 더 나은 최적화가 가능하게 한다.
당신은 상수를 경쟁상태(Race condition)로 만들 수 없다.</p>
<p><a href="../Const/">Con: 상수와 불변성</a>을 참조하라.</p>
<h3 id="p11"><a name="Rp-library"></a>P.11: 지저분한 구조가 코드를 통해 퍼지기 보단, 캠슐화를 하라.</h3>
<h5 id="reason_10">Reason</h5>
<p>지저분한 코드는 버그를 숨기고 쓰기가 더 어렵다.
좋은 인터페이스는 사용하기 더 쉽고 더 안전하다.
지저분한, 저수준의 코드는 그런 코드를 더 많이 낳는다.</p>
<h5 id="example_11">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">int</span> <span class="n">sz</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
    <span class="kt">int</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">sz</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="p">(;;)</span> <span class="p">{</span>
        <span class="c1">// ... read an int into x, exit loop if end of file is reached ...</span>
        <span class="c1">// ... check that x is valid ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">count</span> <span class="o">==</span> <span class="n">sz</span><span class="p">)</span>
            <span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span> <span class="n">realloc</span><span class="p">(</span><span class="n">p</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">sz</span> <span class="o">*</span> <span class="mi">2</span><span class="p">);</span>
        <span class="n">p</span><span class="p">[</span><span class="n">count</span><span class="o">++</span><span class="p">]</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>이 것은 저수준이고, 장황하며, 에러가 발생하기 쉽다.
예를 들어, 우리는 메모리 소모를 테스트하는 것을 잊었다.
대신, 우리는 <code>vector</code>를 사용할 수 있었다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">reserve</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>
    <span class="c1">// ...</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">x</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="c1">// ... check that x is valid ...</span>
        <span class="n">v</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_11">Note</h5>
<p>표준 라이브러리와 GSL은 이런 철학의 예들 이다.
예를 들어, <code>vector</code>, <code>span</code>, <code>lock_guard</code>, <code>future</code>와 같이 핵심적인 추상화 구현에 필요한, 
배열들과 유니온들, 캐스팅, 까다로운 생명주기 문제, <code>gsl::owner</code> 등으로 지저분하게 하는 대신, 
우리는 우리보다 전문적이고 더 많은 시간을 투자한 사람들이 설계하고 구현한 라이브러리들을 사용한다.
마찬가지로, 우리는 사용자들(흔히 우리 자신)을 반복적으로 낮은 수준의 코드를 얻기 쉬운 환경에 버려두지 말고,
더 전문화된 라이브러리들을 설계하고 구현해야하고 할 수 있다.
이것은 본 지침의 기초가 되는 <a href="../Introduction/#R0">subset of superset principle</a>의 변형이다.</p>
<h5 id="enforcement_9">Enforcement</h5>
<ul>
<li>복잡한 포인터 조작이나 추상화 구현 밖에서의 캐스팅 같은 "지저분한 코드"를 찾아봐라.</li>
</ul>
<h3 id="p12"><a name="Rp-tools"></a>P.12: 필요에 맞게 지원 도구를 사용하라</h3>
<h5 id="reason_11">Reason</h5>
<p>"기계에 의해" 더 잘 될 수 있는 많은 것들이 있다.
컴퓨터는 반복적인 작업에 의해 지치거나 지루해 하지 않는다.
우리는 일반적으로 반복적이고 지루한 일을 하는 것보다 더 나은 일을 한다.</p>
<h5 id="example_12">Example</h5>
<p>정적 분석기를 실행하여 코드가 원하는 지침(Guideline)을 따르는 지 확인하라.</p>
<h5 id="note_12">Note</h5>
<p>다음을 참고하라.</p>
<ul>
<li><a href="???">정적 분석 도구들</a></li>
<li><a href="../Concurrency/#Rconc-tools">동시성 도구들</a></li>
<li><a href="???">테스팅 도구들</a></li>
</ul>
<p>소스코드 저장소들, 빌드 도구들등과 같은 많은 다른 종류의 도구들이 있다.
그러나 그것들에 대해 설명하는 것은 이 가이드라인의 범위를 벗어난다.</p>
<h5 id="note_13">Note</h5>
<p>지나치게 정교하거나 지나치게 특수화 된 툴 체인에 의존하지 않도록 주의하라.
그것들은 당신의 이식가능한 코드를 이식이 불가능하도록 만들 수 있다.</p>
<h3 id="p13"><a name="Rp-lib"></a>P.13: 필요에 맞게 라이브러리들을 사용하라</h3>
<h5 id="reason_12">Reason</h5>
<p>잘 설계되고(well-designed), 잘 문서화된(well-documented) 그리고 잘 지원되는(well-supported) 라이브러리들을 사용하는 것은 시간과 노력을 절약한다.
만약에 당신의 대부분의 시간을 구현에 써야만 한다면, 이것의 품질과 문서는 당신이 만드는 것보다 더 좋을 것이다.
라이브러리의 비용(시간, 노력, 돈, 등등)은 많은 사용자들과 공유될 수 있다.
널리 사용되는 라이브러리는 개개의 어플리케이션에 비해, 최신으로 유지되고 새로운 시스템에 포팅이 더 잘되어 있을 것이다.
널리 사용되는 라이브러리는 다른/미래의 프로젝트들의 시간을 절약할 수 있다.
그러므로, 만약에 당신의 응용 도메인(Domain)에 적합한 라이브러리가 있으면 그것을 사용하라.</p>
<h5 id="example_13">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">begin</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">end</span><span class="p">(</span><span class="n">v</span><span class="p">),</span> <span class="n">std</span><span class="o">::</span><span class="n">greater</span><span class="o">&lt;&gt;</span><span class="p">());</span>
</pre></div>


<p>당신이 정렬 알고리즘들에 대한 전문가이거나 시간이 많이 있지 않은 이상,
이 코드는 당신이 특정한 응용을 위해 작성한 그 어떤 것보다 더 정확하고 빠르게 동작할 것이다.
당신이 직접 작성한 코드를 사용하려면, 표준 라이브러리(또는 당신의 어플리케이션이 사용하는 그 어떤 기본 라이브러리들)를 사용하지 않을 이유가 필요하다.</p>
<h5 id="note_14">Note</h5>
<p>기본적으로 사용되는 것</p>
<ul>
<li><a href="../SL/#S-stdlib">ISO C++ 표준 라이브러리</a></li>
<li><a href="../GSL/#S-gsl">라이브러리 지원 지침들</a></li>
</ul>
<h5 id="note_15">Note</h5>
<p>만약에 잘 설계되고, 잘 문서화되고, 잘 지원되는 라이브러리가 중요한 도메인에 없다면,
아마도 당신은 그것을 설계하고 구현한 뒤, 사용해야 할 것이다.</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../Performance/" title="Performance" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Performance
              </span>
            </div>
          </a>
        
        
          <a href="../Profile/" title="Profile" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Profile
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright (c) Standard C++ Foundation and its contributors
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>