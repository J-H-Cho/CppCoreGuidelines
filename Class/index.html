



<!doctype html>
<html lang="en" class="no-js">
  <head>
    
      <meta charset="utf-8">
      <meta name="viewport" content="width=device-width,initial-scale=1">
      <meta http-equiv="x-ua-compatible" content="ie=edge">
      
        <meta name="description" content="C++ 핵심 가이드라인 한글화 프로젝트">
      
      
        <link rel="canonical" href="http://www.cppkorea.org/CppCoreGuidelines/Class/">
      
      
        <meta name="author" content="C++ Korea">
      
      
        <meta name="lang:clipboard.copy" content="Copy to clipboard">
      
        <meta name="lang:clipboard.copied" content="Copied to clipboard">
      
        <meta name="lang:search.language" content="en">
      
        <meta name="lang:search.pipeline.stopwords" content="True">
      
        <meta name="lang:search.pipeline.trimmer" content="True">
      
        <meta name="lang:search.result.none" content="No matching documents">
      
        <meta name="lang:search.result.one" content="1 matching document">
      
        <meta name="lang:search.result.other" content="# matching documents">
      
        <meta name="lang:search.tokenizer" content="[\s\-]+">
      
      <link rel="shortcut icon" href="../assets/images/favicon.png">
      <meta name="generator" content="mkdocs-1.0.4, mkdocs-material-4.6.0">
    
    
      
        <title>Class - C++ 핵심 가이드라인</title>
      
    
    
      <link rel="stylesheet" href="../assets/stylesheets/application.1b62728e.css">
      
        <link rel="stylesheet" href="../assets/stylesheets/application-palette.a8b3c06d.css">
      
      
        
        
        <meta name="theme-color" content="#3f51b5">
      
    
    
      <script src="../assets/javascripts/modernizr.268332fc.js"></script>
    
    
      
        <link href="https://fonts.gstatic.com" rel="preconnect" crossorigin>
        <link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nanum+Gothic:300,400,400i,700%7CNanum+Gothic+Coding&display=fallback">
        <style>body,input{font-family:"Nanum Gothic","Helvetica Neue",Helvetica,Arial,sans-serif}code,kbd,pre{font-family:"Nanum Gothic Coding","Courier New",Courier,monospace}</style>
      
    
    <link rel="stylesheet" href="../assets/fonts/material-icons.css">
    
    
    
      
    
    
  </head>
  
    
    
    <body dir="ltr" data-md-color-primary="indigo" data-md-color-accent="blue">
  
    <svg class="md-svg">
      <defs>
        
        
          <svg xmlns="http://www.w3.org/2000/svg" width="416" height="448" viewBox="0 0 416 448" id="__github"><path fill="currentColor" d="M160 304q0 10-3.125 20.5t-10.75 19T128 352t-18.125-8.5-10.75-19T96 304t3.125-20.5 10.75-19T128 256t18.125 8.5 10.75 19T160 304zm160 0q0 10-3.125 20.5t-10.75 19T288 352t-18.125-8.5-10.75-19T256 304t3.125-20.5 10.75-19T288 256t18.125 8.5 10.75 19T320 304zm40 0q0-30-17.25-51T296 232q-10.25 0-48.75 5.25Q229.5 240 208 240t-39.25-2.75Q130.75 232 120 232q-29.5 0-46.75 21T56 304q0 22 8 38.375t20.25 25.75 30.5 15 35 7.375 37.25 1.75h42q20.5 0 37.25-1.75t35-7.375 30.5-15 20.25-25.75T360 304zm56-44q0 51.75-15.25 82.75-9.5 19.25-26.375 33.25t-35.25 21.5-42.5 11.875-42.875 5.5T212 416q-19.5 0-35.5-.75t-36.875-3.125-38.125-7.5-34.25-12.875T37 371.5t-21.5-28.75Q0 312 0 260q0-59.25 34-99-6.75-20.5-6.75-42.5 0-29 12.75-54.5 27 0 47.5 9.875t47.25 30.875Q171.5 96 212 96q37 0 70 8 26.25-20.5 46.75-30.25T376 64q12.75 25.5 12.75 54.5 0 21.75-6.75 42 34 40 34 99.5z"/></svg>
        
      </defs>
    </svg>
    <input class="md-toggle" data-md-toggle="drawer" type="checkbox" id="__drawer" autocomplete="off">
    <input class="md-toggle" data-md-toggle="search" type="checkbox" id="__search" autocomplete="off">
    <label class="md-overlay" data-md-component="overlay" for="__drawer"></label>
    
      <a href="#reason" tabindex="1" class="md-skip">
        Skip to content
      </a>
    
    
      <header class="md-header" data-md-component="header">
  <nav class="md-header-nav md-grid">
    <div class="md-flex">
      <div class="md-flex__cell md-flex__cell--shrink">
        <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-header-nav__button md-logo">
          
            <img src="../images/logo.svg" width="24" height="24">
          
        </a>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        <label class="md-icon md-icon--menu md-header-nav__button" for="__drawer"></label>
      </div>
      <div class="md-flex__cell md-flex__cell--stretch">
        <div class="md-flex__ellipsis md-header-nav__title" data-md-component="title">
          
            <span class="md-header-nav__topic">
              C++ 핵심 가이드라인
            </span>
            <span class="md-header-nav__topic">
              
                Class
              
            </span>
          
        </div>
      </div>
      <div class="md-flex__cell md-flex__cell--shrink">
        
          <label class="md-icon md-icon--search md-header-nav__button" for="__search"></label>
          
<div class="md-search" data-md-component="search" role="dialog">
  <label class="md-search__overlay" for="__search"></label>
  <div class="md-search__inner" role="search">
    <form class="md-search__form" name="search">
      <input type="text" class="md-search__input" name="query" placeholder="Search" autocapitalize="off" autocorrect="off" autocomplete="off" spellcheck="false" data-md-component="query" data-md-state="active">
      <label class="md-icon md-search__icon" for="__search"></label>
      <button type="reset" class="md-icon md-search__icon" data-md-component="reset" tabindex="-1">
        &#xE5CD;
      </button>
    </form>
    <div class="md-search__output">
      <div class="md-search__scrollwrap" data-md-scrollfix>
        <div class="md-search-result" data-md-component="result">
          <div class="md-search-result__meta">
            Type to start searching
          </div>
          <ol class="md-search-result__list"></ol>
        </div>
      </div>
    </div>
  </div>
</div>
        
      </div>
      
        <div class="md-flex__cell md-flex__cell--shrink">
          <div class="md-header-nav__source">
            


  

<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
          </div>
        </div>
      
    </div>
  </nav>
</header>
    
    <div class="md-container">
      
        
      
      
        

  

<nav class="md-tabs md-tabs--active" data-md-component="tabs">
  <div class="md-tabs__inner md-grid">
    <ul class="md-tabs__list">
      
        
      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Introduction/" class="md-tabs__link">
          Introduction
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../References/" class="md-tabs__link">
          References
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../Architecture/" class="md-tabs__link md-tabs__link--active">
          Sections
        </a>
      
    </li>
  

      
        
  
  
    <li class="md-tabs__item">
      
        <a href="../appendix/Modernizing/" class="md-tabs__link">
          Appendix
        </a>
      
    </li>
  

      
    </ul>
  </div>
</nav>
      
      <main class="md-main" role="main">
        <div class="md-main__inner md-grid" data-md-component="container">
          
            
              <div class="md-sidebar md-sidebar--primary" data-md-component="navigation">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    <nav class="md-nav md-nav--primary" data-md-level="0">
  <label class="md-nav__title md-nav__title--site" for="__drawer">
    <a href="http://www.cppkorea.org/CppCoreGuidelines" title="C++ 핵심 가이드라인" class="md-nav__button md-logo">
      
        <img src="../images/logo.svg" width="48" height="48">
      
    </a>
    C++ 핵심 가이드라인
  </label>
  
    <div class="md-nav__source">
      


  

<a href="http://github.com/CppKorea/CppCoreGuidelines/" title="Go to repository" class="md-source" data-md-source="github">
  
    <div class="md-source__icon">
      <svg viewBox="0 0 24 24" width="24" height="24">
        <use xlink:href="#__github" width="24" height="24"></use>
      </svg>
    </div>
  
  <div class="md-source__repository">
    CppKorea/CppCoreGuidelines
  </div>
</a>
    </div>
  
  <ul class="md-nav__list" data-md-scrollfix>
    
      
      
      


  <li class="md-nav__item">
    <a href="../home/" title="Overview" class="md-nav__link">
      Overview
    </a>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-2" type="checkbox" id="nav-2">
    
    <label class="md-nav__link" for="nav-2">
      Introduction
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-2">
        Introduction
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Introduction/" title="In: 소개" class="md-nav__link">
      <a name="S-introduction"></a>In: 소개
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-3" type="checkbox" id="nav-3">
    
    <label class="md-nav__link" for="nav-3">
      References
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-3">
        References
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../References/" title="RF: 레퍼런스" class="md-nav__link">
      <a name="S-references"></a>RF: 레퍼런스
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      

  


  <li class="md-nav__item md-nav__item--active md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-4" type="checkbox" id="nav-4" checked>
    
    <label class="md-nav__link" for="nav-4">
      Sections
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-4">
        Sections
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../Architecture/" title="Architecture" class="md-nav__link">
      Architecture
    </a>
  </li>

        
          
          
          

  


  <li class="md-nav__item md-nav__item--active">
    
    <input class="md-toggle md-nav__toggle" data-md-toggle="toc" type="checkbox" id="__toc">
    
      
    
    
    <a href="./" title="Class" class="md-nav__link md-nav__link--active">
      Class
    </a>
    
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Concurrency/" title="Concurrency" class="md-nav__link">
      Concurrency
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Const/" title="Const" class="md-nav__link">
      Const
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../CPL/" title="C-Style" class="md-nav__link">
      C-Style
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Enum/" title="Enum" class="md-nav__link">
      Enum
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Errors/" title="Errors" class="md-nav__link">
      Errors
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Expr/" title="Expr" class="md-nav__link">
      Expr
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Functions/" title="Functions" class="md-nav__link">
      Functions
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Glossary/" title="Glossary" class="md-nav__link">
      Glossary
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../GSL/" title="GSL" class="md-nav__link">
      GSL
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Interfaces/" title="Interfaces" class="md-nav__link">
      Interfaces
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Naming/" title="Naming" class="md-nav__link">
      Naming
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Not/" title="Not-Rule" class="md-nav__link">
      Not-Rule
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Performance/" title="Performance" class="md-nav__link">
      Performance
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Philosophy/" title="Philosophy" class="md-nav__link">
      Philosophy
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Profile/" title="Profile" class="md-nav__link">
      Profile
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Resource/" title="Resource" class="md-nav__link">
      Resource
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../SL/" title="Standard Library" class="md-nav__link">
      Standard Library
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Source/" title="Source" class="md-nav__link">
      Source
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Templates/" title="Templates" class="md-nav__link">
      Templates
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../Unclassified/" title="Unclassified" class="md-nav__link">
      Unclassified
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
      
      
      


  <li class="md-nav__item md-nav__item--nested">
    
      <input class="md-toggle md-nav__toggle" data-md-toggle="nav-5" type="checkbox" id="nav-5">
    
    <label class="md-nav__link" for="nav-5">
      Appendix
    </label>
    <nav class="md-nav" data-md-component="collapsible" data-md-level="1">
      <label class="md-nav__title" for="nav-5">
        Appendix
      </label>
      <ul class="md-nav__list" data-md-scrollfix>
        
        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Modernizing/" title="Modernizing" class="md-nav__link">
      Modernizing
    </a>
  </li>

        
          
          
          


  <li class="md-nav__item">
    <a href="../appendix/Tools/" title="Tools" class="md-nav__link">
      Tools
    </a>
  </li>

        
      </ul>
    </nav>
  </li>

    
  </ul>
</nav>
                  </div>
                </div>
              </div>
            
            
              <div class="md-sidebar md-sidebar--secondary" data-md-component="toc">
                <div class="md-sidebar__scrollwrap">
                  <div class="md-sidebar__inner">
                    
<nav class="md-nav md-nav--secondary">
  
  
    
  
  
</nav>
                  </div>
                </div>
              </div>
            
          
          <div class="md-content">
            <article class="md-content__inner md-typeset">
              
                
                  <a href="http://github.com/CppKorea/CppCoreGuidelines/edit/master/docs/Class.md" title="Edit this page" class="md-icon md-content__icon">&#xE3C9;</a>
                
                
                <h1 id="c"><a name="S-class"></a>C: 클래스와 클래스 계층 구조</h1>
<p>클래스는 사용자 정의 타입으로써, 타입의 표현과 연산, 인터페이스를 프로그래머가  정의할 수 있다.
클래스 계층 구조는 관련된 클래스들을 계층적으로 구조화 할 때 사용된다.</p>
<p>클래스 규칙 요약:</p>
<ul>
<li><a href="#Rc-org">C.1: 관련된 데이터를 조직화 하라 (<code>struct</code> 와 <code>class</code>)</a></li>
<li><a href="#Rc-struct">C.2: 타입이 불변조건을 가진다면, <code>class</code>를 사용하라; 데이터 멤버들에 대한 제약이 자유롭다면 <code>struct</code>를 사용하라</a></li>
<li><a href="#Rc-interface">C.3: 클래스를 사용해 인터페이스와 구현을 분리하라</a></li>
<li><a href="#Rc-member">C.4: 클래스에 직접적으로 접근할 필요가 있는 경우에만 함수를 멤버함수로 작성하라</a></li>
<li><a href="#Rc-helper">C.5: 보조 함수들은 관련 클래스와 같은 namespace에 배치하라</a></li>
<li><a href="#Rc-standalone">C.7: 클래스 또는 열거형에 대한 정의와 변수 선언을 같은 구문에 넣지 말아라</a></li>
<li><a href="#Rc-class">C.8: non-public 멤버가 있다면 <code>struct</code>보단 <code>class</code>를 사용하라</a></li>
<li><a href="#Rc-private">C.9: 멤버들의 노출을 최소화하라</a></li>
</ul>
<p>하위 영역:</p>
<ul>
<li><a href="#SS-concrete">C.concrete: 실제 타입(Concrete types)</a></li>
<li><a href="#S-ctor">C.ctor: 생성자, 대입 연산자, 소멸자</a></li>
<li><a href="#SS-containers">C.con: 컨테이너와 리소스 핸들</a></li>
<li><a href="#SS-lambdas">C.lambdas: 함수 개체와 람다 표현식</a></li>
<li><a href="#SS-hier">C.hier: 클래스 계층 구조 (OOP)</a></li>
<li><a href="#SS-overload">C.over: 오버로딩</a></li>
<li><a href="#SS-union">C.union: 공용체</a></li>
</ul>
<h3 id="c1-struct-class"><a name="Rc-org"></a>C.1: 관련된 데이터를 조직화 하라 (<code>struct</code> 와 <code>class</code>)</h3>
<h5 id="reason">Reason</h5>
<p>이해하기 쉽다. 근본적인 이유로 데이터가 관련이 있다면, 그 사실은 코드에 반영되어야 한다.</p>
<h5 id="example">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y2</span><span class="p">);</span>  <span class="c1">// BAD: unnecessary implicit relationships</span>
    <span class="kt">void</span> <span class="nf">draw</span><span class="p">(</span><span class="n">Point</span> <span class="n">from</span><span class="p">,</span> <span class="n">Point</span> <span class="n">to</span><span class="p">);</span>          <span class="c1">// better</span>
</pre></div>


<h5 id="note">Note</h5>
<p>가상 함수가 없는 간단한 클래스는 공간, 시간적인 오버헤드가 없다.</p>
<h5 id="note_1">Note</h5>
<p>언어적인 관점에서 볼 때 <code>class</code> 와 <code>struct</code>의 차이는 멤버들의 가시성(visibility)이다.</p>
<h5 id="enforcement">Enforcement</h5>
<p>특별히 없다. 데이터 항목들에 대한 경험적인 관점들이 함께 반영될 수는 있을 것이다.</p>
<h3 id="c2-class-struct"><a name="Rc-struct"></a>C.2: 타입이 불변조건을 가진다면, <code>class</code>를 사용하라; 데이터 멤버들에 대한 제약이 자유롭다면 <code>struct</code>를 사용하라</h3>
<h5 id="reason_1">Reason</h5>
<p>가독성이 좋고 이해하기도 쉽다.
<code>class</code> 를 사용함으로써, 프로그래머가 불변조건(invariant)이 필요하다는 것을 알게 된다.<br />
이 점은 유익한 관습이다.</p>
<h5 id="note_2">Note</h5>
<p>invariant는 개체 멤버들의 논리적인 상태로써, 공개 멤버 함수들이 가정할 수 있도록 생성자가 설정 해 주어야 한다. invariant가 설정된 후에야 (일반적으로 생성자에 의해) 모든 멤버 함수는 개체를 통해 호출될 수 있다.
invariant는 형식에 구애받지 않고 (가령, 주석으로) 기술될 수 있으며, 더 형식을 갖춘다면 <code>Expects</code> 를 사용할 수 있다.</p>
<p>만약 모든 데이터 멤버들이 상호독립적이라면, 불변조건은 존재할 수 없다.</p>
<h5 id="example_1">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Pair</span> <span class="p">{</span>  <span class="c1">// the members can vary independently</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">volume</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>하지만:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// validate that {yy, mm, dd} is a valid date and initialize</span>
        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">yy</span><span class="p">,</span> <span class="n">Month</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">char</span> <span class="n">dd</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">Month</span> <span class="n">m</span><span class="p">;</span>
        <span class="kt">char</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// day</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note_3">Note</h5>
<p>클래스가 어떤 <code>private</code> 데이터를 가지고 있으면, 사용자는 생성자 호출 없이 개체를 초기화할 수 없다. 
따라서, 클래스를 정의하는 사람은 생성자를 제공하고 그 의미를 명시해야만 한다.
이는 클래스 작성자가 invariant를 정의해야 한다는 것을 의미한다.</p>
<h5 id="see-also">See also</h5>
<ul>
<li><a href="#Rc-class">private 데이터를 가지고 있다면 <code>class</code>를 사용하라</a></li>
<li><a href="../Naming/#Rl-order">클래스 정의에 인터페이스를 먼저 배치하라</a></li>
<li><a href="#Rc-private">멤버의 노출을 최소화하라</a></li>
<li><a href="#Rh-protected"><code>protected</code> 데이터 사용을 지양하라</a></li>
</ul>
<h5 id="enforcement_1">Enforcement</h5>
<p>private 데이터를 가진 <code>struct</code>나 public 멤버를 가진 <code>class</code>들을 찾아낸다.</p>
<h3 id="c3"><a name="Rc-interface"></a>C.3: 클래스를 사용해 인터페이스와 구현을 분리하라</h3>
<h5 id="reason_2">Reason</h5>
<p>인터페이스와 구현에 대한 분명한 구분은 가독성을 더 좋게 하고, 유지 보수를 단순하게 한다.</p>
<h5 id="example_2">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
        <span class="c1">// ... some representation ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Date</span><span class="p">();</span>
        <span class="c1">// validate that {yy, mm, dd} is a valid date and initialize</span>
        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">yy</span><span class="p">,</span> <span class="n">Month</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">char</span> <span class="n">dd</span><span class="p">);</span>

        <span class="kt">int</span> <span class="nf">day</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">Month</span> <span class="nf">month</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>이러한 경우, 이제 사용자에게 영향을 주지 않고 <code>Date</code> 에 대한 representation을 변경할 수 있다. (비록 다시 컴파일 해야 하겠지만)</p>
<h5 id="note_4">Note</h5>
<p>인터페이스와 구현간의 구분을 표현하기 위해 클래스를 사용하는 것이 유일한 방법은 아니다.
예를 들면, 인터페이스를 표현하기 위한 개념으로 네임스페이스 안에 독립적인 함수들이나 추상 기본 클래스 혹은 템플릿 함수들을 선언해서 사용할 수 있다.
가장 중요한 것을 명시적으로 인터페이스와 그것들의 구현 "세부사항"을 구분하는 것이다.
이상적으로, 그리고 일반적으로, 인터페이스는 그 구현들보다 훨씬 더 안정적이다.</p>
<h5 id="enforcement_2">Enforcement</h5>
<p>???</p>
<h3 id="c4"><a name="Rc-member"></a>C.4: 클래스에 직접적으로 접근할 필요가 있는 경우에만 함수를 멤버함수로 작성하라</h3>
<h5 id="reason_3">Reason</h5>
<p>멤버 함수간 커플링을 줄인다. 개체 상태 변경에 의해 문제가 생기는 함수를 줄인다. 표현이 변경된 후에 수정될 필요가 있는 멤버 함수의 수를 줄인다.</p>
<h5 id="example_3">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
        <span class="c1">// ... 상대적으로 적은 인터페이스 ...</span>
    <span class="p">};</span>

    <span class="c1">// helper functions:</span>
    <span class="n">Date</span> <span class="nf">next_weekday</span><span class="p">(</span><span class="n">Date</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Date</span><span class="p">,</span> <span class="n">Date</span><span class="p">);</span>
</pre></div>


<p>"helper functions"으로 표시된 함수들은 <code>Date</code>의 내부에 접근할 필요가 없다.</p>
<h5 id="note_5">Note</h5>
<p><a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2016/p0251r0.pdf">"uniform function call"</a>이 가능해지면 더 좋아질 것이다.</p>
<h5 id="exception">Exception</h5>
<p>C++ 에서는 멤버 함수만이 <code>virtual</code> 함수가 될 수 있지만, 모든 <code>virtual</code>가 멤버에 접근하는 것은 아니다. 특히 추상 클래스들은 멤버에 접근하는 경우가 드물다.</p>
<p><a href="https://parasol.tamu.edu/~yuriys/papers/OMM10.pdf">multi-methods</a>를 확인하라.</p>
<h5 id="exception_1">Exception</h5>
<p>C++ 언어에서 <code>=</code>, <code>()</code>, <code>[]</code>, <code>-&gt;</code> 연산자는 멤버함수여야 한다.</p>
<h5 id="exception_2">Exception</h5>
<p>중복정의(overload) 집합에 <code>private</code> 데이터에 직접 접근하지 않는 멤버가 있을 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foobar</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">long</span> <span class="n">x</span><span class="p">)</span>    <span class="p">{</span> <span class="cm">/* manipulate private data */</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">foo</span><span class="p">(</span><span class="kt">double</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">foo</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">lround</span><span class="p">(</span><span class="n">x</span><span class="p">));</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>유사하게, 어떤 함수들은 연속적으로 호출하도록 설계되었을 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">x</span><span class="p">.</span><span class="n">scale</span><span class="p">(</span><span class="mf">0.5</span><span class="p">).</span><span class="n">rotate</span><span class="p">(</span><span class="mi">45</span><span class="p">).</span><span class="n">set_color</span><span class="p">(</span><span class="n">Color</span><span class="o">::</span><span class="n">red</span><span class="p">);</span>
</pre></div>


<p>일반적으로, 이런 함수들 중 일부는 <code>private</code> 데이터에 접근한다.</p>
<h5 id="enforcement_3">Enforcement</h5>
<ul>
<li>데이터 멤버에 직접 접근하지 않는 비 가상 멤버 함수를 찾아낸다. 이런 함수는 많은 멤버 함수들이 데이터 멤버를 직접 접근할 필요가 없음을 의미한다</li>
<li><code>virtual</code> 함수들은 무시한다</li>
<li>중복정의하는 함수 중 하나 이상의 함수가 <code>private</code> 데이터 멤버에 접근할 때, 접근하지 않는 다른 함수들은 무시한다</li>
<li><code>this</code>를 반환하는 함수들은 무시한다</li>
</ul>
<h3 id="c5-namespace"><a name="Rc-helper"></a>C.5: 보조 함수들은 관련 클래스와 같은 namespace에 배치하라</h3>
<h5 id="reason_4">Reason</h5>
<p>보조 함수(helper function)는 (보통 클래스 작성자가 제공하는) 클래스의 표현에 직접 접근할 필요가 없는 함수이며, 클래스에 대한 유용한 인터페이스 중에 하나로 볼 수 있다.
보조 함수들을 같은 네임스페이스에 넣으면 함수와 클래스의 관계가 명확해지고, Argument Dependent Lookup에서 발견 할 수 있게 된다.</p>
<h5 id="example_4">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">namespace</span> <span class="n">Chrono</span> <span class="p">{</span> <span class="c1">// here we keep time-related services</span>

        <span class="k">class</span> <span class="nc">Time</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
        <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

        <span class="c1">// helper functions:</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Date</span><span class="p">,</span> <span class="n">Date</span><span class="p">);</span>
        <span class="n">Date</span> <span class="nf">next_weekday</span><span class="p">(</span><span class="n">Date</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_6">Note</h5>
<p>이는 <a href="#Ro-namespace">연산자 오버로딩</a>을 위해서 매우 중요하다.</p>
<h5 id="enforcement_4">Enforcement</h5>
<ul>
<li>단일 네임스페이스에서 인자 타입을 취하는 전역함수들을 지적하라</li>
</ul>
<h3 id="c7"><a name="Rc-standalone"></a>C.7: 클래스 또는 열거형에 대한 정의와 변수 선언을 같은 구문에 넣지 말아라</h3>
<h5 id="reason_5">Reason</h5>
<p>타입에 대한 정의와 다른 개체(entitiy)에 대한 정의를 같은 구문(statement)에 넣는 것은 혼동을 일으킬 수 있고, 불필요하다.</p>
<h5 id="example-bad">Example; bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Data</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">}</span> <span class="n">data</span><span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</pre></div>


<h5 id="example-good">Example; good</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Data</span> <span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
    <span class="n">Data</span> <span class="n">data</span><span class="p">{</span> <span class="cm">/*...*/</span> <span class="p">};</span>
</pre></div>


<h5 id="enforcement_5">Enforcement</h5>
<ul>
<li>클래스나 열거형의 정의에 있는 닫는 괄호 <code>}</code>에 <code>;</code>이 바로 나타나지 않으면 지적하라</li>
</ul>
<h3 id="c8-non-public-struct-class"><a name="Rc-class"></a>C.8: non-public 멤버가 있다면 <code>struct</code>보단 <code>class</code>를 사용하라</h3>
<h5 id="reason_6">Reason</h5>
<p>가독성에 좋다.<br />
무엇인가 숨겨져 있거나, 추상화되었다는 것을 분명하게 한다.<br />
유익한 관습이다.</p>
<h5 id="example-bad_1">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Date</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">;</span>

        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="n">Month</span> <span class="n">m</span><span class="p">);</span>
        <span class="c1">// ... lots of functions ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>  <span class="c1">// year</span>
    <span class="p">};</span>
</pre></div>


<p>C++ 언어 규칙을 고려했을 때 이 코드엔 잘못된 것이 없다.<br />
하지만 디자인 관점에서는 모든게 잘못되었다.
private 데이터가 public 데이터와 멀리 떨어져 숨어있고, 클래스 선언의 다른 부분들로 분리되어 있다.<br />
이런 요소들은 가독성을 저해하고 유지보수를 복잡하게 한다.</p>
<h5 id="note_7">Note</h5>
<p>클래스 인터페이스를 먼저 배치하라. <a href="../Naming/#Rl-order">NL.16을 참고하라</a></p>
<h5 id="enforcement_6">Enforcement</h5>
<p><code>private</code> 혹은 <code>protected</code> 멤버를 가지지만 <code>struct</code>로 선언된 클래스를 지적한다</p>
<h3 id="c9"><a name="Rc-private"></a>C.9: 멤버들의 노출을 최소화하라</h3>
<h5 id="reason_7">Reason</h5>
<p>캡슐화. 정보 은닉. 의도치 않은 접근을 최소화 하고, 유지보수를 쉽게 한다.</p>
<h5 id="example_5">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="p">,</span> <span class="k">typename</span> <span class="n">U</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">pair</span> <span class="p">{</span>
        <span class="n">T</span> <span class="n">a</span><span class="p">;</span>
        <span class="n">U</span> <span class="n">b</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>//</code> 부분에 어떤 코드가 작성되건, <code>pair</code>의 사용자는 <code>a</code>와 <code>b</code>를 독립적으로 변경할 수 있다.
코드 규모가 큰 경우, <code>pair</code>의 멤버에 어떤 일이 일어나는지 찾기 어렵다.</p>
<p>독립적으로 변경하는 것이 의도에 맞을 수 있지만, 멤버간의 관계를 강제하고 싶다면, <code>private</code>로 변경하고 그 관계(불변조건)를 생성자와 멤버 함수들로 지키도록 해야 한다.</p>
<p>예를 들자면:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Distance</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="kt">double</span> <span class="n">meters</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">magnitude</span><span class="o">*</span><span class="n">unit</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">set_unit</span><span class="p">(</span><span class="kt">double</span> <span class="n">u</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// ... check that u is a factor of 10 ...</span>
            <span class="c1">// ... change magnitude appropriately ...</span>
            <span class="n">unit</span> <span class="o">=</span> <span class="n">u</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">double</span> <span class="n">magnitude</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">unit</span><span class="p">;</span>    <span class="c1">// 1 is meters, 1000 is kilometers, 0.001 is millimeters, etc.</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note_8">Note</h5>
<p>만약 변수들에 접근하는 코드를 쉽게 결정할 수 없다면, 그 타입이나 사용을 (쉽게) 변경하거나 개선하기 어렵다.
<code>public</code>과 <code>protected</code>데이터는 보통 이 경우에 해당한다.</p>
<h5 id="example_6">Example</h5>
<p>클래스는 사용자에게 두가지 인터페이스를 제공할 수 있다. 하나는 상속받는 클래스에게 제공하는 <code>protected</code>이며 하나는 일반적으로 사용 가능한 <code>public</code>이다.
예를 들면, 하위 클래스는 상위 클래스의 불변조건이 유지된다는 것을 확실히 할 수 있다면 실행시간 검사를 생략 할수도 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="p">{</span> <span class="n">check</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="k">return</span> <span class="nf">do_bar</span><span class="p">(</span><span class="n">x</span><span class="p">);</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">do_bar</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span> <span class="c1">// do some operation on the data</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="c1">// ... data ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Dir</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Foo</span> <span class="p">{</span>
        <span class="c1">//...</span>
        <span class="kt">int</span> <span class="n">mem</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="cm">/* ... do something ... */</span>
            <span class="k">return</span> <span class="n">do_bar</span><span class="p">(</span><span class="n">x</span> <span class="o">+</span> <span class="n">y</span><span class="p">);</span> <span class="c1">// OK: derived class can bypass check</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">user</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">int</span> <span class="n">r1</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">bar</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>      <span class="c1">// OK, will check</span>
        <span class="kt">int</span> <span class="n">r2</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">do_bar</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>   <span class="c1">// error: would bypass check</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_9">Note</h5>
<p><a href="#Rh-protected"><code>protected</code> 데이터는 좋은 생각이 아니다</a>.</p>
<h5 id="note_10">Note</h5>
<p><code>public</code> 멤버를 가장 앞에, <code>protected</code> 멤버를 다음에, <code>private</code> 멤버를 마지막에 배치하라.</p>
<h5 id="enforcement_7">Enforcement</h5>
<ul>
<li><a href="#Rh-protected">protected 데이터를 지적하라</a></li>
<li><code>public</code>과 <code>private</code> 데이터가 함께 사용된 경우를 지적하라</li>
</ul>
<h2 id="cconcrete-concrete-types"><a name="SS-concrete"></a>C.concrete: 실제 타입(Concrete types)</h2>
<p>이상적인 클래스는 정규 타입(Regular Type)과 같아야 한다.
쉽게 말하면 "<code>int</code> 처럼 동작하는 것"이다. 실제 타입(Concrete type)이란 가장 간단한 종류의 클래스를 의미한다.</p>
<blockquote>
<p>역주:<br />
Regular Type은 다음의 조건을 모두 만족하는 타입을 의미합니다.
- DefaultConstructible
- CopyConstructible, CopyAssignable
- MoveConstructible, MoveAssignable
- Destructible
- Swappable
- EqualityComparable</p>
<p>예시로 언급된 <code>int</code>의 경우, 기본 연산(생성, 파괴, 복사, 이동)을 지원하면서 교환, 동등비교가 가능합니다</p>
</blockquote>
<p>정규 타입의 값은 복사 될 수 있고, 복사의 결과는 원본과 같은 값을 갖는 독립적인 개체이다. 타입이 <code>=</code> 와 <code>==</code> 를 모두 갖는다면, <code>a = b</code>를 실행한 이후에는 <code>a == b</code>에서 <code>true</code>가 반환되도록 해야 한다.
실제 타입이 대입과 동등 비교를 지원하지 않을 수 있지만, 그런 경우는 드물다 (거의 없어야 한다).</p>
<p>C++의 언어 내장(built-in) 타입들은 정규적(Regular)이고, <code>string</code>, <code>vector</code>, <code>map</code>같은 표준 라이브러리의 클래스들 또한 그렇다. 실제 타입들은 종종 계층구조의 일부로 사용되는 타입들과 구분하여 값 타입으로 언급된다.</p>
<p>실제 타입 규칙 요약:</p>
<ul>
<li><a href="#Rc-concrete">C.10: 클래스 계층 보다 실제(Concrete) 타입들을 선호하라</a></li>
<li><a href="#Rc-regular">C.11: 실제 타입들은 정규적으로 만들어라</a></li>
</ul>
<h3 id="c10-concrete"><a name="Rc-concrete"></a>C.10: 클래스 계층 보다 실제(Concrete) 타입들을 선호하라</h3>
<h5 id="reason_8">Reason</h5>
<p>실제 타입은 근본적으로 계층구조보다 단순하다:
디자인이 더 쉽고, 구현이 더 쉽고, 사용하기가 더 쉬우며, 추론하기 더 쉽다. 더 작고 더 빠르기도 하다.<br />
계층구조를 사용할 때는 타당한 이유가 있어야 한다.</p>
<h5 id="example_7">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Point1</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="c1">// ... operations ...</span>
        <span class="c1">// ... no virtual functions ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Point2</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
        <span class="c1">// ... operations, some virtual ...</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">Point2</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Point1</span> <span class="n">p11</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">};</span>   <span class="c1">// make an object on the stack</span>
        <span class="n">Point1</span> <span class="n">p12</span> <span class="p">{</span><span class="n">p11</span><span class="p">};</span>    <span class="c1">// a copy</span>

        <span class="k">auto</span> <span class="n">p21</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Point2</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>   <span class="c1">// make an object on the free store</span>
        <span class="k">auto</span> <span class="n">p22</span> <span class="o">=</span> <span class="n">p21</span><span class="p">.</span><span class="n">clone</span><span class="p">();</span>                 <span class="c1">// make a copy</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>클래스가 계층구조의 일부가 될 수 있다면, 반드시 포인터나 레퍼런스로 개체를 다루어야 한다.
이는 간접 처리를 위해 더 많은 메모리를 사용하게 되고, 더 많은 할당과 해제, 실행시간 오버헤드가 발생하게 된다는 것을 의미한다.</p>
<h5 id="note_11">Note</h5>
<p>실제 타입은 스택에 할당될 수 있고, 다른 클래스의 멤버가 될 수 있다.</p>
<h5 id="note_12">Note</h5>
<p>실행시간에 다형적 인터페이스를 위해 간접처리는 필수적이다.
할당과 해제의 추가비용은 그렇지 않다. (단지 가장 흔한 사례일 뿐이다)
파생 클래스의 제한된(특정된) 개체에 대한 인터페이스로써 기본 클래스를 사용할 수도 있다.
동적 할당을 할 수 없으며, 플러그인과 같은 것들에게 안정적인 인터페이스를 제공하고자 할 때 이렇게 할 수 있다. (예컨대, hard real-time)</p>
<h5 id="enforcement_8">Enforcement</h5>
<p>???</p>
<h3 id="c11"><a name="Rc-regular"></a>C.11: 실제 타입들은 정규적으로 만들어라</h3>
<h5 id="reason_9">Reason</h5>
<p>일반적인(regular) 타입은 이해하고 추론(reason)하기 쉽다.
(일반적이지 않은 타입들은 이해하고 사용하는데 추가적인 노력을 필요로 한다.)</p>
<h5 id="example_8">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Bundle</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">Record</span><span class="o">&gt;</span> <span class="n">vr</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">Bundle</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">Bundle</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">vr</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">vr</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Bundle</span> <span class="n">b1</span> <span class="p">{</span> <span class="s">&quot;my bundle&quot;</span><span class="p">,</span> <span class="p">{</span><span class="n">r1</span><span class="p">,</span> <span class="n">r2</span><span class="p">,</span> <span class="n">r3</span><span class="p">}};</span>
    <span class="n">Bundle</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b1</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span><span class="p">))</span> <span class="n">error</span><span class="p">(</span><span class="s">&quot;impossible!&quot;</span><span class="p">);</span>
    <span class="n">b2</span><span class="p">.</span><span class="n">name</span> <span class="o">=</span> <span class="s">&quot;the other bundle&quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">b1</span> <span class="o">==</span> <span class="n">b2</span><span class="p">)</span> <span class="n">error</span><span class="p">(</span><span class="s">&quot;No!&quot;</span><span class="p">);</span>
</pre></div>


<p>일반적인 경우, 만약 concrete type이 대입연산(<code>a = b</code>)을 지원한다면, 비교 연산(<code>a == b</code>)도 지원한다.</p>
<h5 id="enforcement_9">Enforcement</h5>
<p>???</p>
<h2 id="cctor"><a name="S-ctor"></a>C.ctor: 생성자, 대입 연산자, 소멸자</h2>
<p>이 함수들은 개체의 생명주기를 제어 한다: 생성, 복사, 이동, 그리고 소멸.
생성자를 정의해서 클래스의 초기화를 보장하고 단순화 하라.</p>
<p><em>기본 연산</em>은 아래와 같은 연산들을 의미한다.</p>
<ul>
<li>기본 생성자: <code>X()</code></li>
<li>복사 생성자: <code>X(const X&amp;)</code></li>
<li>복사 대입 연산자: <code>operator=(const X&amp;)</code></li>
<li>이동 생성자: <code>X(X&amp;&amp;)</code></li>
<li>이동 대입 연산자: <code>operator=(X&amp;&amp;)</code></li>
<li>소멸자: <code>~X()</code></li>
</ul>
<p>이상의 연산들은 정의하지 않아도 코드에서 사용되면 컴파일러가 생성한다. 하지만 기본연산을 제한하는 것도 가능하다.</p>
<p>기본 연산은 개체의 수명주기와 관련된 연산들의 집합을 의미한다.</p>
<p>코드가 명시하지 않는 한, C++은 클래스를 값 타입 처럼 다루지만 모든 타입이 값 타입처럼 동작하는 것은 아니다.</p>
<p>기본 연산 규칙들:</p>
<ul>
<li><a href="#Rc-zero">C.20: 기본 연산을 정의하지 않아도 되면 그렇게 하라</a></li>
<li><a href="#Rc-five">C.21: 기본 연산을 정의 하거나 <code>=delete</code> 로 선언했다면, 나머지 모두 정의하거나 <code>=delete</code>하라</a></li>
<li><a href="#Rc-matched">C.22: 기본 연산들은 서로 조화롭게 동작해야 한다</a></li>
</ul>
<p>소멸자 규칙들:</p>
<ul>
<li><a href="#Rc-dtor">C.30: 개체가 없어질 때, 명시적인 동작이 필요할 경우 소멸자를 정의하라</a></li>
<li><a href="#Rc-dtor-release">C.31: 클래스가 획득한 모든 자원은 소멸자에서 해제되어야 한다</a></li>
<li><a href="#Rc-dtor-ptr">C.32: 클래스가 포인터(<code>T*</code>)나 참조(<code>T&amp;</code>)를 가지고 있다면, 참조 대상을 소유하고 있는지를 고려하라</a></li>
<li><a href="#Rc-dtor-ptr2">C.33: 클래스가 포인터로 대상을 소유하고 있다면, 소멸자를 정의하라</a></li>
<li><a href="#Rc-dtor-virtual">C.35: 상위 클래스의 소멸자는 공개된 가상 소멸자 혹은 상속되는 비-가상 함수여야 한다</a></li>
<li><a href="#Rc-dtor-fail">C.36: 소멸자는 실패해선 안된다</a></li>
<li><a href="#Rc-dtor-noexcept">C.37: 소멸자를 <code>noexcept</code>로 작성하라</a></li>
</ul>
<p>생성자 규칙들:</p>
<ul>
<li><a href="#Rc-ctor">C.40: 클래스가 불변조건을 가진다면 생성자를 정의하라</a></li>
<li><a href="#Rc-complete">C.41: 생성자는 완전히 초기화된 개체를 생성해야 한다</a></li>
<li><a href="#Rc-throw">C.42: 생성자가 유효한 개체를 생성하지 못한다면, 예외를 던지도록 하라</a></li>
<li><a href="#Rc-default0">C.43: 복사 가능한 클래스(값 타입)는 반드시 기본 생성자를 갖도록 하라</a></li>
<li><a href="#Rc-default00">C.44: 기본 생성자는 가능한 단순하고 예외를 던지지 않도록 하라</a></li>
<li><a href="#Rc-default">C.45: 멤버를 초기화 하기만 하는 기본 생성자는 정의하지 마라; 대신 멤버들이 스스로 초기화 하도록 하라</a></li>
<li><a href="#Rc-explicit">C.46: 단일 인자를 사용하는 생성자는 <code>explicit</code>으로 선언하라</a></li>
<li><a href="#Rc-order">C.47: 멤버 변수들은 선언된 순서대로 초기화하라</a></li>
<li><a href="#Rc-in-class-initializer">C.48: 상수 초기화는 가능한 클래스 내(in-class) 멤버 초기화를 사용하라</a></li>
<li><a href="#Rc-initialize">C.49: 생성자 안에서의 대입 보다는 초기화를 선호하라</a></li>
<li><a href="#Rc-factory">C.50: 초기화 과정에서 <code>virtual</code> 동작이 필요하다면, 팩토리 함수를 사용하라</a></li>
<li><a href="#Rc-delegating">C.51: 클래스의 모든 생성자들을 위한 일반적인 동작을 표현할 때는 대리 생성자를 사용하라</a></li>
<li><a href="#Rc-inheriting">C.52: 추가적인 초기화가 필요하지 않은 파생된 클래스에서 생성자를 사용할 때는 상속 생성자들을 사용하라</a></li>
</ul>
<p>복사와 이동 규칙들:</p>
<ul>
<li><a href="#Rc-copy-assignment">C.60: 복사연산을 <code>virtual</code>로 만들지 말아라. 매개변수는 <code>const&amp;</code>로 받고, <code>const&amp;</code>로 반환하지 말아라</a></li>
<li><a href="#Rc-copy-semantic">C.61: 복사 연산은 복사를 수행해야 한다</a></li>
<li><a href="#Rc-copy-self">C.62: 복사 연산은 자기 대입에 안전하게 작성하라</a></li>
<li><a href="#Rc-move-assignment">C.63: 이동 연산은 <code>virtual</code>로 만들지 말아라, 매개변수는 <code>&amp;&amp;</code>를 사용하고, <code>const&amp;</code>로 반환하지 말아라</a></li>
<li><a href="#Rc-move-semantic">C.64: 이동 연산은 이동을 수행해야 하며, 원본 개체를 유효한 상태로 남겨놓아야 한다</a></li>
<li><a href="#Rc-move-self">C.65: 이동 연산은 자기 대입에 안전하게 작성하라</a></li>
<li><a href="#Rc-move-noexcept">C.66: 이동 연산은 <code>noexcept</code>로 만들어라</a></li>
<li><a href="#Rc-copy-virtual">C.67: 다형적인 클래스는 복사를 제한해야 한다</a></li>
</ul>
<p>다른 기본 연산들에 대한 규칙:</p>
<ul>
<li><a href="#Rc-eqdefault">C.80: 기본 의미구조(semantic)를 명시적으로 사용하려면 <code>=default</code>를 사용하라</a></li>
<li><a href="#Rc-delete">C.81: 기본 동작을 (대안을 원하지 않고) 금지하고 싶다면 <code>=delete</code>를 사용하라</a></li>
<li><a href="#Rc-ctor-virtual">C.82: 생성자 또는 소멸자에서 가상 함수를 호출하지 말아라</a></li>
<li><a href="#Rc-swap">C.83: 값 타입들에는, <code>noexcept</code> swap함수를 제공하는 것을 고려하라</a></li>
<li><a href="#Rc-swap-fail">C.84: <code>swap</code> 연산은 실패해선 안된다</a></li>
<li><a href="#Rc-swap-noexcept">C.85: <code>swap</code> 연산은 <code>noexcept</code>로 작성하라</a></li>
<li><a href="#Rc-eq">C.86: <code>==</code>연산자는 피연산자 타입들에 대칭적이고, <code>noexcept</code>로 만들어라</a></li>
<li><a href="#Rc-eq-base">C.87: 기본 클래스에 있는 <code>==</code>에 주의하라</a></li>
<li><a href="#Rc-hash">C.89: <code>hash</code>는 <code>noexcept</code>로 작성하라</a></li>
<li><a href="#Rc-memset">C.90: <code>memset</code> 또는 <code>memcpy</code>가 아닌, 생성자와 할당 연산자에 의존하라</a></li>
</ul>
<h2 id="cdefop-default-operations"><a name="SS-defop"></a>C.defop: 기본 연산들(Default Operations)</h2>
<p>C++ 에서는 기본적인 의미를 가진 연산들을 제공한다.
프로그래머는 이 연산들을 금지하거나 교체할 수 있다.</p>
<h3 id="c20"><a name="Rc-zero"></a>C.20: 기본 연산을 정의하지 않아도 되면 그렇게하라</h3>
<h5 id="reason_10">Reason</h5>
<p>가장 단순하고, 명료한 의미를 준다.</p>
<h5 id="example_9">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Named_map</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ... no default operations declared ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">rep</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Named_map</span> <span class="n">nm</span><span class="p">;</span>        <span class="c1">// default construct</span>
    <span class="n">Named_map</span> <span class="n">nm2</span> <span class="p">{</span><span class="n">nm</span><span class="p">};</span>  <span class="c1">// copy construct</span>
</pre></div>


<p><code>std::map</code> 과 <code>string</code> 은 모든 특수한 함수들을 갖고 있다, 추가로 코드를 작성할 필요가 없다.</p>
<h5 id="note_13">Note</h5>
<p>"The rule of zero"로 알려져 있다.</p>
<h5 id="enforcement_10">Enforcement</h5>
<p>(Not enforceable) 시행할 수 없더라도, 좋은 정적 분석기는 이 규칙에 맞는 가능한 개선사항들을 알려주는 패턴들을 찾을 수 있다.
예를 들면, 포인터와 크기를 멤버로 갖는 클래스가 있고 소멸자에서 그 포인터를 <code>delete</code> 한다면 아마도 <code>vector</code> 로 바꿀 수 있을 것이다.</p>
<h3 id="c21-delete-delete"><a name="Rc-five"></a>C.21: 기본 연산을 정의 하거나 <code>=delete</code> 로 선언했다면, 나머지 모두 정의하거나 <code>=delete</code>하라</h3>
<h5 id="reason_11">Reason</h5>
<p>이 <em>특별한 멤버 함수들</em>은 기본 생성자, 복사 생성자, 복사 대입 연산자, 이동 생성자, 이동 대입 연산자, 소멸자를 의미한다.</p>
<p>이들의 의미는 서로 밀접하게 연관되어 있다. 만약 한 함수가 기본 제공 함수가 아니어야 한다면(non-default), 다른 함수들도 수정이 필요하다.</p>
<p>기본 생성자를 제외하고 이 특별한 멤버 함수들 중 하나를 <code>=default</code> 혹은 <code>=delete</code>로 선언할 경우, 컴파일러가 이동 생성자와 이동 대입 연산자를 묵시적으로 선언하지 않는다.
이동 생성자 또는 이동 대입 연산자를 선언하는 경우, 복사 생성자와 복사 대입 연산자가 이를 따른다. 이동 연산이 <code>=default</code>로 선언된 경우 복사 연산이 자동으로 정의되며, 이동 연산이 <code>=delete</code>로 선언된 경우 복사 연산도 <code>=delete</code>가 적용된다.
따라서, 이 특별 함수들 중 하나라도 선언되었다면, 의도치 않은 복사와 이동연산을 피하기 위해 나머지 함수들도 선언되어야 한다.</p>
<h5 id="example-bad_2">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">M2</span> <span class="p">{</span>   <span class="c1">// bad: incomplete set of default operations</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="c1">// ... no copy or move operations ...</span>
        <span class="o">~</span><span class="n">M2</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">rep</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;*</span> <span class="n">rep</span><span class="p">;</span>  <span class="c1">// zero-terminated set of pairs</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">M2</span> <span class="n">x</span><span class="p">;</span>
        <span class="n">M2</span> <span class="n">y</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>   <span class="c1">// the default assignment</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>여기서는, 소멸자에 대한 "특별한 주의"가 필요하다고 한다면, 복사와 이동 할당(둘 다 묵시적으로 개체를 소멸할 것이다)이 정확하게 동작할 가능성은 적다. (여기서는, 두번 <code>delete</code>를 시도할 것이다)</p>
<h5 id="note_14">Note</h5>
<p>기본 생성자를 중요하게 생각하는지에 달려있는데, 이것은 "The rule of five" 혹은 "The rule of six" 이라고 알려져 있다.</p>
<h5 id="note_15">Note</h5>
<p>다른 것은 정의 하더라도 기본 연산의 기본 구현이 필요하다면, <code>=default</code> 을 사용하여 해당 함수에 대한 의도를 표현하라.
기본 연산을 원하지 않는다면, <code>=delete</code>를 써서 제한하라.</p>
<h5 id="example-good_1">Example, good</h5>
<p>단순히 <code>virtual</code>을 위해 소멸자가 선언되어야 한다면, <code>=default</code>를 사용해 정의할 수 있다. 
묵시적으로 이동 연산이 제한되는 것을 막고 싶다면 이동 연산들이 선언되어야 한다. 만약 이동 연산만 지원하는게 아니라면 (즉 복사가 가능해야 한다면) 복사 연산 역시 그에 맞게 선언해야 한다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">AbstractBase</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">AbstractBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="n">AbstractBase</span><span class="p">(</span><span class="k">const</span> <span class="n">AbstractBase</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="n">AbstractBase</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">AbstractBase</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="n">AbstractBase</span><span class="p">(</span><span class="n">AbstractBase</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="n">AbstractBase</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">AbstractBase</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p><a href="#Rc-copy-virtual">C.67</a>을 고려해서 복사 절단(slicing) 문제를 예방하기 위해 복사와 이동연산을 제한할 수도 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">ClonableBase</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
      <span class="k">virtual</span> <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ClonableBase</span><span class="o">&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
      <span class="k">virtual</span> <span class="o">~</span><span class="n">ClonableBase</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
      <span class="n">ClonableBase</span><span class="p">(</span><span class="k">const</span> <span class="n">ClonableBase</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
      <span class="n">ClonableBase</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">ClonableBase</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
      <span class="n">ClonableBase</span><span class="p">(</span><span class="n">ClonableBase</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
      <span class="n">ClonableBase</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">ClonableBase</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>복사를 지원하지 않는다면 이동 연산들을 <code>=delete</code>로 정의하거나 복사연산을 <code>=delete</code>하는 경우 모두 같은 효과를 가진다. 하지만 타입의 의도를 분명히 전달하기 위해서는 모든 특별 함수들을 정의하는 것이 좋다.</p>
<h5 id="note_16">Note</h5>
<p>컴파일러는 이 규칙을 강제하고, 이상적으로는 위반사항이 발생하면 경고한다.</p>
<h5 id="note_17">Note</h5>
<p>클래스에 묵시적으로 생성된 복사 연산에 의존하는 것은 더 이상 사용되지 않는다.</p>
<h5 id="note_18">Note</h5>
<p>여섯개의 특별 함수들을 모두 작성하는 것은 오류에 취약할 수 있다. 아래 예시의 인자 타입에 주목하라:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>            <span class="c1">// destructor (virtual if X is meant to be a base class)</span>
        <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>             <span class="c1">// copy constructor</span>
        <span class="n">X</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>  <span class="c1">// copy assignment</span>
        <span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>                  <span class="c1">// move constructor</span>
        <span class="n">X</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>       <span class="c1">// move assignment</span>
    <span class="p">};</span>
</pre></div>


<p>스펠링을 잘못 적거나, <code>const</code>를 빠뜨리거나, <code>&amp;&amp;</code>대신 <code>&amp;</code>을 사용하거나, 하나를 빠뜨리는 것 같은 사소한 실수가 오류나 경고로 이어질 수 있다.
이런 (지루한 코드로 인해 발생하는) 오류를 피하고자 한다면 <a href="#Rc-zero">The rule of zero</a>를 따르는 것을 권한다.</p>
<h5 id="enforcement_11">Enforcement</h5>
<p>(쉬움) 클래스는 특별한 함수들에 대한 선언(<code>=delete</code>도 포함하여)을 모두 갖거나 하나도 없어야 한다.</p>
<h3 id="c22"><a name="Rc-matched"></a>C.22: 기본 연산들은 서로 조화롭게 동작해야 한다</h3>
<h5 id="reason_12">Reason</h5>
<p>기본 연산들은 개념적으로 잘 짜여진 집합이다. 연산들의 의미는 서로 연관되어 있다.
사용자는 복사/이동 생성과 복사/이동 할당이 논리적으로 동일하고, 생성자와 소멸자가 리소스 관리에 대해 일관적으로 동작하며, 복사와 이동이 생성자와 소멸자가 동작하는 방식을 반영한다는 것을 기대 할 것이다. 만약 복사와 이동이 생성과 소멸에 영향을 주지 않는다면 사용자에게 혼란을 줄 것이다.</p>
<h5 id="example-bad_3">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Silly</span> <span class="p">{</span>   <span class="c1">// BAD: Inconsistent copy operations</span>
        <span class="k">class</span> <span class="nc">Impl</span> <span class="p">{</span>
            <span class="c1">// ...</span>
        <span class="p">};</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Impl</span><span class="o">&gt;</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Silly</span><span class="p">(</span><span class="k">const</span> <span class="n">Silly</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">p</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">}</span> <span class="p">{</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="o">*</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// deep copy</span>
        <span class="n">Silly</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Silly</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// shallow copy</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>이 연산들은 복사 연산에 대한 의미가 일치하지 않는다. 이런 동작은 혼란을 야기하고 버그를 만들 것이다.</p>
<h5 id="enforcement_12">Enforcement</h5>
<ul>
<li>(어려움) 복사/이동 생성자와 이에 대응하는 복사/이동 할당 연산자는 동일한 레벨에서 동일한 멤버 변수를 변경하는 것이 좋다</li>
<li>(어려움) 복사/이동 생성자에서 변경하는 멤버 변수들은 다른 생성자들에서도 초기화 하는 것이 좋다</li>
<li>(어려움) 복사/이동 생성자는 멤버 변수에 대해 깊은 복사를 수행하고 나서, 소멸자는 멤버 변수를 수정해야 한다</li>
<li>(어려움) 소멸자가 멤버 변수를 변경하면, 그 멤버 변수들은 복사/이동 생성자 혹은 할당 연산자에서 쓰여지는 것이 좋다</li>
</ul>
<h2 id="cdtor"><a name="SS-dtor"></a>C.dtor: 소멸자</h2>
<p>"이 클래스에 소멸자가 필요할까?"라는 것은 설계 측면에서 굉장히 강력한 질문이다.
대부분의 클래스들에 대해서 대답은 "no"인데, 그 이유는 해당 클래스가 자원들을 가지고 있지 않거나 소멸과정이 <a href="#Rc-zero">The rule of zero</a>에 의해 처리되기 때문이다.</p>
<p>요컨대, 클래스의 멤버들이 스스로의 소멸을 관리한다는 것이다.
만약 대답이 "yes"라면, 그 클래스 설계의 대부분은 <a href="#Rc-five">The rule of five</a>를 따르게 된다.</p>
<h3 id="c30"><a name="Rc-dtor"></a>C.30: 개체가 없어질 때, 명시적인 동작이 필요할 경우 소멸자를 정의하라</h3>
<h5 id="reason_13">Reason</h5>
<p>소멸자는 암묵적으로 개체의 생명주기의 마지막에 호출된다.
기본 소멸자로 충분하다면 그것을 사용하라.
단순하게 멤버의 소멸자를 호출하는 것이 아닌 코드가 필요할 경우 소멸자를 정의하라.</p>
<h5 id="example_10">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="n">final_action</span> <span class="p">{</span>   <span class="c1">// slightly simplified</span>
        <span class="n">A</span> <span class="n">act</span><span class="p">;</span>
        <span class="n">final_action</span><span class="p">(</span><span class="n">A</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span><span class="n">act</span><span class="p">{</span><span class="n">a</span><span class="p">}</span> <span class="p">{}</span>
        <span class="o">~</span><span class="n">final_action</span><span class="p">()</span> <span class="p">{</span> <span class="n">act</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">A</span><span class="o">&gt;</span>
    <span class="n">final_action</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span> <span class="n">finally</span><span class="p">(</span><span class="n">A</span> <span class="n">act</span><span class="p">)</span>   <span class="c1">// deduce action type</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">final_action</span><span class="o">&lt;</span><span class="n">A</span><span class="o">&gt;</span><span class="p">{</span><span class="n">act</span><span class="p">};</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">test</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">act</span> <span class="o">=</span> <span class="n">finally</span><span class="p">([]{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Exit test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span> <span class="p">});</span>  <span class="c1">// establish exit action</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">something</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>   <span class="c1">// act done here</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="c1">// act done here</span>
</pre></div>


<p><code>final_action</code> 의 목적은 소멸할 때 실행할 코드(보통 람다 표현식을 쓴다)를 얻는 것이다.</p>
<h5 id="note_19">Note</h5>
<p>사용자 정의 소멸자가 필요한 클래스에는 보통 두 종류가 있다:</p>
<ul>
<li>리소스를 사용하는 클래스가 소멸자가 없는 경우, 예컨대 <code>vector</code> 혹은 트랜잭션 코드</li>
<li>트레이싱이나 <code>final_action</code>처럼 소멸시기에 어떤 동작을 발생시키기 위한 클래스</li>
</ul>
<h5 id="example-bad_4">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>   <span class="c1">// bad; use the default destructor</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="o">~</span><span class="n">Foo</span><span class="p">()</span> <span class="p">{</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">vi</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span> <span class="p">}</span>  <span class="c1">// clean up</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vi</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>기본 소멸자가 더 잘 동작하고, 더 효과적이며, 틀리지 않는다.</p>
<h5 id="note_20">Note</h5>
<p>기본 소멸자가 필요하지만, 생성되지 않도록 되어 있다면 (예, 이동 생성자를 정의한 경우), <code>=default</code> 를 사용하라.</p>
<h5 id="enforcement_13">Enforcement</h5>
<p>포인터나 참조와 같은 "암묵적인 자원"이 될 수 있는 것들을 찾아보라. 
모든 데이터 멤버가 소멸자를 갖고 있더라도, 사용자 지정 소멸자가 있는 클래스들을 찾아보라.</p>
<h3 id="c31"><a name="Rc-dtor-release"></a>C.31: 클래스가 획득한 모든 자원은 소멸자에서 해제되어야 한다</h3>
<h5 id="reason_14">Reason</h5>
<p>리소스 누수를 막는다, 특히 오류가 발생한 상황에서 그렇다.</p>
<h5 id="note_21">Note</h5>
<p>클래스로 표현되는 리소스들이 기본 연산 집합을 갖고 있을 때 소멸자에서의 리소스 해제가 자동으로 발생한다.</p>
<h5 id="example_11">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
        <span class="n">ifstream</span> <span class="n">f</span><span class="p">;</span>   <span class="c1">// may own a file</span>
        <span class="c1">// ... no default operations defined or =deleted ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>X</code>의 <code>ifstream</code> 은 <code>X</code>가 소멸될 때 묵시적으로 열었을 수 있는 파일을 닫는다.  </p>
<h5 id="example-bad_5">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X2</span> <span class="p">{</span>     <span class="c1">// bad</span>
        <span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span><span class="p">;</span>   <span class="c1">// may own a file</span>
        <span class="c1">// ... no default operations defined or =deleted ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>X2</code> 에서는 파일 핸들 누수가 생길 것이다.  </p>
<h5 id="note_22">Note</h5>
<p>닫지 않은 소켓은 어떨까? 소멸자, 닫기, 정리 연산은 <a href="#Rc-dtor-fail">실패하지 않는 것이 좋다</a>.
그럼에도 불구하고 발생한다면, 좋은 해결책을 찾기 정말 힘든 문제를 마주친 것이다.
초심자들은 소멸자를 작성할 때 왜 소멸자가 호출되고, 예외를 던짐으로써 "처리를 거부"를 할 수 없는지 알지 못할 것이다. 이에 대해서는 <a href="./appendix/Discussion.md#Sd-never-fail">소멸자는 실패해선 안된다(토론)</a>를 참고하라.</p>
<p>문제를 악화시키는 것은, 많은 "닫기/해제" 연산들이 재시도 할 수 없도록 되어있는 것이다.
이 문제를 풀려는 시도는 많았지만, 일반적인 해결책은 알려지지 않았다.
해결책이 없다면, 닫기/해제에 대한 실패를 디자인 오류로 간주하고 종료시키는 것을 고려해 보라.</p>
<h5 id="note_23">Note</h5>
<p>클래스가 소유하고 있지 않은 개체에 대한 포인터나 참조를 갖고 있을 수 있다.
당연하지만, 이 개체들은 클래스의 소멸자에서 <code>delete</code>되지 않아야 한다.
예를 들면:</p>
<div class="codehilite"><pre><span></span>    <span class="n">Preprocessor</span> <span class="n">pp</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
    <span class="n">Parser</span> <span class="n">p</span> <span class="p">{</span> <span class="n">pp</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">};</span>
    <span class="n">Type_checker</span> <span class="n">tc</span> <span class="p">{</span> <span class="n">p</span><span class="p">,</span> <span class="cm">/* ... */</span> <span class="p">};</span>
</pre></div>


<p><code>p</code>는 <code>pp</code>를 참조하지만, 소유하고 있지 않다.</p>
<h5 id="enforcement_14">Enforcement</h5>
<ul>
<li>(쉬움) 클래스가 소유자인 포인터나 참조 멤버 변수를 갖고 있다면 (가령, <code>gsl::owner</code>를 사용하여 소유하는 경우), 소멸자에서 참조되는 것이 좋다</li>
<li>(어려움) 소유권에 대해 명시적으로 기술하지 않은 경우, 포인터나 참조 멤버 변수들이 소유자 인지 판단하라 (예, 생성자 본문을 확인한다).</li>
</ul>
<h3 id="c32-t-tamp"><a name="Rc-dtor-ptr"></a>C.32: 클래스가 포인터(<code>T*</code>)나 참조(<code>T&amp;</code>)를 가지고 있다면, 참조 대상을 소유하고 있는지를 고려하라</h3>
<h5 id="reason_15">Reason</h5>
<p>소유권에 대해서 상세하지 않은 코드는 많이 있다.</p>
<h5 id="example_12">Example</h5>
<div class="codehilite"><pre><span></span>    ???
</pre></div>


<h5 id="note_24">Note</h5>
<p><code>T*</code> 혹은 <code>T&amp;</code> 가 소유를 의미한다면, <strong>소유한다는</strong> 표시를 하라. <code>T*</code> 에 소유의 의미가 없다면 <code>ptr</code> 로 표시하는 것을 고려하라.
이것은 문서화와 분석에 도움이 될 것이다.</p>
<h5 id="enforcement_15">Enforcement</h5>
<p>포인터나 참조를 초기화 할 때 자원할당이 발생하는지 확인하라.</p>
<h3 id="c33"><a name="Rc-dtor-ptr2"></a>C.33: 클래스가 포인터로 대상을 소유하고 있다면, 소멸자를 정의하라</h3>
<h5 id="reason_16">Reason</h5>
<p>소유된 개체는 그것을 소유한 개체가 소멸될 때 <code>delete</code>되어야 한다.</p>
<h5 id="example_13">Example</h5>
<p>포인터 멤버는 리소스일 것이다. <a href="../Resource/#Rr-ptr"><code>T*</code>는 리소스가 아니어야 한다</a>, 이는 오래된 코드에서는 일반적이다.
가능한 <code>T*</code>를 소유자라고 고려하고, 의심해보라.</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Smart_ptr</span> <span class="p">{</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// BAD: *p 의 소유가 불분명하다</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ... 사용자가 복사 연산을 정의하지 않았다 ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="n">Smart_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// error: p2.p 에 누수가 발생한다. (nullptr가 아니거나 다른 코드에서 소유하지 않는다면)</span>
        <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>소멸자를 정의 한다면, <a href="#Rc-five">모든 기본 연산들</a>을 정의하거나 삭제해야 한다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Smart_ptr2</span> <span class="p">{</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>   <span class="c1">// BAD: *p 의 소유가 불분명하다</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ... 사용자가 복사 연산을 정의하지 않았다 ...</span>
        <span class="o">~</span><span class="n">Smart_ptr2</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// p 가 자원을 소유하고 있었다!</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="n">Smart_ptr2</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>    <span class="c1">// error: delete가 2번 호출된다.</span>
    <span class="p">}</span>
</pre></div>


<p>기본 복사 연산은 단지 <code>p1.p</code> 를 <code>p2.p</code> 로 복사하고, <code>p1.p</code> 가 두번 소멸되게 만들 것이다. 소유권을 명시하라:</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Smart_ptr3</span> <span class="p">{</span>
        <span class="n">owner</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">p</span><span class="p">;</span>  <span class="c1">// OK: 명시적으로 *p 의 소유권을 가진다. </span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="c1">// ... 복사와 이동 연산들 ...</span>
        <span class="o">~</span><span class="n">Smart_ptr3</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="n">Smart_ptr3</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">p1</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">p1</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_25">Note</h5>
<p>보통 소멸자를 사용하는 가장 단순한 방법은 포인터를 스마트 포인터(가령, <code>std::unique_ptr</code>)로 교체하고, 컴파일러가
적절한 소멸자를 암묵적으로 호출하게 만들도록 놔두는 것이다.</p>
<h5 id="note_26">Note</h5>
<p>소유하고 있는 모든 포인터를 "스마트 포인터"로 변경하는 것은 어떤가?
드물게는 중대한 코드 변경이 필요해지고 ABI 에 영향을 줄 수도 있다.</p>
<h5 id="enforcement_16">Enforcement</h5>
<ul>
<li>포인터 데이터 멤버를 갖는 클래스를 의심하라</li>
<li><code>owner&lt;T&gt;</code> 를 갖는 클래스는 기본 연산들을 정의 해야한다</li>
</ul>
<h3 id="c35-"><a name="Rc-dtor-virtual"></a>C.35: 상위 클래스의 소멸자는 공개된 가상 소멸자 혹은 상속되는 비-가상 함수여야 한다</h3>
<h5 id="reason_17">Reason</h5>
<p>미정의 동작(undefined behavior)을 막기 위한 규칙이다.</p>
<p>만약 소멸자가 <code>public</code> 이면, 호출하는 코드는 파생 클래스가 기본 클래스의 포인터를 통해 소멸될 것이라 생각한다. 그리고 기본 클래스의 소멸자가 <code>virtual</code>이 아니면 결과는 미정의 동작으로 이어진다.</p>
<p>만약 소멸자가 <code>protected</code>라면, 호출하는 코드는 기본 클래스의 포인터를 통해서 소멸시킬 수 없고, 따라서 소멸자는 <code>virtual</code>이 아니어도 문제가 없다. <code>private</code>가 아닌 <code>protected</code>여야 하는 이유는 파생 클래스의 소멸자가 호출할 수 있어야 하기 때문이다.</p>
<p>일반적으로, 기본 클래스의 작성자는 소멸 과정에서 어떤 동작이 적합한지 알 수 없다.  </p>
<h5 id="discussion">Discussion</h5>
<p><a href="./appendix/Discussion.md#Sd-dtor">토론</a>을 함께 읽어보라.</p>
<h5 id="example-bad_6">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Base</span> <span class="p">{</span>  <span class="c1">// BAD: virtual 소멸자가 없다</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">Base</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span> <span class="p">{</span><span class="s">&quot;a resource needing cleanup&quot;</span><span class="p">};</span>
        <span class="o">~</span><span class="n">D</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... 정리 작업을 한다 ... */</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Base</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
    <span class="c1">// p 의 소멸은 ~Base()를 호출하지만, ~D() 는 호출하지 않는다.</span>
    <span class="c1">// 따라서 D::s 에 누수가 발생하고, 다른 자원들도 누수될 것이다.</span>
</pre></div>


<h5 id="note_27">Note</h5>
<p>가상(<code>virtual</code>) 함수는 파생 클래스에 대한 인터페이스를 제공한다. 이 인터페이스를 통해 파생 클래스에 대해 신경을 쓰지 않게 된다. <br />
만약 인터페이스가 소멸을 지원한다면, 그 과정은 안전해야만 한다.</p>
<h5 id="note_28">Note</h5>
<p>소멸자는 private이 아니어야 한다. 만약 그럴 경우 해당 타입을 사용하지 못하게 될 것이다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
        <span class="o">~</span><span class="n">X</span><span class="p">();</span>   <span class="c1">// private 소멸자</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="n">a</span><span class="p">;</span>                        <span class="c1">// error: 소멸시킬 수 없다</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">X</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// error: 소멸시킬 수 없다</span>
    <span class="p">}</span>
</pre></div>


<h5 id="exception_3">Exception</h5>
<p>protected virtual 소멸자를 원하지 않는 경우를 상상해볼 수 있다. 파생 타입의 개체가 기본 타입 포인터를 통해 (그 자신이 아닌) <em>다른</em> 개체의 소멸을 하도록 허용해야 하는 경우가 그러하다. 하지만 아직까지 그런 사례를 볼 수 없었다.</p>
<h5 id="enforcement_17">Enforcement</h5>
<ul>
<li>가상 함수를 하나라도 가지는 클래스는 <code>public</code> 하고 <code>virtual</code>한 소멸자를 가져야 한다. 또는 <code>protected</code>이고 <code>virtual</code>이 아닌 소멸자를 가져야 한다.</li>
</ul>
<h3 id="c36"><a name="Rc-dtor-fail"></a>C.36: 소멸자는 실패해선 안된다</h3>
<h5 id="reason_18">Reason</h5>
<p>일반적으로 소멸자가 실패할 때 오류 없는 코드를 작성하는 방법을 알 수 없다.
표준 라이브러리에서 다루는 모든 클래스들은 예외를 던지지 않는 소멸자를 요구한다.</p>
<h5 id="example_14">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">X</span><span class="o">::~</span><span class="n">X</span><span class="p">()</span> <span class="k">noexcept</span>
    <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">cannot_release_a_resource</span><span class="p">)</span> <span class="n">terminate</span><span class="p">();</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_29">Note</h5>
<p>소멸자에서의 실패를 다루기 위해 실패할 염려가 없는 방법(scheme)을 많이 고안해 왔다. 이에 대해선 일반적인 방법으로 성공한 예가 없다.</p>
<p>이것은 정말 현실적인 문제가 될 수 있다: 예를 들면, 닫지 않은 소켓은 어떤가?<br />
소멸자를 작성하는 사람은 왜 소멸자가 호출되고 예외를 던짐으로써 "동작을 거부하는 것"을 할 수 없는지 모른다.</p>
<p><a href="./appendix/Discussion.md#Sd-dtor">토론</a>을 함께보라.
문제를 악화시키는 것은, 많은 "close/release" 연산이 재시도할 수 없게 되어있는 것이다.
가능하다면, close/failure에 대한 실패를 근본적인 디자인 오류로 간주하고 종료시켜라.</p>
<h5 id="note_30">Note</h5>
<p>소멸자를 <code>noexcept</code>로 선언하라. 이것은 소멸자가 정상적으로 완료했거나 프로그램을 종료한다는 것을 보장한다.</p>
<h5 id="note_31">Note</h5>
<p>만약 자원이 해제될 수 없고 프로그램이 실패하지 않는다면, 어떤 방법으로든 시스템의 나머지 부분에서 실패 했다는 신호를 보내도록 하라.
(전역 상태 변수를 수정하고 프로그램의 다른 부분이 그것을 확인하고 아마도 문제를 처리할 수 있을 것이다)</p>
<p>이 방식은 특별한 목적이 있고, 오류가 발생하기 쉽다는 것을 충분히 이해하라.</p>
<p>예시로 "닫히지 않는 연결"을 고려해보자.
어쩌면 연결의 반대편에 문제가 있을 수 있고, 이때 양쪽의 연결을 담당하는 코드만이 문제를 처리할 수 있다.
소멸자가 (어떤 방법으로) 시스템의 담당(responsible) 부분에 메세지를 보내고, 연결이 닫힌 것으로 간주한 뒤, 정상적으로 반환할 수도 있다.</p>
<h5 id="note_32">Note</h5>
<p>소멸자가 실패할 수도 있는 연산을 사용한다면, 예외를 잡을 수 있고, 어떤 경우에는 성공적으로 완료할 수 있다.
(가령, 예외를 던진 메커니즘과는 다른 정리(clean-up) 메커니즘을 사용하는 것이다)</p>
<h5 id="enforcement_18">Enforcement</h5>
<p>(쉬움) 만약 예외 발생이 가능하면, 소멸자는 <code>noexcept</code>로 선언되어야 한다</p>
<h3 id="c37-noexcept"><a name="Rc-dtor-noexcept"></a>C.37: 소멸자를 <code>noexcept</code>로 작성하라</h3>
<h5 id="reason_19">Reason</h5>
<p><a href="#Rc-dtor-fail">소멸자는 실패해선 안된다</a>.<br />
만약 소멸자가 예외로 인해 종료되려고 한다면, 좋지 않은 디자인 오류로 보고 종료하는 편이 나을 것이다.</p>
<h5 id="note_33">Note</h5>
<p>사용자가 정의하였건 컴파일러가 생성하였건 모든 멤버 변수들의 소멸자가 <code>noexcept</code>라면 소멸자는 암묵적으로 <code>noexcept</code>가 된다 (함수의 코드가 어떻게 작성되었는지는 고려되지 않는다).
명시적으로 소멸자를 <code>noexcept</code>로 표기함으로써, 그 코드의 작성자는 나중에 멤버가 추가되거나 변경되면서 소멸자가 <code>noexcept(false)</code>로 변하는 것을 차단할 수 있다.</p>
<h5 id="example_15">Example</h5>
<p>모든 소멸자가 <code>noexcept</code>를 기본으로 하지는 않는다; 예외를 던지는 하나의 멤버가 모든 클래스 계층구조에 영향을 줄 수 있다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
        <span class="n">Details</span> <span class="n">x</span><span class="p">;</span>  <span class="c1">// happens to have a throwing destructor</span>
        <span class="c1">// ...</span>
        <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>    <span class="c1">// implicitly noexcept(false); aka can throw</span>
    <span class="p">};</span>
</pre></div>


<p>만약 의심이 생긴다면, 소멸자는 <code>noexcept</code>로 선언하라.</p>
<h5 id="note_34">Note</h5>
<p>소멸자를 <code>noexcept</code>로 선언하지 않을 이유가 없다. <code>noexcept(false)</code>는 많은 경우 -- 특히 단순한 코드에서 -- 혼란을 발생시킨다.</p>
<h5 id="enforcement_19">Enforcement</h5>
<p>(쉬움) 소멸자는 <code>noexcept</code>로 선언되어야 한다.</p>
<h2 id="cctor_1"><a name="SS-ctor"></a>C.ctor: 생성자</h2>
<p>생성자는 개체가 생성되는(초기화되는) 방법을 정의 한다.</p>
<h3 id="c40"><a name="Rc-ctor"></a>C.40: 클래스가 불변조건을 가진다면 생성자를 정의하라</h3>
<h5 id="reason_20">Reason</h5>
<p>생성자가 존재하는 이유다.</p>
<h5 id="example_16">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>  <span class="c1">// Date 클래스는 유효한 날짜를 표현한다</span>
                  <span class="c1">// 범위 : 1900년 1월 1일 ~ 2100년 12월 31일</span>
        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yy</span><span class="p">)</span>
            <span class="o">:</span><span class="n">d</span><span class="p">{</span><span class="n">dd</span><span class="p">},</span> <span class="n">m</span><span class="p">{</span><span class="n">mm</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">yy</span><span class="p">}</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">is_valid</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span>
                <span class="k">throw</span> <span class="n">Bad_date</span><span class="p">{};</span>  <span class="c1">// 불변조건을 강제한다</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>생성자에서 <code>Ensures</code>로 불변조건을 표현하는 것도 좋은 생각이다.</p>
<h5 id="note_35">Note</h5>
<p>생성자는 클래스가 불변조건이 아니더라도 편의를 위해 사용될 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Rec</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="n">Rec</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ss</span><span class="p">)</span> <span class="o">:</span> <span class="n">s</span><span class="p">{</span><span class="n">ss</span><span class="p">}</span> <span class="p">{}</span>
        <span class="n">Rec</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">)</span> <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">}</span> <span class="p">{}</span>
    <span class="p">};</span>

    <span class="n">Rec</span> <span class="n">r1</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>
    <span class="n">Rec</span> <span class="n">r2</span> <span class="p">{</span><span class="s">&quot;Foo bar&quot;</span><span class="p">};</span>
</pre></div>


<h5 id="note_36">Note</h5>
<p>C++11 초기화 리스트 규칙은 많은 생성자의 필요성을 제거한다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Rec2</span><span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">Rec2</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ss</span><span class="p">,</span> <span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">:</span><span class="n">s</span><span class="p">{</span><span class="n">ss</span><span class="p">},</span> <span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">}</span> <span class="p">{}</span>   <span class="c1">// redundant</span>
    <span class="p">};</span>

    <span class="n">Rec2</span> <span class="n">r1</span> <span class="p">{</span><span class="s">&quot;Foo&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
    <span class="n">Rec2</span> <span class="n">r2</span> <span class="p">{</span><span class="s">&quot;Bar&quot;</span><span class="p">};</span>
</pre></div>


<p><code>Rec2</code> 생성자는 중복적이다. 그리고, <code>int</code>에 대한 기본값은 <a href="#Rc-in-class-initializer">member initializer</a>를 사용하는 편이 낫다.</p>
<h5 id="see-also_1">See also:</h5>
<ul>
<li><a href="#Rc-complete">유효한 개체를 생성하라</a></li>
<li><a href="#Rc-throw">생성자가 던지는 예외</a></li>
</ul>
<h5 id="enforcement_20">Enforcement</h5>
<ul>
<li>사용자 정의 복사 연산이 있지만 소멸자가 없는 클래스를 지적한다 (사용자 정의 복사는 클래스가 불변조건을 가진다는 것을 알려준다)</li>
</ul>
<h3 id="c41"><a name="Rc-complete"></a>C.41: 생성자는 완전히 초기화된 개체를 생성해야 한다</h3>
<h5 id="reason_21">Reason</h5>
<p>생성자는 클래스에 대한 불변조건을 설정한다. 클래스 사용자는 생성된 개체가 사용가능하다는 것을 가정할 수 있어야 한다.</p>
<h5 id="example-bad_7">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X1</span> <span class="p">{</span>
        <span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span><span class="p">;</span>   <span class="c1">// 다른 함수에 앞서 init()을 호출한다</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X1</span><span class="p">()</span> <span class="p">{}</span>
        <span class="kt">void</span> <span class="n">init</span><span class="p">();</span>   <span class="c1">// 멤버 f 초기화</span>
        <span class="kt">void</span> <span class="nf">read</span><span class="p">();</span>   <span class="c1">// 멤버 f 로부터 읽는다</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X1</span> <span class="n">file</span><span class="p">;</span>
        <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>   <span class="c1">// crash 또는 bad read 가 발생한다.</span>
        <span class="c1">// ...</span>
        <span class="n">file</span><span class="p">.</span><span class="n">init</span><span class="p">();</span>   <span class="c1">// 초기화 하기엔 너무 늦었다</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>컴파일러는 주석을 읽지 않는다.</p>
<h5 id="exception_4">Exception</h5>
<p>생성자만으로 유효한 개체를 쉽게 만들 수 없다면 <a href="#Rc-factory">팩토리 함수를 사용하라</a></p>
<h5 id="enforcement_21">Enforcement</h5>
<ul>
<li>(단순) 모든 생성자는 해당 클래스의 모든 멤버변수들을 초기화해야 한다 (명시적인 생성자 위임 혹은 기본 생성을 통해서)</li>
<li>(불분명함) 만약 생성자가 <code>Ensures</code> 계약을 가지고 있다면, 생성 후 조건이 존재하는지 확인하라</li>
</ul>
<h5 id="note_37">Note</h5>
<p>생성자가 유효한 개체를 만들기 위해 자원을 얻는다면, 리소스는 <a href="#Rc-dtor-release">소멸자에 의해 해제</a>되어야 한다.
생성자에서 자원을 얻고 소멸자에서 자원을 해제하는 것을 <a href="../Resource/#Rr-raii">RAII</a> ("Resource Acquisitions Is Initialization") 라고 한다.</p>
<h3 id="c42"><a name="Rc-throw"></a>C.42: 생성자가 유효한 개체를 생성하지 못한다면, 예외를 던지도록 하라</h3>
<h5 id="reason_22">Reason</h5>
<p>유효하지 않은 개체를 남겨두는 것은 문제를 일으킬 것이다.</p>
<h5 id="example_17">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X2</span> <span class="p">{</span>
        <span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X2</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
            <span class="o">:</span><span class="n">f</span><span class="p">{</span><span class="n">fopen</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="s">&quot;r&quot;</span><span class="p">)}</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">f</span><span class="p">)</span> <span class="k">throw</span> <span class="n">runtime_error</span><span class="p">{</span><span class="s">&quot;could not open&quot;</span> <span class="o">+</span> <span class="n">name</span><span class="p">};</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>

        <span class="kt">void</span> <span class="n">read</span><span class="p">();</span>      <span class="c1">// 멤버 f 로부터 읽는다</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X2</span> <span class="n">file</span> <span class="p">{</span><span class="s">&quot;Zeno&quot;</span><span class="p">};</span> <span class="c1">// file이 열려있지 않으면 예외를 던진다</span>
        <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>      <span class="c1">// 문제 없다</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example-bad_8">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X3</span> <span class="p">{</span>     <span class="c1">// bad: 생성자가 유효하지 않은 개체를 남겨놓을 수 있다</span>
        <span class="kt">FILE</span><span class="o">*</span> <span class="n">f</span><span class="p">;</span>   <span class="c1">// call is_valid() before any other function</span>
        <span class="kt">bool</span> <span class="n">valid</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X3</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">name</span><span class="p">)</span>
            <span class="o">:</span><span class="n">f</span><span class="p">{</span><span class="n">fopen</span><span class="p">(</span><span class="n">name</span><span class="p">.</span><span class="n">c_str</span><span class="p">(),</span> <span class="s">&quot;r&quot;</span><span class="p">)},</span> <span class="n">valid</span><span class="p">{</span><span class="nb">false</span><span class="p">}</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f</span><span class="p">)</span> <span class="n">valid</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>

        <span class="kt">bool</span> <span class="n">is_valid</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">valid</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">read</span><span class="p">();</span>   <span class="c1">// 멤버 f 로부터 읽는다</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X3</span> <span class="n">file</span> <span class="p">{</span><span class="s">&quot;Heraclides&quot;</span><span class="p">};</span>
        <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>   <span class="c1">// crash 또는 bad read가 발생한다!</span>
        <span class="c1">// ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">file</span><span class="p">.</span><span class="n">is_valid</span><span class="p">())</span> <span class="p">{</span>
            <span class="n">file</span><span class="p">.</span><span class="n">read</span><span class="p">();</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ... 오류를 처리한다 ...</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_38">Note</h5>
<p>변수를 정의할 때는 (가령, 스택에 혹은 다른 개체의 멤버로써) 오류코드가 리턴되는 명시적인 함수 호출은 없다.
유효하지 않은 개체를 남겨두고 사용하기 전에 지속적으로 <code>is_valid()</code> 함수를 호출해야 하는 것은 번거롭고, 오류가 발생하기 쉬우며, 비효율적 이다.</p>
<h5 id="exception_5">Exception</h5>
<p>(추가적인 툴 지원 없이) 예외 처리가 예측 가능한 시간 내로 수행되어야 하는 실시간 시스템(비행기 제어를 생각해 보라)과 같은 분야도 있다.</p>
<p>이런 경우엔 <code>is_valid()</code> 와 같은 방법이 반드시 사용되어야 한다. 이와 같은 경우 <a href="../Resource/#Rr-raii">RAII</a>처럼 동작하도록 하기 위해 지속적으로 <code>is_valid()</code> 로 확인하라.</p>
<h5 id="alternative">Alternative</h5>
<p>"생성자 이후 초기화" 혹은 "두 단계 초기화"를 사용해야 할 것 같다면, 그렇게 하지 않도록 해보라. 정말로 그렇게 해야 한다면 <a href="#Rc-factory">팩토리 함수</a>를 검토하라.</p>
<h5 id="note_39">Note</h5>
<p>사람들이 생성자에서 초기화를 수행하지 않고 <code>init()</code>함수를 사용해온 이유 중 하나는 코드의 중복을 막기 위함이었다.
<a href="#Rc-delegating">대리 생성자</a>와 <a href="#Rc-in-class-initializer">기본 멤버 초기화</a>가 이런 작업을 더 잘 해낼 수 있다.</p>
<p>또 다른 이유로는 개체가 필요할 때까지 초기화를 지연시키는 것이다; 이러한 해법은 보통 <a href="../Expr/#Res-init">변수가 적절하게 초기화되기 전까지는 해당 변수를 선언하지 않는 것이다</a>.</p>
<h5 id="enforcement_22">Enforcement</h5>
<p>???</p>
<h3 id="c43"><a name="Rc-default0"></a>C.43: 복사 가능한 클래스(값 타입)는 반드시 기본 생성자를 갖도록 하라</h3>
<h5 id="reason_23">Reason</h5>
<p>많은 언어나 라이브러리들이 기본 생성자에 의존하고 있다.<br />
예를 들면, <code>T a[10]</code> 나 <code>std::vector&lt;T&gt; v(10)</code> 는 기본 생성자들이 각 요소를 초기화 한다.
기본 생성자는 보통 복사 가능한 타입이 적합한 이동 된 상태를 정의하기 쉽도록 한다.</p>
<h5 id="note_40">Note</h5>
<p><a href="#SS-concrete">값 타입</a>은 복사 가능한 타입을 의미한다 (많은 경우 보통 비교 가능하다).
<a href="http://elementsofprogramming.com/">EoP</a>와 <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2012/n3351.pdf">The Palo Alto TR</a>에서 나온 정규 타입 개념과 밀접한 관련이 있다.</p>
<h5 id="example_18">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span> <span class="c1">// BAD: 기본 생성자가 없다</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yyyy</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Date</span><span class="o">&gt;</span> <span class="n">vd1</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>   <span class="c1">// Date의 기본 값이 필요하다</span>
    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Date</span><span class="o">&gt;</span> <span class="n">vd2</span><span class="p">(</span><span class="mi">1000</span><span class="p">,</span> <span class="n">Date</span><span class="p">{</span><span class="n">Month</span><span class="o">::</span><span class="n">October</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">1885</span><span class="p">});</span>   <span class="c1">// 대안</span>
</pre></div>


<p>기본 생성자는 다른 사용자 정의 생성자가 없을 때만 자동으로 생성된다. 때문에 이런 코드와 같은 경우엔 <code>vd1</code>을 초기화 하는 것은 불가능하다.
기본값이 없다는 것은 사용자에게는 날벼락 같은 상황일 수 있으며 타입의 사용을 어렵게 한다. 때문에 하나라도 의미있게 정의할 수 있다면, 정의되어야 한다.</p>
<p><code>Date</code>를 바탕으로 생각해보자:<br />
"자연적인" 기본 날짜라는 것은 존재하지 않는다 (빅뱅은 대부분의 사람들에게 너무 오래 전 이야기다). 그러니 이 예시는 사소한 고민은 아니라고 할 수 있다.
<code>{0, 0, 0}</code>는 대부분의 달력 체계에서 유효한 날짜가 아니다. 때문에 이 값을 사용하는 것은 부동 소수점에서 <code>NaN</code>을 사용하는 것과 같다.
하지만, 대부분의 현실적인 <code>Date</code> 클래스는 "첫째 날" (가령. 1970년 1월 1일이 많이 쓰인다)을 갖기 때문에 이것을 기본으로 사용하는 것이 일반적이다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">dd</span><span class="p">,</span> <span class="kt">int</span> <span class="n">mm</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yyyy</span><span class="p">);</span>
        <span class="n">Date</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// [C.45: 멤버를 초기화 하기만 하는 기본 생성자는 정의하지 마라](#Rc-default)</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">dd</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">mm</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">yyyy</span> <span class="o">=</span> <span class="mi">1970</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Date</span><span class="o">&gt;</span> <span class="n">vd1</span><span class="p">(</span><span class="mi">1000</span><span class="p">);</span>
</pre></div>


<h5 id="note_41">Note</h5>
<p>클래스의 모든 멤버들이 기본 생성자들을 가지고 있을 경우 묵시적으로 기본 생성자를 가진다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">X</span> <span class="n">x</span><span class="p">;</span> <span class="c1">// means X{{}, {}}; that is the empty string and the empty vector</span>
</pre></div>


<p>기본(built-in) 타입들은 적절하게 기본 생성(default construct)되지 않을 수도 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">;</span>    <span class="c1">// x.s is initialized to the empty string; x.i is uninitialized</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="o">&lt;&lt;</span> <span class="n">x</span><span class="p">.</span><span class="n">i</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
        <span class="o">++</span><span class="n">x</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>정적으로 할당된 내장 타입 개체들은 <code>0</code>으로 초기화 된다. 하지만 지역 변수들은 그렇지 않다.<br />
컴파일러의 최적화 빌드는 내장 타입 지역 변수들을 초기화하지 않을 수 있다는 점에 주의하라. 따라서, 위의 예시와 같은 코드가 나타난다면, 미정의 동작을 일으킬 수 있다.
초기화를 하고자 한다면, 명시적 기본 생성이 도움이 될 것이다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">{};</span>   <span class="c1">// 기본 초기화 (i는 0 이 된다)</span>
    <span class="p">};</span>
</pre></div>


<h5 id="notes">Notes</h5>
<p>적절한 기본 생성을 가지지 않는 클래스들은 보통 복사 또한 불가하다. 때문에 이런 경우는 이 가이드라인에서 다루지 않는다.</p>
<p>예를 들어, 상위 클래스가 값 타입이 아니라면 (상위 클래스들은 복사되어선 안된다) 기본 생성자가 필수적이지 않다:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// Shape is an abstract base class, not a copyable value type.</span>
    <span class="c1">// It may or may not need a default constructor.</span>
    <span class="k">struct</span> <span class="n">Shape</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">draw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// =delete copy/move functions</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>호출자가 제공하는 자원을 생성 과정에서 사용하는 경우라면 기본 생성자를 가질 수 없다. 이 경우도 가이드라인에 해당하지 않는데 보통 이런 클래스들은 복사가 불가능하기 때문이다:</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// std::lock_guard is not a copyable value type.</span>
    <span class="c1">// It does not have a default constructor.</span>
    <span class="n">lock_guard</span> <span class="n">g</span> <span class="p">{</span><span class="n">mx</span><span class="p">};</span>  <span class="c1">// guard the mutex mx</span>
    <span class="n">lock_guard</span> <span class="n">g2</span><span class="p">;</span>      <span class="c1">// error: guarding nothing</span>
</pre></div>


<p>다른 상태들과 다른 방식으로 처리되어야 하는 "특별한 상태"를 가지는 클래스들은 사용자가 더 많은 작업을 하게 만든다 (그 때문에 더 많은 오류를 만들기도 한다). 그런 타입은 (복사와 무관하게) 특별한 상태를 기본 생성 직후의 상태로 사용할 수도 있다.</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// std::ofstream is not a copyable value type.</span>
    <span class="c1">// It does happen to have a default constructor</span>
    <span class="c1">// that goes along with a special &quot;not open&quot; state.</span>
    <span class="n">ofstream</span> <span class="n">out</span> <span class="p">{</span><span class="s">&quot;Foobar&quot;</span><span class="p">};</span>
    <span class="c1">// ...</span>
    <span class="n">out</span> <span class="o">&lt;&lt;</span> <span class="n">log</span><span class="p">(</span><span class="n">time</span><span class="p">,</span> <span class="n">transaction</span><span class="p">);</span>
</pre></div>


<p>복사 가능한 특별한 상태를 가진 타입의 예시로는, 복사 가능한 스마트 포인터를 들 수 있다. 여기서 기본 생성 상태(특별한 상태)는 <code>nullptr</code>를 들고있는 상태가 된다.</p>
<p>하지만, 기본 생성자를 지원하고 생성 후 유의미한 상태를 가지는 것이 권장된다. 이런 예로는 <code>std::string</code>이 <code>""</code>로 초기화되거나, <code>std::vector</code>가 공백상태(<code>{}</code>)를 가지는 것을 들 수 있다.</p>
<h5 id="enforcement_23">Enforcement</h5>
<ul>
<li>클래스가 기본 생성자 없이 복사 가능한 경우를 지적한다</li>
<li>클래스가 복사를 지원하지 않으면서 동등 비교(<code>==</code>)가 가능하면 지적한다</li>
</ul>
<h3 id="c44"><a name="Rc-default00"></a>C.44: 기본 생성자는 가능한 단순하고 예외를 던지지 않도록 하라</h3>
<h5 id="reason_24">Reason</h5>
<p>실패할 수 있는 연산없이 "기본"적인 값을 설정할 수 있다는 것은 오류 처리를 단순화 하고, 이동 연산을 추측 할 수 있도록 한다.</p>
<h5 id="example-problematic">Example, problematic</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="c1">// elem은 공간에 대한 포인터다 - new를 사용해 원소들이 할당된다.</span>
    <span class="k">class</span> <span class="nc">Vector0</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Vector0</span><span class="p">()</span> <span class="o">:</span><span class="n">Vector0</span><span class="p">{</span><span class="mi">0</span><span class="p">}</span> <span class="p">{}</span>
        <span class="n">Vector0</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span><span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]},</span> <span class="n">space</span><span class="p">{</span><span class="n">elem</span> <span class="o">+</span> <span class="n">n</span><span class="p">},</span> <span class="n">last</span><span class="p">{</span><span class="n">elem</span><span class="p">}</span> <span class="p">{}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">own</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">elem</span><span class="p">;</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">space</span><span class="p">;</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">last</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>일반적이지만, 오류 이후 <code>Vector0</code> 를 공백으로 만드는 것은 할당과 관련이 있고, 실패할 수 있다.
또, 기본 <code>Vector</code> 를 <code>{ new T[0], 0, 0}</code> 으로 표현하는 것 역시 낭비처럼 보인다
예를 들면, <code>Vector0&lt;int&gt; v(100)</code>은 100 만큼 할당하는 비용이 든다.</p>
<h5 id="example_19">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="c1">// elem은 nullptr이거나, new를 사용해 할당된 공간을 가리킨다.</span>
    <span class="k">class</span> <span class="nc">Vector1</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// {nullptr, nullptr, nullptr}과 동일하다. 예외를 던지지 않는다.</span>
        <span class="n">Vector1</span><span class="p">()</span> <span class="k">noexcept</span> <span class="p">{}</span>
        <span class="n">Vector1</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span> <span class="o">:</span><span class="n">elem</span><span class="p">{</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">n</span><span class="p">]},</span> <span class="n">space</span><span class="p">{</span><span class="n">elem</span> <span class="o">+</span> <span class="n">n</span><span class="p">},</span> <span class="n">last</span><span class="p">{</span><span class="n">elem</span><span class="p">}</span> <span class="p">{}</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">own</span><span class="o">&lt;</span><span class="n">T</span><span class="o">*&gt;</span> <span class="n">elem</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">space</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">last</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p><code>{nullptr, nullptr, nullptr}</code>는 <code>Vector1{}</code> 를 만드는 비용을 줄여준다(cheap). 하지만 이는 특별한 경우이고 실행시간 평가가 필요하다.
오류를 발견하고 <code>Vector1</code>를 비우는 것은 간단하다.</p>
<h5 id="enforcement_24">Enforcement</h5>
<ul>
<li>예외를 던지는 기본 생성자를 지적한다</li>
</ul>
<h3 id="c45"><a name="Rc-default"></a>C.45: 멤버를 초기화 하기만 하는 기본 생성자는 정의하지 마라; 대신 멤버들이 스스로 초기화 하도록 하라</h3>
<h5 id="reason_25">Reason</h5>
<p>멤버들에게 초기화를 위임하면, 컴파일러가 효율적인 코드를 생성한다. 더 효율적일 수 있다.</p>
<h5 id="example-bad_9">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X1</span> <span class="p">{</span> <span class="c1">// BAD: 멤버 초기화를 사용하지 않는다</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X1</span><span class="p">()</span> <span class="o">:</span><span class="n">s</span><span class="p">{</span><span class="s">&quot;default&quot;</span><span class="p">},</span> <span class="n">i</span><span class="p">{</span><span class="mi">1</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example_20">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X2</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span> <span class="o">=</span> <span class="s">&quot;default&quot;</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// 컴파일러가 생성한 기본 생성자를 사용한다.</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="enforcement_25">Enforcement</h5>
<p>(쉬움) 명시적인 기본 생성자는 초기화 이외의 동작을 해야할 때 쓰는 것이 좋다.</p>
<h3 id="c46-explicit"><a name="Rc-explicit"></a>C.46: 단일 인자를 사용하는 생성자는 <code>explicit</code>으로 선언하라</h3>
<h5 id="reason_26">Reason</h5>
<p>의도치 않은 변환을 피한다.</p>
<h5 id="example-bad_10">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">String</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">String</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>   <span class="c1">// BAD</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">String</span> <span class="n">s</span> <span class="o">=</span> <span class="mi">10</span><span class="p">;</span>   <span class="c1">// 놀랍게도... 길이가 10인 문자열이 된다</span>
</pre></div>


<h5 id="exception_6">Exception</h5>
<p>생성 인자 타입으로부터의 묵시적인 변환을 허용한다면 <code>explicit</code>을 사용하지 않아야 한다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Complex</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Complex</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">);</span>   <span class="c1">// OK: we want a conversion from d to {d, 0}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Complex</span> <span class="n">z</span> <span class="o">=</span> <span class="mf">10.7</span><span class="p">;</span>   <span class="c1">// 전혀 어색하지 않다</span>
</pre></div>


<h5 id="see-also_2">See also</h5>
<p><a href="#Ro-conversion">Discussion of implicit conversions</a></p>
<h5 id="note_42">Note</h5>
<p>복사와 이동 생성자는 변환(conversion)을 수행하지 않기 때문에 <code>explicit</code>이 되어야 한다. 명시적 복사/이동 생성자는 값으로 전달하거나 반환하는 것을 어렵게 한다.</p>
<h5 id="enforcement_26">Enforcement</h5>
<p>(쉬움) 단일 인자를 사용하는 생성자는 <code>explicit</code>으로 선언하도록 한다. <code>explicit</code>이 아니면서 좋은 생성자는 드물다. 모범 사례에 포함되지 않는다면 경고하라.</p>
<h3 id="c47"><a name="Rc-order"></a>C.47: 멤버 변수들은 선언된 순서대로 초기화하라</h3>
<h5 id="reason_27">Reason</h5>
<p>혼란과 오류를 최소화한다. 순서대로 진행하는 것이 초기화의 방식이다. (멤버 변수 초기화와는 무관하다).</p>
<h5 id="example-bad_11">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">m1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m2</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span> <span class="o">:</span><span class="n">m2</span><span class="p">{</span><span class="n">x</span><span class="p">},</span> <span class="n">m1</span><span class="p">{</span><span class="o">++</span><span class="n">x</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>   <span class="c1">// BAD: misleading initializer order</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Foo</span> <span class="nf">x</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span> <span class="c1">// surprise: x.m1 == x.m2 == 2</span>
</pre></div>


<h5 id="enforcement_27">Enforcement</h5>
<p>(단순) 멤버 초기화 리스트는 선언과 같은 순서로 진행되어야 한다.</p>
<h5 id="see-also_3">See also</h5>
<p><a href="./appendix/Discussion.md#Sd-order">Discussion</a></p>
<h3 id="c48-in-class"><a name="Rc-in-class-initializer"></a>C.48: 상수 초기화는 가능한 클래스 내(in-class) 멤버 초기화를 사용하라</h3>
<h5 id="reason_28">Reason</h5>
<p>같은 변수가 사용될 것이라고 명시적으로 보여준다. 중복적으로 작성하지 않아도 된다. 유지보수 문제는 없앤다. 짧고 효율적인 코드가 된다.</p>
<h5 id="example-bad_12">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>   <span class="c1">// BAD</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X</span><span class="p">()</span> <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="mi">666</span><span class="p">},</span> <span class="n">s</span><span class="p">{</span><span class="s">&quot;qqq&quot;</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>   <span class="c1">// j is uninitialized</span>
        <span class="n">X</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">)</span> <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">}</span> <span class="p">{}</span>         <span class="c1">// s is &quot;&quot; and j is uninitialized</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>코드를 유지보수하는 사람이 <code>j</code>가 의도적으로 초기화되지 않았다고 생각할 수 있다 (꽤 이상한 생각이지만). 또 어떤 의도로 <code>s</code>의 기본값으로 <code>""</code>와 <code>qqq</code>를 사용하는지 알 수 있을까? <code>j</code>와 같이 멤버 초기화가 생략되는 문제는 이미 있는 클래스에 새로운 멤버가 추가될 때 발생한다.</p>
<h5 id="example_21">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X2</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">i</span> <span class="p">{</span><span class="mi">666</span><span class="p">};</span>
        <span class="n">string</span> <span class="n">s</span> <span class="p">{</span><span class="s">&quot;qqq&quot;</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">j</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X2</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>        <span class="c1">// all members are initialized to their defaults</span>
        <span class="n">X2</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">)</span> <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">}</span> <span class="p">{}</span>   <span class="c1">// s and j initialized to their defaults</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="alternative_1">Alternative</h5>
<p>생성자에 기본 인자를 주는 것을 생각해볼 수 있다. 오래된 코드에선 꽤 흔한 방법이다. 하지만, 이는 명시적이지 않고, 더 많은 인자가 전달되도록 만든다. 생성자가 여럿인 경우, 기본 인자 코드를 반복적으로 작성해야 한다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X3</span> <span class="p">{</span>   <span class="c1">// BAD: inexplicit, argument passing overhead</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">j</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X3</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span> <span class="o">=</span> <span class="mi">666</span><span class="p">,</span> <span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ss</span> <span class="o">=</span> <span class="s">&quot;qqq&quot;</span><span class="p">,</span> <span class="kt">int</span> <span class="n">jj</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span>
            <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">},</span> <span class="n">s</span><span class="p">{</span><span class="n">ss</span><span class="p">},</span> <span class="n">j</span><span class="p">{</span><span class="n">jj</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>   <span class="c1">// all members are initialized to their defaults</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="enforcement_28">Enforcement</h5>
<ul>
<li>(쉬움) 모든 생성자는 모든 멤버 변수들을 초기화해야 한다 (명시적으로든, 생성자 위임이든, 기본 생성이든)</li>
<li>(쉬움) 생성자의 기본인자는 클래스 내 초기화가 적합할 수 있다</li>
</ul>
<h3 id="c49"><a name="Rc-initialize"></a>C.49: 생성자 안에서의 대입 보다는 초기화를 선호하라</h3>
<h5 id="reason_29">Reason</h5>
<p>초기화는 대입 보다 깔끔하고 아름답게 수행될 수 있다. 값을 설정하기 전에 사용하는 오류("use before set")를 예방한다.</p>
<h5 id="example-good_2">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">A</span> <span class="p">{</span>   <span class="c1">// Good</span>
        <span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">A</span><span class="p">()</span> <span class="o">:</span> <span class="n">s1</span><span class="p">{</span><span class="s">&quot;Hello, &quot;</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>    <span class="c1">// GOOD: directly construct</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example-bad_13">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>   <span class="c1">// BAD</span>
        <span class="n">string</span> <span class="n">s1</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="n">s1</span> <span class="o">=</span> <span class="s">&quot;Hello, &quot;</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// BAD: default constructor followed by assignment</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">C</span> <span class="p">{</span>   <span class="c1">// UGLY, aka very bad</span>
        <span class="kt">int</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">C</span><span class="p">()</span> <span class="p">{</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span><span class="p">{</span><span class="mi">10</span><span class="p">};</span> <span class="p">}</span>   <span class="c1">// accidental use before initialized</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example-better-still">Example, better still</h5>
<p><a href="../SL/#Rstr-view">함수에 문자열 인수를 제시하는 보다 일반적인 방법</a>)으로,
<code>const char*</code> 대신에 'gsl::string_span' 또는 'std::string_view'(C++17)를 사용할 수 있다.</p>
<div class="codehilite"><pre><span></span>class D {   // Good
    string s1;
public:
    A(string_view v) : s1{v} { }    // GOOD: directly construct
    // ...
};
</pre></div>


<h3 id="c50-virtual"><a name="Rc-factory"></a>C.50: 초기화 과정에서 <code>virtual</code> 동작이 필요하다면, 팩토리 함수를 사용하라</h3>
<h5 id="reason_30">Reason</h5>
<p>상위 클래스의 상태가 하위 개체에 의해 결정된다면, 불완전하게 생성된 개체를 사용할 가능성을 최소화 하면서 가상 함수를 사용해야 한다.</p>
<h5 id="note_43">Note</h5>
<p>팩토리 함수의 반환 타입은 보통 <code>unique_ptr</code>가 적절하다; 만약 공유되어야 한다면, 함수를 호출한 쪽에서 <code>unique_ptr</code>를 <code>shared_ptr</code>로 이동시킬 수 있다. 다르게는, 팩토리 함수의 작성자가 반환 개체가 항상 공유된다는 것을 알고있다면, <code>make_shared</code>를 사용해서 <code>shared_ptr</code>를 반환하고 할당을 줄일 수 있다.</p>
<h5 id="example-bad_14">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">B</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="n">f</span><span class="p">();</span>   <span class="c1">// BAD: virtual call in constructor</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example_22">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="n">B</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>              <span class="c1">// create an imperfectly initialized object</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">PostInitialize</span><span class="p">()</span>  <span class="c1">// to be called right after construction</span>
        <span class="p">{</span>
            <span class="c1">// ...</span>
            <span class="n">f</span><span class="p">();</span>    <span class="c1">// GOOD: virtual dispatch is safe</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>

    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
        <span class="k">static</span> <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">Create</span><span class="p">()</span>  <span class="c1">// interface for creating shared objects</span>
        <span class="p">{</span>
            <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">();</span>
            <span class="n">p</span><span class="o">-&gt;</span><span class="n">PostInitialize</span><span class="p">();</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>  <span class="c1">// some derived class</span>

    <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">D</span><span class="o">::</span><span class="n">Create</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">();</span>  <span class="c1">// creating a D object</span>
</pre></div>


<p>생성자를 <code>protected</code>로 만듦으로써, 개체가 불완전하게 생성된 후 사용자 코드에 노출되는 것을 막을 수 있다.
팩토리 함수 <code>Create()</code>를 지원하면 (자유 저장소 영역에) 개체 생성을 좀 더 쉽게할 수 있다.</p>
<h5 id="note_44">Note</h5>
<p>전통적인 팩토리 함수들은 스택이나 인접 개체보다는 자유 저장소에 생성한다.</p>
<h5 id="see-also_4">See also</h5>
<p><a href="./appendix/Discussion.md#Sd-factory">Discussion</a></p>
<h3 id="c51"><a name="Rc-delegating"></a>C.51: 클래스의 모든 생성자들을 위한 일반적인 동작을 표현할 때는 대리 생성자를 사용하라</h3>
<h5 id="reason_31">Reason</h5>
<p>코드 중복과 실수에 의한 코드 차이가 발생하지 않는다.</p>
<h5 id="example-bad_15">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date</span> <span class="p">{</span>   <span class="c1">// BAD: repetitive</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">Month</span> <span class="n">m</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Month</span> <span class="n">mm</span><span class="p">,</span> <span class="n">year</span> <span class="n">yy</span><span class="p">)</span>
            <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">},</span> <span class="n">m</span><span class="p">{</span><span class="n">mm</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">yy</span><span class="p">}</span>
            <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">throw</span> <span class="n">Bad_date</span><span class="p">{};</span> <span class="p">}</span>

        <span class="n">Date</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Month</span> <span class="n">mm</span><span class="p">)</span>
            <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">},</span> <span class="n">m</span><span class="p">{</span><span class="n">mm</span><span class="p">}</span> <span class="n">y</span><span class="p">{</span><span class="n">current_year</span><span class="p">()}</span>
            <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">throw</span> <span class="n">Bad_date</span><span class="p">{};</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>똑같은 동작을 작성하는 것은 지루하고 실수로 인해 똑같지 않을 수도 있다.</p>
<h5 id="example_23">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Date2</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">Month</span> <span class="n">m</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Date2</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Month</span> <span class="n">mm</span><span class="p">,</span> <span class="n">year</span> <span class="n">yy</span><span class="p">)</span>
            <span class="o">:</span><span class="n">i</span><span class="p">{</span><span class="n">ii</span><span class="p">},</span> <span class="n">m</span><span class="p">{</span><span class="n">mm</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">yy</span><span class="p">}</span>
            <span class="p">{</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">valid</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="n">m</span><span class="p">,</span> <span class="n">y</span><span class="p">))</span> <span class="k">throw</span> <span class="n">Bad_date</span><span class="p">{};</span> <span class="p">}</span>

        <span class="n">Date2</span><span class="p">(</span><span class="kt">int</span> <span class="n">ii</span><span class="p">,</span> <span class="n">Month</span> <span class="n">mm</span><span class="p">)</span>
            <span class="o">:</span><span class="n">Date2</span><span class="p">{</span><span class="n">ii</span><span class="p">,</span> <span class="n">mm</span><span class="p">,</span> <span class="n">current_year</span><span class="p">()}</span> <span class="p">{}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="see-also_5">See also</h5>
<p>만약 "반복된 동작"이 단순한 초기화라면, <a href="#Rc-in-class-initializer">클래스 내 멤버 초기화</a>를 고려하라.</p>
<h5 id="enforcement_29">Enforcement</h5>
<p>(중간) 유사한 생성자 구현(Body)을 찾는다</p>
<h3 id="c52"><a name="Rc-inheriting"></a>C.52: 추가적인 초기화가 필요하지 않은 파생된 클래스에서 생성자를 사용할 때는 상속 생성자들을 사용하라</h3>
<h5 id="reason_32">Reason</h5>
<p>하위 클래스들을 위한 생성자가 필요하다면, 생성자를 다시 구현하도록 하는 것은 지루하고 오류의 소지가 많다.</p>
<h5 id="example_24">Example</h5>
<p><code>std::vector</code>는 굉장히 많은 생성자를 지원한다. 때문에 자신만의 <code>vector</code>를 만들고자 한다면, 그 많은 생성자를 다시 작성하고 싶지는 않을 것이다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Rec</span> <span class="p">{</span>
        <span class="c1">// ... data and lots of nice constructors ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Oper</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Rec</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">Rec</span><span class="o">::</span><span class="n">Rec</span><span class="p">;</span>
        <span class="c1">// ... no data members ...</span>
        <span class="c1">// ... lots of nice utility functions ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example-bad_16">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="nl">Rec2</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Rec</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">Rec</span><span class="o">::</span><span class="n">Rec</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Rec2</span> <span class="n">r</span> <span class="p">{</span><span class="s">&quot;foo&quot;</span><span class="p">,</span> <span class="mi">7</span><span class="p">};</span>
    <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="n">r</span><span class="p">.</span><span class="n">x</span><span class="p">;</span>   <span class="c1">// uninitialized</span>
</pre></div>


<h5 id="enforcement_30">Enforcement</h5>
<p>하위 클래스의 모든 멤버들이 초기화되는지 검사한다</p>
<h2 id="ccopy-copy-move"><a name="SS-copy"></a>C.copy: 복사(Copy)와 이동(Move)</h2>
<p>값 타입들은 일반적으로 복사 가능해야 한다. 하지만 클래스 계층에서의 인터페이스들은 그렇지 않아야 한다.<br />
리소스 핸들의 경우, 복사가 가능할 수도, 그렇지 않을 수도 있다.<br />
타입들은 논리적인 또는 성능 상의 이유로 이동하도록 정의될 수 있다.</p>
<h3 id="c60-virtual-constamp-constamp"><a name="Rc-copy-assignment"></a>C.60: 복사연산을 <code>virtual</code>로 만들지 말아라. 매개변수는 <code>const&amp;</code>로 받고, <code>const&amp;</code>로 반환하지 말아라</h3>
<h5 id="reason_33">Reason</h5>
<p>이렇게 하는 것이 간단하고 효율적이다. r-value를 위해 최적화하길 원한다면, <code>&amp;&amp;</code>를 받는 대입 연산을 오버로드하여 제공하라. (<a href="../Functions/#Rf-consume">F.18</a>를 보라)</p>
<h5 id="example_25">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// GOOD: 자기대입 검사를 할 필요가 없다. (성능은 어찌되었든)</span>
            <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">tmp</span><span class="p">);</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Foo</span> <span class="n">a</span><span class="p">;</span>
    <span class="n">Foo</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">Foo</span> <span class="nf">f</span><span class="p">();</span>

    <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// l-value 대입 : 복사</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">f</span><span class="p">();</span>  <span class="c1">// r-value 대입 : 이동일수도 있다</span>
</pre></div>


<h5 id="note_45">Note</h5>
<p><code>swap</code>함수의 구현은 <a href="../Bibliography/#Abrahams01">강한 예외 안전성 보장</a>을 가능하게 한다.</p>
<h5 id="example_26">Example</h5>
<p>하지만 만약 임시 사본을 만들지 않음으로써 훨씬 더 좋은 성능을 얻을 수 있다면 어떨까? 
크고 같은 크기의 <code>Vector</code>들의 대입이 빈번한 영역을 위한 간단한 <code>Vector</code>를 생각해보라.  </p>
<p>이 경우, <code>swap</code>구현 기법에 의한 원소들의 사본은 상당한 비용 증가를 야기할 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Vector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">Vector</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Vector</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">&gt;</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ... swap함수 기법을 사용한다. 이러면 최상의 구현이 된다 ...</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span>
        <span class="p">}</span>
        <span class="c1">// ... copy sz elements from *a.elem to elem ...</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">&lt;</span> <span class="n">sz</span><span class="p">)</span> <span class="p">{</span>
            <span class="c1">// ... *a.elem으로부터 elem으로 sz만큼 원소들을 복사한다 ...</span>
        <span class="p">}</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>대상 원소들에 직접 쓰기 연산을 함으로써, <code>swap</code>기법이 제공하는 강한 예외 보장 대신 <a href="../Bibliography/#Abrahams01">기본적인 예외 보장</a>만 얻게 될 것이다.<br />
<a href="#Rc-copy-self">자기 대입</a>에 주의하라.</p>
<h5 id="alternatives">Alternatives</h5>
<p>만약 <code>virtual</code> 대입 연산자가 필요하다고 생각한다면, 그리고 그것이 어째서 문제를 야기할 수 있는지 이해한다면, 그 함수는 <code>operator=</code>라고 부르지 마라. 이름을 부여해서 <code>virtual void assign(const Foo&amp;)</code>로 만들어라.
<a href="#Rc-copy-virtual">복사 생성 vs. <code>clone()</code></a>를 참조하라.</p>
<h5 id="enforcement_31">Enforcement</h5>
<ul>
<li>(쉬움) 대입 연산자는 가상함수여서는 안된다. 드래곤들만큼 위험하다!</li>
<li>(쉬움) 대입 연산자는 <code>T&amp;</code>를 반환하면 안된다. 연쇄적인 호출을 위해선, 컨테이너로의 개체 대입과 코드 작성을 방해하는 <code>const T&amp;</code>를 사용하지 말아라.</li>
<li>(중간) 대입 연산자는 (암시적으로나 명시적으로나) 모든 기본 클래스와 멤버들의 대입 연산자를 호출해야 한다. 해당 타입이 포인터 문맥이나 값 문맥을 가지는지 확인하기 위해 소멸자를 확인하라.</li>
</ul>
<h3 id="c61"><a name="Rc-copy-semantic"></a>C.61: 복사 연산은 복사를 수행해야 한다</h3>
<h5 id="reason_34">Reason</h5>
<p>일반적으로 그렇게 할 것이라 생각한다. <code>x = y</code>가 수행된 후에는, <code>x == y</code>인 결과를 가져야 한다.
복사 후에는 <code>x</code>와 <code>y</code>가 독립적인 개체들일 수 있다. (값 의미구조, 비-포인터 기본 타입들과 표준 라이브러리 타입들의 동작하는 방식) 또는 공유된 개체를 참조한다(포인터 의미구조, 포인터들이 동작하는 방식).</p>
<h5 id="example_27">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>   <span class="c1">// OK: value semantics</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X</span><span class="p">();</span>
        <span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span>     <span class="c1">// copy X</span>
        <span class="kt">void</span> <span class="nf">modify</span><span class="p">();</span>   <span class="c1">// change the value of X</span>
        <span class="c1">// ...</span>
        <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">sz</span> <span class="o">&amp;&amp;</span> <span class="n">equal</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">a</span><span class="p">.</span><span class="n">sz</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="n">b</span><span class="p">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">b</span><span class="p">.</span><span class="n">sz</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>
        <span class="o">:</span><span class="n">p</span><span class="p">{</span><span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">a</span><span class="p">.</span><span class="n">sz</span><span class="p">]},</span> <span class="n">sz</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">sz</span><span class="p">}</span>
    <span class="p">{</span>
        <span class="n">copy</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">p</span> <span class="o">+</span> <span class="n">sz</span><span class="p">,</span> <span class="n">p</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">X</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">X</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad</span><span class="p">{};</span>
    <span class="n">x</span><span class="p">.</span><span class="n">modify</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">==</span> <span class="n">y</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad</span><span class="p">{};</span>   <span class="c1">// assume value semantics</span>
</pre></div>


<h5 id="example_28">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X2</span> <span class="p">{</span>  <span class="c1">// OK: pointer semantics</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X2</span><span class="p">();</span>
        <span class="n">X2</span><span class="p">(</span><span class="k">const</span> <span class="n">X2</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span> <span class="c1">// shallow copy</span>
        <span class="o">~</span><span class="n">X2</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">modify</span><span class="p">();</span>          <span class="c1">// change the pointed-to value</span>
        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">X2</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">X2</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">sz</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">p</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">p</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">X2</span> <span class="n">x</span><span class="p">;</span>
    <span class="n">X2</span> <span class="n">y</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad</span><span class="p">{};</span>
    <span class="n">x</span><span class="p">.</span><span class="n">modify</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">x</span> <span class="o">!=</span> <span class="n">y</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad</span><span class="p">{};</span>  <span class="c1">// assume pointer semantics</span>
</pre></div>


<h5 id="note_46">Note</h5>
<p>"스마트 포인터"를 만들고 있지 않다면 복사 의미구조을 선호하라. 값 의미구조은 가장 간단하며, 표준 라이브러리의 기능들이 기대하는 것이다.</p>
<h5 id="enforcement_32">Enforcement</h5>
<p>(특별히 없음)</p>
<h3 id="c62"><a name="Rc-copy-self"></a>C.62: 복사 연산은 자기 대입에 안전하게 작성하라</h3>
<h5 id="reason_35">Reason</h5>
<p><code>x = x</code>의 수행이 <code>x</code>의 값을 바꾼다면, 사람들은 놀랄 것이며 안좋은 에러들이 발생할 수 있다 (종종 자원 누수를 포함하기도 한다).</p>
<h5 id="example_29">Example</h5>
<p>표준 라이브러리 컨테이너들은 자기 대입을 우아하고 효율적인 방법으로 처리한다.</p>
<div class="codehilite"><pre><span></span>    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">9</span><span class="p">};</span>
    <span class="n">v</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>
    <span class="c1">// the value of v is still {3, 1, 4, 1, 5, 9}</span>
</pre></div>


<h5 id="note_47">Note</h5>
<p>멤버들로부터 생성된 기본 대입 연산은 자기 대입에 안전하다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Bar</span> <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">map</span><span class="o">&lt;</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Bar</span> <span class="n">b</span><span class="p">;</span>
    <span class="c1">// ...</span>
    <span class="n">b</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>   <span class="c1">// 정확하고, 효율적이다</span>
</pre></div>


<h5 id="note_48">Note</h5>
<p>자기 대입을 명시적으로 검사함으로써 처리할 수도 있을 것이다. 하지만 종종 그런 검사 없이도 우아하고 빠르게 동작하도록 할 수 있다 (가령, <a href="#Rc-swap"><code>swap</code> 사용법</a>).</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">Foo</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>   <span class="c1">// OK, but there is a cost</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>이 방법은 분명 안전하고 효율적이다.
하지만, 만약 백만번 마다 한번씩 자기 대입을 한다면 어떻겠는가?<br />
그 말은 백만번이나 장황한 검사를해야 한다는 것과 같다 (하지만 자기 대입의 결과는 반드시 자신과 같아야 하기 때문에, 컴퓨터의 분기 예측은 매번 맞아떨어질 것이다.)  </p>
<p>이런 코드를 생각해볼 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">Foo</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span>       <span class="c1">// 간단하고, 아마도 훨씬 나을 것이다.</span>
    <span class="p">{</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p><code>std::string</code>은 자기 대입에 안전하고, <code>int</code> 역시 안전하다. (희소하게 발생하는) 자기 대입에 대해서만 비용이 발생하게 된다.</p>
<h5 id="enforcement_33">Enforcement</h5>
<ul>
<li>(쉬움) 대입 연산자들은 <code>if (this == &amp;a) return *this;</code>와 같은 패턴이 있어선 안된다.  </li>
</ul>
<h3 id="c63-virtual-ampamp-constamp"><a name="Rc-move-assignment"></a>C.63: 이동 연산은 <code>virtual</code>로 만들지 말아라, 매개변수는 <code>&amp;&amp;</code>를 사용하고, <code>const&amp;</code>로 반환하지 말아라</h3>
<h5 id="reason_36">Reason</h5>
<p>간단하고, 효율적이다.</p>
<h5 id="see-also_6">See also</h5>
<p><a href="#Rc-copy-assignment">복사 대입을 위한 규칙들</a></p>
<h5 id="enforcement_34">Enforcement</h5>
<p><a href="#Rc-copy-assignment">복사 대입</a>에서와 동일하다.  </p>
<ul>
<li>(쉬움) 대입 연산자는 가상 함수여서는 안된다. 드래곤들만큼 위험하다!</li>
<li>(쉬움) 대입 연산자는 <code>T&amp;</code>를 반환하면 안된다. 연쇄적인 호출을 위해선, 컨테이너로의 개체 대입과 코드 작성을 방해하는 <code>const T&amp;</code>를 사용하지 말아라</li>
<li>(중간) 이동 연산자는 (암시적으로나 명시적으로나) 모든 기본 클래스와 멤버들의 이동 연산자를 호출해야 한다</li>
</ul>
<h3 id="c64"><a name="Rc-move-semantic"></a>C.64: 이동 연산은 이동을 수행해야 하며, 원본 개체를 유효한 상태로 남겨놓아야 한다</h3>
<h5 id="reason_37">Reason</h5>
<p>일반적으로 기대하는 의미구조(semantics)이다. <code>x = std::move(y)</code>를 수행한 후에는, <code>x</code>의 값은 <code>y</code>여야 하며, <code>y</code>는 유효한 상태여야 한다.</p>
<h5 id="example_30">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>   <span class="c1">// OK: value semantics</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">X</span><span class="p">();</span>
        <span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>  <span class="c1">// X를 이동한다</span>
        <span class="kt">void</span> <span class="nf">modify</span><span class="p">();</span>      <span class="c1">// X의 값을 변경한다</span>
        <span class="c1">// ...</span>
        <span class="o">~</span><span class="n">X</span><span class="p">()</span> <span class="p">{</span> <span class="k">delete</span><span class="p">[]</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">X</span><span class="o">::</span><span class="n">X</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span>
        <span class="o">:</span><span class="n">p</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">p</span><span class="p">},</span> <span class="n">sz</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">sz</span><span class="p">}</span>  <span class="c1">// 값을 가져간다</span>
    <span class="p">{</span>
        <span class="n">a</span><span class="p">.</span><span class="n">p</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>     <span class="c1">// empty 상태가 된다</span>
        <span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">X</span> <span class="n">x</span><span class="p">{};</span>
        <span class="c1">// ...</span>
        <span class="n">X</span> <span class="n">y</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">x</span><span class="p">);</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">X</span><span class="p">{};</span>   <span class="c1">// OK</span>
    <span class="p">}</span> <span class="c1">// OK: x 는 소멸 가능하다</span>
</pre></div>


<h5 id="note_49">Note</h5>
<p>이상적으로는, 이동연산을 해준 개체는 해당 타입의 기본 값이어야 한다. 그렇지 않아야 하는 이유가 있지 않는한 기본 값을 가지도록 확실히 하라. 
하지만, 모든 타입들이 기본 값을 가지는 것은 아니며, 또 일부 타입들에서는 기본 값을 만드는 것이 비싼 비용을 필요로 할 수도 있다.
표준에서 요구하는 것은, 이동연산을 해준 개체가 파괴될 수 있다는 것 뿐이다.<br />
종종, 쉽고 비용이 들지 않는 방법을 쓸수도 있다: 표준 라이브러리는 개체로부터 이동을 받을 수 있다고 가정한다. 이동을 해주는 개체는 유효한 상태로 (필요하다면 명시하여) 남겨놓아라.  </p>
<h5 id="note_50">Note</h5>
<p>이 가이드라인을 적용하지 않아야 할 예외적인 이유가 있지 않는 한, <code>x = std::move(y); y = z;</code>를 사용하라. 전통적인 의미구조에 부합한다.</p>
<h5 id="enforcement_35">Enforcement</h5>
<p>(자유선택) 이동 연산에서 멤버들의 대입을 확인해보라. 기본 생성자가 있다면, 그 대입 연산들을 기본 생성자를 사용한 초기화와 비교해보라.  </p>
<h3 id="c65"><a name="Rc-move-self"></a>C.65: 이동 연산은 자기 대입에 안전하게 작성하라</h3>
<h5 id="reason_38">Reason</h5>
<p>만약 <code>x = x</code>가 <code>x</code>의 값을 바꾼다면, 사람들은 놀랄 것이고 안좋은 에러들이 발생할 수 있다. 사람들은 주로 자기 대입을 이동연산으로 작성하지 않지만, 그럴 수도 있다. 
예를 들어, <code>std::swap</code>은 이동 연산들로 구현되었고 만약 당신이 우연히  <code>a</code>와 <code>b</code>가 같은 개체를 참조하는 상황에서 <code>swap(a, b)</code>를 사용한다면, 자기-이동의 실패는 심각하거나 찾기 어려운(subtle) 에러가 될 수 있다.</p>
<h5 id="example_31">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Foo</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">Foo</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">noexcept</span>   <span class="c1">// OK, 하지만 비용이 든다</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">a</span><span class="p">)</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>       <span class="c1">// 이 라인은 무의미하다</span>
        <span class="n">s</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">s</span><span class="p">);</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>백만번에 한번 발생하는 <code>if (this == &amp;a) return *this;</code>에 대한 논쟁이 있다. <a href="#Rc-copy-self">자기 대입</a> 항목에서의 논의는 자기 이동과 더 관련이 있다.</p>
<h5 id="note_51">Note</h5>
<p><code>if (this == &amp;a) return *this;</code>을 쓰지 않는 방법은 알려진 것이 없다. 이동 대입 연산에서 검사를 수행하고 정확한 결과를 얻으라.(가령, <code>x=x</code>를 수행한 뒤에 <code>x</code>가 변화하지 않는다.)  </p>
<h5 id="note_52">Note</h5>
<p>ISO 표준은 표준 라이브러리 컨테이너들에 대해 오직 "유효하지만 명시되지는 않은" 상태만을 보장한다. 이것은 10여년간의 실험적인 사용이나 상용 환경에서 문제가 되지 않았다. 만약 반례를 찾게 된다면 작성자에게 연락하라. 이 규칙은 주의를 필요로 하며 완전히 안전해야 한다.</p>
<h5 id="example_32">Example</h5>
<p>아래는 검사 없이 포인터를 이동하는 방법이다(마치 이동 대입을 구현한 코드라고 상상해보라.):</p>
<div class="codehilite"><pre><span></span>    <span class="c1">// move from other.ptr to this-&gt;ptr</span>
    <span class="n">T</span><span class="o">*</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">other</span><span class="p">.</span><span class="n">ptr</span><span class="p">;</span>
    <span class="n">other</span><span class="p">.</span><span class="n">ptr</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span>
    <span class="k">delete</span> <span class="n">ptr</span><span class="p">;</span>
    <span class="n">ptr</span> <span class="o">=</span> <span class="n">temp</span><span class="p">;</span>
</pre></div>


<h5 id="enforcement_36">Enforcement</h5>
<ul>
<li>(중간) 이러한 자기 대입의 경우, 이동 대입 연산자는 대입 받는 개체의 포인터 멤버를 <code>delete</code>된 상태 또는 <code>nullptr</code>로 남겨놓아서는 안된다.</li>
<li>(자유선택) 표준 라이브러리 컨테이너들의 사용법을 보라(<code>string</code>을 포함한다). 그리고 일반적인(개체 수명에 민감하지 않은) 사용에 그 컨테이너들이 안전하다고 생각하라.</li>
</ul>
<h3 id="c66-noexcept"><a name="Rc-move-noexcept"></a>C.66: 이동 연산은 <code>noexcept</code>로 만들어라</h3>
<h5 id="reason_39">Reason</h5>
<p>예외를 던지는 이동 연산은 대다수의 사람들의 타당한 가정을 무너뜨린다.
예외를 던지지 않는 이동은 표준 라이브러리와 언어 특징들에 의해 더 효율적으로 사용될 수 있다.</p>
<h5 id="example_33">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">Vector</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">noexcept</span> <span class="o">:</span><span class="n">elem</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">elem</span><span class="p">},</span> <span class="n">sz</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">sz</span><span class="p">}</span> <span class="p">{</span> <span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span><span class="p">.</span><span class="n">elem</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">Vector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span> <span class="n">elem</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">elem</span><span class="p">;</span> <span class="n">sz</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">sz</span><span class="p">;</span> <span class="n">a</span><span class="p">.</span><span class="n">sz</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">a</span><span class="p">.</span><span class="n">elem</span> <span class="o">=</span> <span class="k">nullptr</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>이 복사 연산들은 예외를 던지지 않는다.</p>
<h5 id="example-bad_17">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Vector2</span> <span class="p">{</span>
        <span class="c1">// ...</span>
        <span class="n">Vector2</span><span class="p">(</span><span class="n">Vector2</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>             <span class="c1">// just use the copy</span>
        <span class="n">Vector2</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Vector2</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="o">*</span><span class="k">this</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span> <span class="p">}</span>  <span class="c1">// just use the copy</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>이 <code>Vector2</code>는 비 효율적일 뿐만 아니라, 벡터가 메모리 할당을 요구하기 때문에 예외를 던질 수 있다.</p>
<h5 id="enforcement_37">Enforcement</h5>
<p>(쉬움) 이동연산은 <code>noexcept</code>로 표시되어야 한다.</p>
<h3 id="c67"><a name="Rc-copy-virtual"></a>C.67: 다형적인 클래스는 복사를 제한해야 한다</h3>
<h5 id="reason_40">Reason</h5>
<p><em>다형적인 클래스</em>는 하나 이상의 가상 함수를 정의하거나 상속받은 클래스를 의미한다. 다른 하위 클래스들과 같이 상위 클래스를 통해서 사용될 것이다. 
만약 실수로 인해 묵시적으로 생성된 복사 생성자/대입 연산자와 함께 값으로 전달된 경우, 복사 절단(slicing)의 위험이 있다: 하위 개체에서 상위 개체에 해당하는 부분만 복사되고 다형성이 망가진다.</p>
<h5 id="example-bad_18">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span> <span class="c1">// BAD: polymorphic base class doesn&#39;t suppress copying</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">char</span> <span class="n">m</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ... nothing about copy operations, so uses default ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">char</span> <span class="n">m</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// oops, slices the object; b2.m() will return &#39;B&#39;</span>
    <span class="p">}</span>

    <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
</pre></div>


<h5 id="example_34">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span> <span class="c1">// GOOD: polymorphic class suppresses copying</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">B</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">char</span> <span class="nf">m</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">&#39;B&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">char</span> <span class="n">m</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="sc">&#39;D&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">B</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">auto</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span> <span class="c1">// ok, compiler will detect inadvertent copying, and protest</span>
    <span class="p">}</span>

    <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">f</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>
</pre></div>


<h5 id="note_53">Note</h5>
<p>다형적인 개체에 깊은 복사를 사용해야 한다면, <code>clone()</code> 함수들을 사용하라: <a href="#Rh-copy">C.130</a>를 참고하라.</p>
<h5 id="exception_7">Exception</h5>
<p>예외 개체들을 위한 클래스는 다형적이면서 복사 생성이 가능해야 한다.</p>
<h5 id="enforcement_38">Enforcement</h5>
<ul>
<li>다형적인 클래스이면서 복사 연산을 지원하는 경우를 지적하라</li>
<li>다형적인 클래스의 개체가 복사되는 경우 지적하라</li>
</ul>
<h2 id="cother">C.other: 다른 기본 연산 규칙들</h2>
<p>언어가 제공하는 기본 연산들의 구현 이외에도, 비교, <code>swap</code>, 그리고 <code>hash</code>처럼 별도의 정의가 필요할 정도로 기초적인 몇몇 연산들이 있다:</p>
<h3 id="c80-semantic-default"><a name="Rc-eqdefault"></a>C.80: 기본 의미구조(semantic)를 명시적으로 사용하려면 <code>=default</code>를 사용하라</h3>
<h5 id="reason_41">Reason</h5>
<p>컴파일러가 더 정확한 기본 의미구조를 알고 있으며, 이보다 나은 코드를 작성할 수 없다.</p>
<h5 id="example_35">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Tracer</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">message</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Tracer</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="n">message</span><span class="p">{</span><span class="n">m</span><span class="p">}</span> <span class="p">{</span> <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;entering &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">Tracer</span><span class="p">()</span> <span class="p">{</span> <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;exiting &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">Tracer</span><span class="p">(</span><span class="k">const</span> <span class="n">Tracer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Tracer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Tracer</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Tracer</span><span class="p">(</span><span class="n">Tracer</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Tracer</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Tracer</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>소멸자를 정의했기 때문에, 우리는 복사, 이동 연산들을 정의해야만 한다. 이를 위해선 <code>=default</code>가 가장 최선이고, 간단한 방법이다.</p>
<h5 id="example-bad_19">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Tracer2</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">message</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Tracer2</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">m</span><span class="p">)</span> <span class="o">:</span> <span class="n">message</span><span class="p">{</span><span class="n">m</span><span class="p">}</span> <span class="p">{</span> <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;entering &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span>
        <span class="o">~</span><span class="n">Tracer2</span><span class="p">()</span> <span class="p">{</span> <span class="n">cerr</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;exiting &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">message</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="p">}</span>

        <span class="n">Tracer2</span><span class="p">(</span><span class="k">const</span> <span class="n">Tracer2</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span> <span class="n">message</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">message</span><span class="p">}</span> <span class="p">{}</span>
        <span class="n">Tracer2</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Tracer2</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">message</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">message</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">Tracer2</span><span class="p">(</span><span class="n">Tracer2</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="o">:</span><span class="n">message</span><span class="p">{</span><span class="n">a</span><span class="p">.</span><span class="n">message</span><span class="p">}</span> <span class="p">{}</span>
        <span class="n">Tracer2</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Tracer2</span><span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="n">message</span> <span class="o">=</span> <span class="n">a</span><span class="p">.</span><span class="n">message</span><span class="p">;</span> <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
</pre></div>


<p>복사와 이동 연산들의 함수들을 일일이 작성하는 것은 번거롭고, 지루하며, 에러에 취약하다. 컴파일러가 이 작업을 더 잘 할수있다.</p>
<h5 id="enforcement_39">Enforcement</h5>
<ul>
<li>(중간) 특별한 연산들은 중복을 피하기 위해 컴파일러가 만든 함수들과 같은 접근성, 의미구조를 가져서는 안된다</li>
</ul>
<h3 id="c81-delete"><a name="Rc-delete"></a>C.81: 기본 동작을 (대안을 원하지 않고) 금지하고 싶다면 <code>=delete</code>를 사용하라</h3>
<h5 id="reason_42">Reason</h5>
<p>드물게 기본 연산들이 바람직하지 않은 경우도 있다.</p>
<h5 id="example_36">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Immortal</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="o">~</span><span class="n">Immortal</span><span class="p">()</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>   <span class="c1">// 소멸이 금지되었다</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Immortal</span> <span class="n">ugh</span><span class="p">;</span>  <span class="c1">// error: ugh은 소멸될 수 없다</span>
        <span class="n">Immortal</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Immortal</span><span class="p">{};</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>       <span class="c1">// error: *p를 소멸시킬 수 없다</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example_37">Example</h5>
<p><code>unique_ptr</code>는 이동 가능하지만, 복사는 불가능하다. 이 클래스의 복사를 막기 위해, 복사 연산들은 삭제되었다. l-value로부터 복사 연산을 막기 위해서는 <code>=delete</code>가 필요하다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="p">,</span> <span class="k">class</span> <span class="nc">D</span> <span class="o">=</span> <span class="n">default_delete</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&gt;</span> <span class="k">class</span> <span class="nc">unique_ptr</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="k">constexpr</span> <span class="n">unique_ptr</span><span class="p">()</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="k">explicit</span> <span class="nf">unique_ptr</span><span class="p">(</span><span class="n">pointer</span> <span class="n">p</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="n">unique_ptr</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&amp;&amp;</span> <span class="n">u</span><span class="p">)</span> <span class="k">noexcept</span><span class="p">;</span>   <span class="c1">// move constructor</span>
        <span class="c1">// ...</span>
        <span class="n">unique_ptr</span><span class="p">(</span><span class="k">const</span> <span class="n">unique_ptr</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span> <span class="c1">// disable copy from lvalue</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">make</span><span class="p">();</span>   <span class="c1">// &quot;무언가&quot; 만든 뒤에 이동으로 반환한다</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">pi</span> <span class="p">{};</span>
        <span class="k">auto</span> <span class="n">pi2</span> <span class="p">{</span><span class="n">pi</span><span class="p">};</span>      <span class="c1">// error: l-value로부터 생성할 수 없다.</span>
        <span class="k">auto</span> <span class="n">pi3</span> <span class="p">{</span><span class="n">make</span><span class="p">()};</span>  <span class="c1">// OK, 이동 생성: make()의 결과는 r-value이다</span>
    <span class="p">}</span>
</pre></div>


<p>delete된 함수들이 public이라는 점에 주목하라</p>
<h5 id="enforcement_40">Enforcement</h5>
<p>기본 연산을 제거하는 것은 해당 클래스에 부합하는 근거가 있어야 한다.
정말 이유가 있는지 의심하라.
하지만 사람이 보기에 문맥적으로 타당하다고 단언(assert)할 수 있도록 하라.</p>
<h3 id="c82"><a name="Rc-ctor-virtual"></a>C.82: 생성자 또는 소멸자에서 가상 함수를 호출하지 말아라</h3>
<h5 id="reason_43">Reason</h5>
<p>호출된 함수는 파생 클래스에서 오버라이드 하는 함수가 아니라, 생성된 개체의 함수이다.
이러한 동작은 혼란을 일으킬 수 있다.
나쁘게는, 생성자와 소멸자 내부에서 발생하는 구현되지 않은 순수 가상 함수에 대한 직접 또는 간접호출이 비정의된 동작을 일으킨다.</p>
<h5 id="example-bad_20">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>   <span class="c1">// 구현되지 않았다</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">g</span><span class="p">();</span>       <span class="c1">// 기본 버전을 구현하였다</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">h</span><span class="p">();</span>       <span class="c1">// 기본 버전을 구현하였다</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">g</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>   <span class="c1">// 파생 구현을 제공한다</span>
        <span class="kt">void</span> <span class="nf">h</span><span class="p">()</span> <span class="k">final</span><span class="p">;</span>      <span class="c1">// 파생 구현을 제공한다</span>

        <span class="n">Derived</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="c1">// BAD: 구현되지 않은 가상 함수를 호출한다</span>
            <span class="n">f</span><span class="p">();</span>

            <span class="c1">// BAD: will call Derived::g, not dispatch further virtually</span>
            <span class="n">g</span><span class="p">();</span>

            <span class="c1">// GOOD: 접근 가능한(visible) 함수를 명시적으로 호출한다</span>
            <span class="n">Derived</span><span class="o">::</span><span class="n">g</span><span class="p">();</span>

            <span class="c1">// ok, 문제 없다. h함수는 final 구현체를 의미한다</span>
            <span class="n">h</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">};</span>
</pre></div>


<p>특정하게 명시적으로 한정된 함수는 <code>virtual</code>로 선언되었다고 하더라도 가상호출이 발생하지 않음을 기억하라.</p>
<h5 id="see-also_7">See also</h5>
<p>정의되지 않은 동작의 위험이 없이 파생 클래스의 함수를 호출하는 효과를 얻기 위해서는 <a href="#Rc-factory">팩토리 함수</a> 항목을 참고하라.</p>
<h5 id="note_54">Note</h5>
<p>가상 함수를 생성자와 소멸자에서 호출하는 행위가 반드시 잘못된 것은 아니다. 보통의 경우 이런 행위는 타입 안전한 의미구조를 가진다.
하지만, 경험적으로 그런 사용이 필요한 경우는 거의 발생하지 않으며, 유지보수 개발자를 혼란스럽게 한다. 초심자가 사용한다면 실수하는 원인이 될 수 있다.</p>
<h5 id="enforcement_41">Enforcement</h5>
<ul>
<li>생성자와 소멸자에서의 가상 함수 호출을 지적한다</li>
</ul>
<h3 id="c83-noexcept-swap"><a name="Rc-swap"></a>C.83: 값 타입들에는, <code>noexcept</code> swap함수를 제공하는 것을 고려하라</h3>
<h5 id="reason_44">Reason</h5>
<p><code>swap</code>함수는 개체 대입을 구현할 때 원활하게 개체를 이동하는 것에서, 에러가 발생하지 않는 것을 보장하는 함수를 제공하는 것까지 몇몇 함수들(idioms)을 구현하는데 유용하다.
swap함수을 이용해서 복사 대입을 구현하는 것을 고려하라. <a href="../Errors/#Re-never-fail">소멸자, 자원 해제, 그리고 swap은 실패해선 안된다</a>.</p>
<h5 id="example-good_3">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Foo</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">void</span> <span class="n">swap</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span> <span class="n">rhs</span><span class="p">)</span> <span class="k">noexcept</span>
        <span class="p">{</span>
            <span class="n">m1</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">rhs</span><span class="p">.</span><span class="n">m1</span><span class="p">);</span>
            <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">m2</span><span class="p">,</span> <span class="n">rhs</span><span class="p">.</span><span class="n">m2</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Bar</span> <span class="n">m1</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">m2</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>호출자들의 편의를 위해서 같은 네임스페이스에 비-멤버 <code>swap</code>함수를 제공하라.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">Foo</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">Foo</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">a</span><span class="p">.</span><span class="n">swap</span><span class="p">(</span><span class="n">b</span><span class="p">);</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_42">Enforcement</h5>
<ul>
<li>(쉬움) 가상 함수들이 없는 클래스는 <code>swap</code>멤버 함수 선언이 있어야 한다</li>
<li>(쉬움) 클래스가 <code>swap</code> 멤버함수를 가지고 있다면, 그 함수는 <code>noexcept</code>로 선언되어야 한다</li>
</ul>
<h3 id="c84-swap"><a name="Rc-swap-fail"></a>C.84: <code>swap</code> 연산은 실패해선 안된다</h3>
<h5 id="reason_45">Reason</h5>
<p><code>swap</code>연산은 많은 경우 실패하지 않을 것으로 전제하고 사용된다. 또한 실패 가능성이 있는 <code>swap</code>연산으로는 정확하게 동작하도록 프로그램이 작성되기 어렵다. 
표준 라이브러리의 컨테이너들과 알고리즘들은 swap연산의 타입이 실패하면 정확하게 동작하지 않을 것이다.</p>
<h5 id="example-bad_21">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">My_vector</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">,</span> <span class="n">My_vector</span><span class="o">&amp;</span> <span class="n">y</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">tmp</span> <span class="o">=</span> <span class="n">x</span><span class="p">;</span>   <span class="c1">// copy elements</span>
        <span class="n">x</span> <span class="o">=</span> <span class="n">y</span><span class="p">;</span>
        <span class="n">y</span> <span class="o">=</span> <span class="n">tmp</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>이 경우는 느릴 뿐만 아니라, <code>tmp</code>내의 원소들에 메모리 할당이 발생하면, 이 <code>swap</code> 연산은 예외를 던지고 이를 사용하는 STL 알고리즘들이 실패할 수 있다.</p>
<h5 id="enforcement_43">Enforcement</h5>
<ul>
<li>(쉬움) 클래스에 <code>swap</code> 멤버 함수가 있으면, <code>noexcept</code>로 선언되어야 한다.</li>
</ul>
<h3 id="c85-swap-noexcept"><a name="Rc-swap-noexcept"></a>C.85: <code>swap</code> 연산은 <code>noexcept</code>로 작성하라</h3>
<h5 id="reason_46">Reason</h5>
<p><a href="#Rc-swap-fail"><code>swap</code>연산은 실패하지 않도록 작성하라</a>.
<code>swap</code>연산이 예외를 던지면서 종료하려 한다면, 그것은 잘못된 설계 오류이며 프로그램을 종료하는게 낫다.</p>
<h5 id="enforcement_44">Enforcement</h5>
<ul>
<li>(쉬움) 클래스에 <code>swap</code> 멤버 함수가 있으면, <code>noexcept</code>로 선언되어야 한다.</li>
</ul>
<h3 id="c86-noexcept"><a name="Rc-eq"></a>C.86: <code>==</code>연산자는 피연산자 타입들에 대칭적이고, <code>noexcept</code>로 만들어라</h3>
<h5 id="reason_47">Reason</h5>
<p>피연산자들에 비대칭적인 처리는 기대에 부합하지 않고, 형변환이 가능한 경우 에러를 유발할 수 있다.
<code>==</code>는 기본적인 연산이며 프로그래머들이 이 연산을 사용할 때 연산 실패에 대한 고민이 없어야 한다.</p>
<h5 id="example_38">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">X</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span> <span class="k">noexcept</span> <span class="p">{</span>
        <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">number</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example-bad_22">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">number</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>B</code>의 비교 연산은 두번째 피연산자에 대해 형변환을 용인하지만, 첫번째 피연산자에 대해서는 그렇지 않다.</p>
<h5 id="note_55">Note</h5>
<p>만약 클래스가 <code>double</code>타입의 <code>NaN</code>처럼 실패 상태를 가진다면, 실패 상태와의 비교에서 예외를 던지도록 하는 것이 적합할 수도 있다.
다른 방법으로는 실패 상태끼리의 비교는 동등하게 보고, 적합한 상태와 실패 상태의 비교에서는 거짓으로 판정할 수 있다.</p>
<h4 id="note_56">Note</h4>
<p>이 규칙은 모든 일반 비교 연산자들에도 적용된다 : <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>.</p>
<h5 id="enforcement_45">Enforcement</h5>
<ul>
<li>인자의 타입이 다른 <code>operator==()</code>를 지적하라. 다른 비교 연산자들도 마찬가지다 : <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>.</li>
<li>멤버인  <code>operator==()</code> 함수들을 지적하라. 다른 비교 연산자들도 마찬가지다 : <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>.</li>
</ul>
<h3 id="c87"><a name="Rc-eq-base"></a>C.87: 기본 클래스에 있는 <code>==</code>에 주의하라</h3>
<h5 id="reason_48">Reason</h5>
<p>계층 구조에서 잘못 사용하기 어렵고 유용한 <code>==</code>를 작성하는 것은 어려운 일이다.</p>
<h5 id="example-bad_23">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">name</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">number</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
             <span class="k">return</span> <span class="n">name</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">number</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>B</code>의 비교 연산은 두번째 피연산자에 대해서 타입 변환을 허용하지만, 첫번째 피연산자에 대해서는 허용하지 않는다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">D</span> <span class="o">:</span><span class="n">B</span> <span class="p">{</span>
        <span class="kt">char</span> <span class="n">character</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">D</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">name</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">name</span> <span class="o">&amp;&amp;</span> <span class="n">number</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">number</span> <span class="o">&amp;&amp;</span> <span class="n">character</span> <span class="o">==</span> <span class="n">a</span><span class="p">.</span><span class="n">character</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="n">B</span> <span class="n">b</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">D</span> <span class="n">d</span> <span class="o">=</span> <span class="p">...</span>
    <span class="n">b</span> <span class="o">==</span> <span class="n">d</span><span class="p">;</span>    <span class="c1">// compares name and number, ignores d&#39;s character</span>
    <span class="n">d</span> <span class="o">==</span> <span class="n">b</span><span class="p">;</span>    <span class="c1">// error: no == defined</span>
    <span class="n">D</span> <span class="n">d2</span><span class="p">;</span>
    <span class="n">d</span> <span class="o">==</span> <span class="n">d2</span><span class="p">;</span>   <span class="c1">// compares name, number, and character</span>
    <span class="n">B</span><span class="o">&amp;</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">d2</span><span class="p">;</span>
    <span class="n">b2</span> <span class="o">==</span> <span class="n">d</span><span class="p">;</span>   <span class="c1">// compares name and number, ignores d2&#39;s and d&#39;s character</span>
</pre></div>


<p>물론 계층 구조 안에서 <code>==</code>가 동작하도록 하는 방법들이 있지만, 단순한(naive) 방법들은 고려하지 말아라.</p>
<h4 id="note_57">Note</h4>
<p>이 규칙은 모든 일반 비교연산자에 대해서도 동일하다 : <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code></p>
<h5 id="enforcement_46">Enforcement</h5>
<ul>
<li>가상 함수인 <code>operator==()</code>를 지적하라. 다른 비교 연산자들도 동일하다: <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>.</li>
</ul>
<h3 id="c89-hash-noexcept"><a name="Rc-hash"></a>C.89: <code>hash</code>는 <code>noexcept</code>로 작성하라</h3>
<h5 id="reason_49">Reason</h5>
<p>해시 컨테이너들의 사용자들은 hash를 간접적으로 사용하며, 해시값을 위한 단순한 접근이 throw하지 않을 것으로 기대한다.<br />
이는 표준 라이브러리의 요구사항이다.  </p>
<h5 id="example-bad_24">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;&gt;</span>
    <span class="k">struct</span> <span class="n">hash</span><span class="o">&lt;</span><span class="n">My_type</span><span class="o">&gt;</span> <span class="p">{</span>  <span class="c1">// 정말정말 안좋은 해시 특수화</span>
        <span class="k">using</span> <span class="n">result_type</span> <span class="o">=</span> <span class="kt">size_t</span><span class="p">;</span>
        <span class="k">using</span> <span class="n">argument_type</span> <span class="o">=</span> <span class="n">My_type</span><span class="p">;</span>

        <span class="kt">size_t</span> <span class="nf">operator</span><span class="p">()</span> <span class="p">(</span><span class="k">const</span> <span class="n">My_type</span> <span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="kt">size_t</span> <span class="n">xs</span> <span class="o">=</span> <span class="n">x</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">xs</span> <span class="o">&lt;</span> <span class="mi">4</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad_My_type</span><span class="p">{};</span>    <span class="c1">// &quot;이런 이단자 같으니!&quot;</span>
            <span class="k">return</span> <span class="n">hash</span><span class="o">&lt;</span><span class="kt">size_t</span><span class="o">&gt;</span><span class="p">()(</span><span class="n">x</span><span class="p">.</span><span class="n">s</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="o">^</span> <span class="n">trim</span><span class="p">(</span><span class="n">x</span><span class="p">.</span><span class="n">s</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">unordered_map</span><span class="o">&lt;</span><span class="n">My_type</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">m</span><span class="p">;</span>
        <span class="n">My_type</span> <span class="n">mt</span><span class="p">{</span> <span class="s">&quot;asdfg&quot;</span> <span class="p">};</span>
        <span class="n">m</span><span class="p">[</span><span class="n">mt</span><span class="p">]</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">m</span><span class="p">[</span><span class="n">My_type</span><span class="p">{</span> <span class="s">&quot;asdfg&quot;</span> <span class="p">}]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p><code>hash</code> 특수화를 정의할 때는, 간단하게 <code>^</code> (xor)와 함께 표준 라이브러리의 <code>hash</code> 특수화와 통합되도록 하라.<br />
비 전문가들을 위해선 이 방법이 더 적합하다.</p>
<h5 id="enforcement_47">Enforcement</h5>
<ul>
<li>예외를 던지는 <code>hash</code>들을 지적하라.</li>
</ul>
<h3 id="c90-memset-memcpy"><a name="Rc-memset"></a>C.90: <code>memset</code> 또는 <code>memcpy</code>가 아닌, 생성자와 할당 연산자에 의존하라</h3>
<h5 id="reason_50">Reason</h5>
<p>타입의 개체를 생성하기 위한 표준 C++ 메커니즘은 생성자를 호출하는 것이다.</p>
<p>가이드라인에 명시된 것 처럼 <a href="#Rc-complete">C.41</a> : 생성자는 완전히 초기화된 개체를 생성해야 한다.<br />
'memcpy'와 같은 추가적인 초기화 방안은 필요로 하지 않는다. 
타입은 클래스의 복사본을 적절하게 만드는 복사 생성자와(또는) 복사 할당 연산자를 제공하여, 타입의 불변 조건을 유지해야한다. 
memcpy를 통해 복사 미정 타입(non-trivially copyable type)을 복사할 때, 미정의 동작으로 이어진다. 
이로 인해 복사 절단 또는 데이터 손상이 자주 발생한다</p>
<h5 id="example-good_4">Example, good</h5>
<div class="codehilite"><pre><span></span>struct base
{
    virtual void update() = 0;
    std::shared_ptr&lt;int&gt; sp;
};

struct derived : public base
{
    void update() override {}
};
</pre></div>


<h5 id="example-bad_25">Example, bad</h5>
<div class="codehilite"><pre><span></span>void init(derived&amp; a)
{
    memset(&amp;a, 0, sizeof(derived));
}
</pre></div>


<p>불안전한 타입이며, 가상 함수 테이블이 손상(overwrite)된다.</p>
<h5 id="example-bad_26">Example, bad</h5>
<div class="codehilite"><pre><span></span>void copy(derived&amp; a, derived&amp; b)
{
    memcpy(&amp;a, &amp;b, sizeof(derived));
}
</pre></div>


<p>이 또한 불안전한 타입이며, 가상 함수 테이블이 손상(overwrite)된다.</p>
<h5 id="enforcement_48">Enforcement</h5>
<ul>
<li>'memset' 또는 'memcpy'에 복사 미정 타입(non-trivially copyable type)을 전달할 경우 지적하라</li>
</ul>
<h2 id="ccon"><a name="SS-containers"></a>C.con: 컨테이너와 리소스 핸들</h2>
<p>컨테이너는 임의 타입의 연속된 개체들을 가진 개체를 의미한다;  <code>std::vector</code>는 대표적인 컨테이너 타입이다.
리소스 핸들은 자원을 소유하는 클래스를 의미한다; <code>std::vector</code>는 보통 리소스 핸들에 해당한다; 이 경우 자원은 연속된 원소들이다.</p>
<p>컨테이너 규칙 요약:</p>
<ul>
<li><a href="#Rcon-stl">C.100: 컨테이너를 정의할때는 STL을 따르라</a></li>
<li><a href="#Rcon-val">C.101: 값 의미구조(value semantics)를 제공하라</a></li>
<li><a href="#Rcon-move">C.102: 이동 연산을 제공하라</a></li>
<li><a href="#Rcon-init">C.103: 초기화 리스트 생성자를 지원하라</a></li>
<li><a href="#Rcon-empty">C.104: 기본 생성자는 빈 컨테이너를 만들도록 하라</a></li>
<li><a href="#rcon-ptr">C.109: 리소스 핸들이 포인터 의미구조를 따를 경우에는, <code>*</code> 과 <code>-&gt;</code> 연산자를 제공하라</a></li>
</ul>
<h5 id="see-also_8">See also</h5>
<p><a href="../Resource/#S-resource">R: 자원 관리</a></p>
<h3 id="c100-stl"><a name="Rcon-stl"></a>C.100: 컨테이너를 정의할때는 STL을 따르라</h3>
<h5 id="reason_51">Reason</h5>
<p>C++ 프로그래머들에게 STL 컨테이너는 친숙하고 기본적으로 적절한(fundamentally sound) 설계를 가지고 있다.</p>
<h5 id="note_58">Note</h5>
<p>다른 fundamentally sound한 설계 방식들이 있고 표준 라이브러리의 방식을 사용하지 않을 이유가 있기도 하지만, 다른 방식을 택해야 할 확실한 이유가 없다면, 구현자와 사용자 모두 표준을 따르는 것이 단순하고 쉬운 방법이다.</p>
<p>특히, <code>std::vector</code>와 <code>std::map</code>은 단순하고 유용한 모델을 제공한다</p>
<h5 id="example_39">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// simplified (e.g., no allocators):</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Sorted_vector</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">value_type</span> <span class="o">=</span> <span class="n">T</span><span class="p">;</span>
        <span class="c1">// ... iterator types ...</span>

        <span class="n">Sorted_vector</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Sorted_vector</span><span class="p">(</span><span class="n">initializer_list</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span><span class="p">);</span>    <span class="c1">// initializer-list constructor: sort and store</span>
        <span class="n">Sorted_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">Sorted_vector</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Sorted_vector</span><span class="p">(</span><span class="n">Sorted_vector</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="n">Sorted_vector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Sorted_vector</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>   <span class="c1">// copy assignment</span>
        <span class="n">Sorted_vector</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="n">Sorted_vector</span><span class="o">&amp;&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>        <span class="c1">// move assignment</span>
        <span class="o">~</span><span class="n">Sorted_vector</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>

        <span class="n">Sorted_vector</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">);</span>   <span class="c1">// store and sort</span>
        <span class="n">Sorted_vector</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;&amp;&amp;</span> <span class="n">v</span><span class="p">);</span>        <span class="c1">// sort and &quot;steal representation&quot;</span>

        <span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">rep</span><span class="p">[</span><span class="n">i</span><span class="p">];</span> <span class="p">}</span>
        <span class="c1">// no non-const direct access to preserve order</span>

        <span class="kt">void</span> <span class="n">push_back</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>   <span class="c1">// insert in the right place (not necessarily at back)</span>
        <span class="kt">void</span> <span class="nf">push_back</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;&amp;</span><span class="p">);</span>        <span class="c1">// insert in the right place (not necessarily at back)</span>

        <span class="c1">// ... cbegin(), cend() ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">T</span><span class="o">&gt;</span> <span class="n">rep</span><span class="p">;</span>  <span class="c1">// use a std::vector to hold elements</span>
    <span class="p">};</span>

    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">!=</span><span class="p">(</span><span class="k">const</span> <span class="n">T</span><span class="o">&amp;</span><span class="p">);</span>
    <span class="c1">// ...</span>
</pre></div>


<p>위 예시에선, 표준 템플릿 라이브러리 스타일을 불완전하게 따른다. 이런 경우는 흔히 볼 수 있다. 최소한의 기능만 제공하는 것은 특별히 구현된 컨테이너에게는 타당하다. 
핵심은 그 컨테이너에게 맞게 전통적인 생성자, 대입, 소멸, 그리고 반복자를 전통적인 의미구조를 지원하도록 정의하는 것이다. 
이를 바탕으로, 그 컨테이너는 필요한 만큼 확장될 수 있다. 이 예시에서는 <code>std::vector</code>를 사용하는 특별한 생성자가 추가되었다.</p>
<h5 id="enforcement_49">Enforcement</h5>
<p>???</p>
<h3 id="c101-value-semantics"><a name="Rcon-val"></a>C.101: 값 의미구조(value semantics)를 제공하라</h3>
<h5 id="reason_52">Reason</h5>
<p>정규 타입의 개체들은 고민없이 사용할 수 있다. 사용자들은 값 의미구조에 익숙하다.</p>
<h5 id="note_59">Note</h5>
<p>필요하다면, 컨테이너를 <code>Regular</code>(Concept 중 하나)하게 만들어라. 특히, 복사된 개체와 원래 개체를 비교했을 때 같도록 하라.</p>
<h5 id="example_40">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="k">const</span> <span class="n">Sorted_vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&amp;</span> <span class="n">v</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">Sorted_vector</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">v2</span> <span class="p">{</span><span class="n">v</span><span class="p">};</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">v</span> <span class="o">!=</span> <span class="n">v2</span><span class="p">)</span>
            <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;insanity rules!</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_50">Enforcement</h5>
<p>???</p>
<h3 id="c102"><a name="Rcon-move"></a>C.102: 이동 연산을 제공하라</h3>
<h5 id="reason_53">Reason</h5>
<p>컨테이너는 큰 규모로 사용되는 경향이 있다; 이동 연산이 없다면 비용이 많이 드는 복사가 사용될 것이고, 사람들이 포인터를 전달하도록 만듦으로써 자원 관리 문제를 일으킬 수 있다.</p>
<h5 id="example_41">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">Sorted_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">read_sorted</span><span class="p">(</span><span class="n">istream</span><span class="o">&amp;</span> <span class="n">is</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
        <span class="n">cin</span> <span class="o">&gt;&gt;</span> <span class="n">v</span><span class="p">;</span>   <span class="c1">// assume we have a read operation for vectors</span>
        <span class="n">Sorted_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sv</span> <span class="o">=</span> <span class="n">v</span><span class="p">;</span>  <span class="c1">// sorts</span>
        <span class="k">return</span> <span class="n">sv</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">A</span> <span class="n">user</span> <span class="n">can</span> <span class="n">reasonably</span> <span class="n">assume</span> <span class="n">that</span> <span class="n">returning</span> <span class="n">a</span> <span class="n">standard</span><span class="o">-</span><span class="n">like</span> <span class="n">container</span> <span class="n">is</span> <span class="n">cheap</span><span class="p">.</span>
</pre></div>


<h5 id="enforcement_51">Enforcement</h5>
<p>???</p>
<h3 id="c103"><a name="Rcon-init"></a>C.103: 초기화 리스트 생성자를 지원하라</h3>
<h5 id="reason_54">Reason</h5>
<p>사람들은 값 집합을 사용해서 컨테이너 초기화가 가능할 것이라 기대한다. 자연스럽다.</p>
<h5 id="example_42">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">Sorted_vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">sv</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">};</span> <span class="c1">// Sorted_vector sorts elements as needed</span>
</pre></div>


<h5 id="enforcement_52">Enforcement</h5>
<p>???</p>
<h3 id="c104"><a name="Rcon-empty"></a>C.104: 기본 생성자는 빈 컨테이너를 만들도록 하라</h3>
<h5 id="reason_55">Reason</h5>
<p>컨테이너를 정규(Regular) 타입으로 만들어준다.</p>
<h5 id="example_43">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">vector</span><span class="o">&lt;</span><span class="n">Sorted_sequence</span><span class="o">&lt;</span><span class="n">string</span><span class="o">&gt;&gt;</span> <span class="n">vs</span><span class="p">(</span><span class="mi">100</span><span class="p">);</span>    <span class="c1">// 100 Sorted_sequences each with the value &quot;&quot;</span>
</pre></div>


<h5 id="enforcement_53">Enforcement</h5>
<p>???</p>
<h3 id="c109-gt"><a name="Rcon-ptr"></a>C.109: 리소스 핸들이 포인터 의미구조를 따를 경우에는, <code>*</code> 과 <code>-&gt;</code> 연산자를 제공하라</h3>
<h5 id="reason_56">Reason</h5>
<p>포인터에 기대되는 연산들이다. 포인터 사용자들에게는 이런 표현이 익숙하다.</p>
<h5 id="example_44">Example</h5>
<div class="codehilite"><pre><span></span>    ???
</pre></div>


<h5 id="enforcement_54">Enforcement</h5>
<p>???</p>
<h2 id="clambdas-function-objects-and-lambdas"><a name="SS-lambdas"></a>C.lambdas: 함수 개체와 람다 표현식(Function objects and lambdas)</h2>
<p>함수 개체는 <code>()</code>를 오버로드해 호출을 지원하는 개체를 의미한다.
람다 표현식(줄여서 "람다"라고도 한다)은 함수 개체를 생성하도록 하는 표기를 의미한다.
함수 개체는 가능한 복사 비용을 발생시키지 않아야 한다 (또 그렇기에 <a href="../Functions/#Rf-in">값에 의한 전달</a>이 사용된다).</p>
<p>요약:</p>
<ul>
<li><a href="../Functions/#Rf-capture-vs-overload">F.50: 함수를 사용할 수 없다면 람다를 사용하라 (지역 변수를 복사하거나, 지역적으로 사용되는 함수를 작성하는 경우)</a></li>
<li><a href="../Functions/#Rf-reference-capture">F.52: 지역적으로 사용되거나 알고리즘에 전달된다면 람다 캡쳐로는 참조를 선호하라</a></li>
<li><a href="../Functions/#Rf-value-capture">F.53: 반환되거나, 외부에 저장되거나, 다른 스레드로 전달하는 경우처럼 비 지역적으로 사용된다면 람다의 참조 캡쳐를 지양하라</a></li>
<li><a href="../Expr/#Res-lambda-init">ES.28: 복잡한 초기화에는, 특히 상수 변수들의 초기화에는 람다를 사용하라</a></li>
</ul>
<h2 id="chier-oop"><a name="SS-hier"></a>C.hier: 클래스 계층 구조 (OOP)</h2>
<p>클래스 계층구조는 계층적으로 조직화된 개념들의 집합을 표현하면서 (오직 그런 경우에만) 생성된다.
보통 상위 클래스(base class)들은 인터페이스로써 동작한다. 
계층구조를 사용하는 대표적인 예로는 2가지가 있는데, 구현 상속과 인터페이스 상속으로 불린다.</p>
<p>클래스 계층구조 규칙 요약:</p>
<ul>
<li><a href="#Rh-domain">C.120: 계층적인 구조를 가진 개념을 표현하기 위해서만 클래스 계층구조를 사용하라</a></li>
<li><a href="#Rh-abstract">C.121: 상위 클래스가 인터페이스로 사용된다면, 순수 가상 클래스로 만들어라</a></li>
<li><a href="#Rh-separation">C.122: 인터페이스와 구현의 분리가 필요하다면 추상 클래스들을 인터페이스로 사용하라</a></li>
</ul>
<p>계층 구조 내 클래스 설계 규칙 요약:</p>
<ul>
<li><a href="#Rh-abstract-ctor">C.126: 일반적으로 추상 클래스는 생성자가 필요하지 않다</a></li>
<li><a href="#Rh-dtor">C.127: 가상함수를 가진 클래스는 공개(public)된 가상(virtual) 혹은 상속되는(protected) 소멸자를 가져야 한다</a></li>
<li><a href="#Rh-override">C.128: 가상 함수들은 <code>virtual</code>, <code>override</code>, 혹은 <code>final</code> 중 하나만 명시해야 한다</a></li>
<li><a href="#Rh-kind">C.129: 클래스 계층구조를 정의할 때는 구현 상속과 인터페이스 상속을 구분하라</a></li>
<li><a href="#Rh-copy">C.130: 다형적인 클래스에서 깊은 복사를 지원하게 하려면 복사 생성/대입 보다는 가상 <code>clone</code>을 선호하라</a></li>
<li><a href="#Rh-get">C.131: 자잘한 getter와 setter를 사용하지 말아라</a></li>
<li><a href="#Rh-virtual">C.132: 이유없이 함수를 <code>virtual</code>로 만들지 말아라</a></li>
<li><a href="#Rh-protected">C.133: <code>protected</code> 데이터를 지양하라</a></li>
<li><a href="#Rh-public">C.134: <code>const</code>가 아닌 모든 데이터 멤버들이 같은 접근 레벨을 가지도록 하라</a></li>
<li><a href="#Rh-mi-interface">C.135: 서로 다른 인터페이스를 표현하기 위해 다중 상속을 사용하라</a></li>
<li><a href="#Rh-mi-implementation">C.136: 구현 특성(attribute)의 결합을 표현하기 위해 다중 상속을 사용하라</a></li>
<li><a href="#Rh-vbase">C.137: 지나치게 일반적인 상위 클래스를 피하기 위해 <code>virtual</code>을 사용하라</a></li>
<li><a href="#Rh-using">C.138: <code>using</code>을 사용해 상위/하위 클래스를 위한 중복 정의 집합을 만들어라</a></li>
<li><a href="#Rh-final">C.139: <code>final</code>은 필요한 만큼만 사용하라</a></li>
<li><a href="#Rh-virtual-default-arg">C.140: 가상 함수와 그 구현 함수에 서로 다른 기본 인자를 사용하지 마라</a></li>
</ul>
<p>계층 구조 내 개체 접근 규칙 요약:</p>
<ul>
<li><a href="#Rh-poly">C.145: 다형적인 개체들은 포인터와 참조를 통해 접근하라</a></li>
<li><a href="#Rh-dynamic_cast">C.146: 클래스 계층구조 탐색이 불가피한 경우에만 <code>dynamic_cast</code>를 사용하라</a></li>
<li><a href="#Rh-ref-cast">C.147: 필요한 클래스를 찾지 못한 경우가 오류에 해당하는 경우 <code>dynamic_cast</code>를 참조 타입에 사용하라</a></li>
<li><a href="#Rh-ptr-cast">C.148: 필요한 클래스를 찾지 못한 경우가 대안으로 사용된다면 <code>dynamic_cast</code>를 포인터 타입에 사용하라</a></li>
<li><a href="#Rh-smart">C.149: 동적 할당한 개체의 소멸을 잊지 않도록 <code>unique_ptr</code> 혹은 <code>shared_ptr</code>를 사용하라</a></li>
<li><a href="#Rh-make_unique">C.150: <code>unique_ptr</code>로 소유되는 개체를 생성하기 위해서는 <code>make_unique()</code>를 사용하라</a></li>
<li><a href="#Rh-make_shared">C.151: <code>shared_ptr</code>로 소유되는 개체를 생성하기 위해서는 <code>make_shared()</code>를 사용하라</a></li>
<li><a href="#Rh-array">C.152: 절대로 하위 클래스의 포인터에 상위 클래스 포인터를 대입하지 마라</a></li>
<li><a href="#Rh-use-virtual">C.153: 타입 캐스팅보다 가상 함수를 선호하라</a></li>
</ul>
<h3 id="c120"><a name="Rh-domain"></a>C.120: 계층적인 구조를 가진 개념을 표현하기 위해서만 클래스 계층구조를 사용하라</h3>
<h5 id="reason_57">Reason</h5>
<p>생각이 바로 코드로 나타나는 것은 이해와 유지보수를 쉽게 만든다. 생각이 상위 클래스에서 나타나고 하위 타입에서 이를 따르게 하라. 이 목적을 담아내기 위한 방법으로 상속보다 좋은 방법은 없다.</p>
<p>데이터 멤버를 담기 위한 방법으로 상속을 <em>사용해선 안된다</em>. 많은 경우 상속은 하위 타입이 상위 가상 함수를 재정의하거나 멤버에 접근할 필요한 경우를 의미한다.</p>
<h5 id="example_45">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">DrawableUIElement</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">AbstractButton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">DrawableUIElement</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">onClick</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">PushButton</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractButton</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">render</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">onClick</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Checkbox</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AbstractButton</span> <span class="p">{</span>
    <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example-bad_27">Example, bad</h5>
<p>계층적이지 않은 개념을 클래스 계층구조로 표현해선 <em>안된다</em>.</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Container</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// list operations:</span>
        <span class="k">virtual</span> <span class="n">T</span><span class="o">&amp;</span> <span class="n">get</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">put</span><span class="p">(</span><span class="n">T</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">insert</span><span class="p">(</span><span class="n">Position</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="c1">// vector operations:</span>
        <span class="k">virtual</span> <span class="n">T</span><span class="o">&amp;</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">sort</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="c1">// tree operations:</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">balance</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>위 예에서 대부분의 하위 클래스들은 인터페이스에서 요구하는 함수들을 잘 재정의(override)할 수 없다. 때문에 상위 클래스는 구현 부담을 발생시킨다.
나아가서, <code>Container</code>의 사용자는 멤버 함수들이 실제로 유의미한 연산들을 효율적으로 실행하는지 신뢰할 수 없다: 연산을 수행하지 않고 예외를 던질 수도 있다.</p>
<p>이 때문에 유저는 실행 시간 검사에 의존하거나 이와 같은 (과도하게) 일반적인 인터페이스를 사용하지 않고 (<code>dynamic_cast</code>와 같은) 실행시간 타입 확인을 사용할 것이다.</p>
<h5 id="enforcement_55">Enforcement</h5>
<ul>
<li>아무것도 하지 않고 예외를 던지는 멤버가 많은 클래스를 찾아낸다</li>
<li>상위 클래스 <code>B</code>의 가상함수를 하위 클래스 <code>D</code>가 구현하지 않거나 <code>B</code> 멤버에 접근하지 않는 경우를 지적하라. 이때 <code>B</code>는 다음에 해당하지 않아야 한다: 멤버 변수를 가지지 않는다. <code>D</code>의 템플릿 인자 혹은 인자 묶음(pack)이 아니다. <code>D</code>를 사용해 특수화된 템플릿이다.</li>
</ul>
<h3 id="c121"><a name="Rh-abstract"></a>C.121: 상위 클래스가 인터페이스로 사용된다면, 순수 가상 클래스로 만들어라</h3>
<h5 id="reason_58">Reason</h5>
<p>클래스는 데이터를 가지지 않으면 더 안정적이다. 인터페이스는 일반적으로 순수 가상 함수와 기본/비어있는 가상 소멸자로 구성되어야 한다</p>
<h5 id="example_46">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">My_interface</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...only pure virtual functions here ...</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">My_interface</span><span class="p">()</span> <span class="p">{}</span>   <span class="c1">// or =default</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example-bad_28">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Goof</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...only pure virtual functions here ...</span>
        <span class="c1">// no virtual destructor</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Goof</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Goof</span><span class="o">&gt;</span> <span class="n">p</span> <span class="p">{</span><span class="k">new</span> <span class="n">Derived</span><span class="p">{</span><span class="s">&quot;here we go&quot;</span><span class="p">}};</span>
        <span class="n">f</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="c1">// use Derived through the Goof interface</span>
        <span class="n">g</span><span class="p">(</span><span class="n">p</span><span class="p">.</span><span class="n">get</span><span class="p">());</span> <span class="c1">// use Derived through the Goof interface</span>
    <span class="p">}</span> <span class="c1">// leak</span>
</pre></div>


<p><code>Derived</code> 클래스는 <code>Goof</code>를 통해서 소멸되기 때문에, 멤버 <code>string</code>에서 누수가 발생한다. <code>Goof</code>에서 가상 소멸자를 제공하면 모든게 원활하게 돌아간다.</p>
<h5 id="enforcement_56">Enforcement</h5>
<ul>
<li>클래스가 데이터 멤버를 가지면서 (<code>final</code>이 아닌) 가상 함수를 가지면 경고한다</li>
</ul>
<h3 id="c122"><a name="Rh-separation"></a>C.122: 인터페이스와 구현의 분리가 필요하다면 추상 클래스들을 인터페이스로 사용하라</h3>
<h5 id="reason_59">Reason</h5>
<p>예를 들어 ABI(Application Binary Interface)를 사용하는 지점에서 이런 작업이 필요하다.</p>
<h5 id="example_47">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Device</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">Device</span><span class="p">()</span> <span class="o">=</span> <span class="k">default</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">write</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">outbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">inbuf</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">D1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Device</span> <span class="p">{</span>
        <span class="c1">// ... data ...</span>

        <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">outbuf</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">inbuf</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">D2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Device</span> <span class="p">{</span>
        <span class="c1">// ... different data ...</span>

        <span class="kt">void</span> <span class="n">write</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="k">const</span> <span class="kt">char</span><span class="o">&gt;</span> <span class="n">outbuf</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">read</span><span class="p">(</span><span class="n">span</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">&gt;</span> <span class="n">inbuf</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>위와 같은 코드에서 사용자는 <code>Device</code>에서 제공하는 인터페이스를 통해서 <code>D1</code>과 <code>D2</code>를 교환하면서 사용할 수 있다. 나아가서, <code>Device</code>를 통해서 접근되는 한 <code>D1</code>과 <code>D2</code>를 구 버전과 호환되지 않도록(not binary compatible) 업데이트 할 수 있다.</p>
<h5 id="enforcement_57">Enforcement</h5>
<p>???</p>
<h2 id="chierclass">C.hierclass: 계층 구조 내 클래스 설계</h2>
<h3 id="c126"><a name="Rh-abstract-ctor"></a>C.126: 일반적으로 추상 클래스는 생성자가 필요하지 않다</h3>
<h5 id="reason_60">Reason</h5>
<p>추상 클래스는 데이터 멤버를 가지지 않으며 이를 초기화하기 위한 생성자 또한 가지지 않는다.</p>
<h5 id="example_48">Example</h5>
<div class="codehilite"><pre><span></span>    ???
</pre></div>


<h5 id="exception_8">Exception</h5>
<ul>
<li>개체를 어딘가에 등록하기 위한 상위 클래스 생성자가 필요할 수도 있다</li>
<li>극히 드문 경우이지만, 추상 클래스가 하위 클래스들이 공유하는 데이터를 가지는 것이 타당한 경우가 있을 수 있다 (예를 들어, 정적 데이터, 디버깅 정보 등); 그러한 클래스들은 생성자를 가진다. 하지만 주의하라; 그런 경우는 가상 상속에 취약하다</li>
</ul>
<h5 id="enforcement_58">Enforcement</h5>
<p>생성자를 가진 추상 클래스들을 지적하라</p>
<h3 id="c127-public-virtual-protected"><a name="Rh-dtor"></a>C.127: 가상함수를 가진 클래스는 공개(public)된 가상(virtual) 혹은 상속되는(protected) 소멸자를 가져야 한다</h3>
<h5 id="reason_61">Reason</h5>
<p>가상 함수를 가진 클래스들은 보통 상위 클래스의 포인터를 통해서 사용된다. 많은 경우, 마지막 사용자가 상위 클래스 포인터를 통해 delete 하거나 스마트 포인터를 사용해 소멸시킨다. 때문에 소멸자는 public 범위에 있으면서 가상 함수여야 한다. 
드물게는, 상위 클래스 포인터를 사용한 소멸을 의도적으로 지원하지 않는다면, 소멸자는 protected 범위에 있으면서 가상 함수가 아니어야 한다; <a href="#Rc-dtor-virtual">C.35</a>를 참고하라</p>
<h5 id="example-bad_29">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">f</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ... no user-written destructor, defaults to public nonvirtual ...</span>
    <span class="p">};</span>

    <span class="c1">// bad: derived from a class without a virtual destructor</span>
    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span> <span class="p">{</span><span class="s">&quot;default&quot;</span><span class="p">};</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">B</span><span class="o">&gt;</span> <span class="n">p</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">D</span><span class="o">&gt;</span><span class="p">();</span>
        <span class="c1">// ...</span>
    <span class="p">}</span> <span class="c1">// undefined behavior. May call B::~B only and leak the string</span>
</pre></div>


<h5 id="note_60">Note</h5>
<p><code>shared_ptr</code>를 통해 클래스를 사용하기 때문에 이 규칙을 따르지 않는 사람들도 있다: <code>std::shared_ptr&lt;B&gt; p = std::make_shared&lt;D&gt;(args);</code> 이런 경우, 공유 포인터가 소멸을 담당할 것이다. 그러니 부적절한 상위 클래스의 <code>delete</code>로 인한 누수가 발생하지 않는다. 
이를 계속하는 사람들은 잘못된 코드로부터 정상적인 동작을 만들어낸다 (false positive), 그렇지만 이 규칙은 중요하다 -- 만약 누군가 <code>make_unique</code>를 사용해 할당하면 어떻게 될 것인가? <code>B</code>의 작성자가 모든 생성자를 private로 만들고 <code>make_shared</code>를 통해서만 생성이 가능하도록 팩토리 함수를 제공해서 잘못 사용될 것이라고 보장하지 않는 한, 이 코드는 안전하지 않다. </p>
<h5 id="enforcement_59">Enforcement</h5>
<ul>
<li>가상 함수를 가진 클래스는 공개(public)된 가상(virtual) 혹은 상속되는(protected) 소멸자를 가져야 한다</li>
<li>가상 소멸자를 가지지 않고 가상 함수를 사용해 <code>delete</code>하는 클래스를 지적하라</li>
</ul>
<h3 id="c128-virtual-override-final"><a name="Rh-override"></a>C.128: 가상 함수들은 <code>virtual</code>, <code>override</code>, 혹은 <code>final</code> 중 하나만 명시해야 한다</h3>
<h5 id="reason_62">Reason</h5>
<p>가독성. 실수를 발견할 수 있다. 명시적으로 <code>virtual</code>, <code>override</code>, <code>final</code>을 사용하는 것은 함수 자체를 문서화한다. 동시에 컴파일러가 상위 클래스와 하위 클래스의 타입 혹은 이름이 불일치 하는 것을 잡아낼 수 있도록 돕는다.
하지만 이들을 하나 이상 작성하는 것은 중복적이면서 오류를 발생시킬 수 있다.</p>
<p>하나만 작성하는 것이 단순하고 명확하다:</p>
<ul>
<li><code>virtual</code>는 "새로운 가상 함수"라는 것을 의미한다</li>
<li><code>override</code>는 "재정의 될 수 있는(non-<code>final</code>) 재정의 함수"라는 것을 의미한다</li>
<li><code>final</code> 는 "마지막 재정의 함수"라는 것을 의미한다</li>
</ul>
<p>만약 상위 클래스의 소멸자가 <code>virtual</code>로 선언되었다면, 하위 클래스 소멸자들은 <code>virtual</code> 혹은 <code>override</code>가 된다. 어떤 코드 혹은 지원도구에서 소멸자에 <code>override</code>를 사용하도록 강요할 수도 있지만, 이 가이드라인에서는 그 방법은 권하지 않는다.</p>
<h5 id="example-bad_30">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>        <span class="c1">// bad (hope for a warning): D::f1() hides B::f1()</span>
        <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>  <span class="c1">// bad (but conventional and valid): no explicit override</span>
        <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>     <span class="c1">// bad (hope for a warning): D::f3() hides B::f3()</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="example-good_5">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="nl">Better</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
        <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>        <span class="c1">// error (caught): D::f1() hides B::f1()</span>
        <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">const</span> <span class="k">override</span><span class="p">;</span>
        <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="kt">double</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>     <span class="c1">// error (caught): D::f3() hides B::f3()</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h4 id="discussion_1">Discussion</h4>
<p>우리는 이 규칙을 통해 2가지 오류를 없애고자 한다:</p>
<ul>
<li><strong>암묵적 가상함수</strong></li>
<li>프로그래머가 암묵적 가상 함수를 의도했으며, 실제로 그에 해당하는 경우<br />
     (하지만 코드를 읽는 사람은 알아볼 수 없다)</li>
<li>프로그래머는 암묵적 가상 함수를 의도했으나 그렇지 않은 경우<br />
     (예를 들어 인자가 미묘하게 맞지 않았다거나하는 이유로)</li>
<li>프로그래머가 가상 함수를 의도하지 않았으나 가상 함수가 된 경우<br />
     (상위 클래스의 가상 함수와 같은 시그니처를 가지는 바람에)     </li>
<li><strong>암묵적 재정의</strong></li>
<li>프로그래머는 함수가 암묵적으로 재정의되는 것을 의도했고 그렇게 된 경우<br />
     (하지만 코드를 읽는 사람은 알아볼 수 없다)</li>
<li>프로그래머는 함수가 암묵적으로 재정의되는 것을 의도했으나 그렇지 않은 경우
     (예를 들어 인자가 미묘하게 맞지 않았다거나하는 이유로)</li>
<li>프로그래머가 함수가 재정의 되는 것을 의도하지 않았으나 재정의 된 경우<br />
     (상위 클래스의 가상 함수와 같은 시그니처를 가지는 바람에 -- 이런 일은 그 함수가 virtual로 선언되지 않아도 발생한다는 점에 주의하라, 프로그래머가 새로운 가상 함수를 만들기를 원했는지 비 가상 함수를 원했는지 알 방법이 없기 때문이다)</li>
</ul>
<h5 id="enforcement_60">Enforcement</h5>
<ul>
<li>상위 클래스와 하위 클래스들의 이름을 비교하고 같은 이름을 쓰면서 재정의하지 않는 경우를 지적하라</li>
<li><code>override</code>와 <code>final</code> 중 어느 하나도 사용하지 않은 재정의를 지적하라</li>
<li><code>virtual</code>, <code>override</code>, <code>final</code>중 2개 이상을 사용한 함수 선언을 지적하라</li>
</ul>
<h3 id="c129"><a name="Rh-kind"></a>C.129: 클래스 계층구조를 정의할 때는 구현 상속과 인터페이스 상속을 구분하라</h3>
<h5 id="reason_63">Reason</h5>
<p>인터페이스에서 구현 내용을 가지는 것은 인터페이스가 망가지기 쉽게 한다; 달리 말해, 인터페이스의 사용자들이 구현을 바꾼 뒤에 다시 컴파일할 때 영향을 받게 한다.
상위 클래스의 데이터는 상위 클래스를 구현하는 것을 어렵게 만들고 코드 중복을 발생시킬 수 있다.</p>
<h5 id="note_61">Note</h5>
<p>정의:</p>
<ul>
<li>인터페이스 상속은 사용자 코드를 구현과 분리하기 위한 것이다. 하위 클래스에서 상위 클래스를 사용하는 코드에 영향을 미치지 않으면서 코드를 더하거나 변경하는데 사용된다</li>
<li>구현 상속은 상속을 사용해 새로운 구현내용을 하위 구현체들이 사용할 수 있도록하는 것이다 (보통 "programming by difference"라고 불린다).</li>
</ul>
<p>순수한 인터페이스 클래스는 쉽게말해 순수 가상함수들의 집합이라고 할 수 있다; <a href="../Interfaces/#Ri-abstract">I.25</a>를 참고하라.</p>
<p>초창기의 개체지향 프로그래밍에서는 (1980년도와 1990년도), 구현 상속과 인터페이스 상속이 혼재되어 있었고 그런 인습이 아직도 남아있다. 오래된 코드나 교육자료에서는 흔히 볼 수 있다.</p>
<p>아래의 경우 2가지 상속을 구분하는 것이 중요하다</p>
<ul>
<li>계층구조의 크기가 커진다(십수개의 하위 클래스가 존재한다)</li>
<li>계층구조를 사용하는 시간이 길어진다 (수십년)</li>
<li>서로 다른 조직이 계층구조를 사용하고 있다 (즉, 흩어진 상위 클래스를 업데이트 하기 어렵다)</li>
</ul>
<h5 id="example-bad_31">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>   <span class="c1">// BAD, mixed interface and implementation</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Shape</span><span class="p">();</span>
        <span class="n">Shape</span><span class="p">(</span><span class="n">Point</span> <span class="n">ce</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">},</span> <span class="n">Color</span> <span class="n">co</span> <span class="o">=</span> <span class="n">none</span><span class="p">)</span><span class="o">:</span> <span class="n">cent</span><span class="p">{</span><span class="n">ce</span><span class="p">},</span> <span class="n">col</span> <span class="p">{</span><span class="n">co</span><span class="p">}</span> <span class="p">{</span> <span class="cm">/* ... */</span><span class="p">}</span>

        <span class="n">Point</span> <span class="n">center</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cent</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">Color</span> <span class="n">color</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">col</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span> <span class="p">{</span> <span class="n">cent</span> <span class="o">=</span> <span class="n">p</span><span class="p">;</span> <span class="n">redraw</span><span class="p">();</span> <span class="p">}</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">redraw</span><span class="p">();</span>

        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Point</span> <span class="n">cent</span><span class="p">;</span>
        <span class="n">Color</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">)</span> <span class="o">:</span><span class="n">Shape</span><span class="p">{</span><span class="n">c</span><span class="p">},</span> <span class="n">rad</span><span class="p">{</span><span class="n">r</span><span class="p">}</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">rad</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Triangle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Triangle</span><span class="p">(</span><span class="n">Point</span> <span class="n">p1</span><span class="p">,</span> <span class="n">Point</span> <span class="n">p2</span><span class="p">,</span> <span class="n">Point</span> <span class="n">p3</span><span class="p">);</span> <span class="c1">// calculate center</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>위 예시는 아래와 같은 문제들을 가지고 있다:</p>
<ul>
<li>계층구조가 늘고 <code>Shape</code>의 데이터가 늘어난다. 생성자를 작성하고 관리하기 어려워진다</li>
<li><code>Triangle</code>의 중심을 사용하지 않을지도 모르는데 계산할 필요가 있을까?</li>
<li><code>Shape</code>에 새로운 멤버를 추가되면 (예컨대 그리는 방법이라던가 그리는 캔버스), 모든 하위 클래스들이 변화되면서 새로 컴파일 되어야 한다</li>
</ul>
<p><code>Shape::move()</code>가 구현 상속의 한 사례이다: 상위 클래스와 모든 하위 클래스를 위해서 <code>move()</code>를 한번만 정의한다.
상위 클래스에 더 많은 멤버함수 코드가 작성될수록,더 많은 데이터가 공유될수록, 코드를 적게 작성하는 효용이 생기지만 계층구조가 불안정하게 된다.</p>
<h5 id="example_49">Example</h5>
<p>인터페이스 상속을 사용해 <code>Shape</code> 계층을 다시 작성하면 이렇다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>  <span class="c1">// pure interface</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="n">Point</span> <span class="n">center</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">Color</span> <span class="nf">color</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">redraw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>순수 인터페이스들이 생성자를 가지는 경우는 드물다는 점에 주의하라: 생성할 데이터가 존재하지 않는다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Circle</span><span class="p">(</span><span class="n">Point</span> <span class="n">c</span><span class="p">,</span> <span class="kt">int</span> <span class="n">r</span><span class="p">,</span> <span class="n">Color</span> <span class="n">c</span><span class="p">)</span> <span class="o">:</span><span class="n">cent</span><span class="p">{</span><span class="n">c</span><span class="p">},</span> <span class="n">rad</span><span class="p">{</span><span class="n">r</span><span class="p">},</span> <span class="n">col</span><span class="p">{</span><span class="n">c</span><span class="p">}</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

        <span class="n">Point</span> <span class="n">center</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">cent</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">Color</span> <span class="n">color</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">col</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">// ...</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">Point</span> <span class="n">cent</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">rad</span><span class="p">;</span>
        <span class="n">Color</span> <span class="n">col</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>인터페이스는 이제 좀 더 견고해졌지만, 멤버 함수의 구현을 위해 더 많은 작업을 해야 한다. 예를 들어, <code>center</code>는 모든 하위 클래스에서 제각기 구현해야 한다.</p>
<h5 id="example-dual-hierarchy">Example, dual hierarchy</h5>
<p>어떻게 하면 인터페이스 상속에 의한 안정적인 계층구조와 구현 상속의 효율적인 재사용을 결합할 수 있을까?
관련해서 유명한 방식 중 하나는 이중 계층(dual hierarchies) 방식이다. 
여러 방식들이 있지만, 여기서는 다중 상속 방법을 사용한다.</p>
<p>첫번째로 인터페이스 상속을 만든다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>   <span class="c1">// pure interface</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="n">Point</span> <span class="n">center</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="n">Color</span> <span class="nf">color</span><span class="p">()</span> <span class="k">const</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">rotate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">move</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">redraw</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Circle</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span>   <span class="c1">// pure interface</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">radius</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>이 인터페이스를 유용하게 만드려면, 구현 클래스들가 필요하다. (여기서는 <code>Impl</code> 네임스페이스에서 클래스를 하나 더 정의한다):</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Impl</span><span class="o">::</span><span class="nl">Shape</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Shape</span> <span class="p">{</span> <span class="c1">// implementation</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// constructors, destructor</span>
        <span class="c1">// ...</span>
        <span class="n">Point</span> <span class="n">center</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
        <span class="n">Color</span> <span class="n">color</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

        <span class="kt">void</span> <span class="n">rotate</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">move</span><span class="p">(</span><span class="n">Point</span> <span class="n">p</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

        <span class="kt">void</span> <span class="n">redraw</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>

        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>이제 <code>Shape</code>는 구현을 가진 클래스의 지저분한 예시가 되었지만, 좀 더 복잡한 계층구조를 위한 단순한 예시이기 때문에 참아줄 수 있다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Impl</span><span class="o">::</span><span class="nl">Circle</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Circle</span><span class="p">,</span> <span class="k">public</span> <span class="n">Impl</span><span class="o">::</span><span class="n">Shape</span> <span class="p">{</span>   <span class="c1">// implementation</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// constructors, destructor</span>

        <span class="kt">int</span> <span class="n">radius</span><span class="p">()</span> <span class="k">override</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>여기서 <code>Smiley</code>클래스를 더해 계층구조를 확장해보자:</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Smiley</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Circle</span> <span class="p">{</span> <span class="c1">// pure interface</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Impl</span><span class="o">::</span><span class="nl">Smiley</span> <span class="p">:</span> <span class="k">public</span> <span class="n">Smiley</span><span class="p">,</span> <span class="k">public</span> <span class="n">Impl</span><span class="o">::</span><span class="n">Circle</span> <span class="p">{</span>   <span class="c1">// implementation</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// constructors, destructor</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>여기에는 두 계층구조가 혼합되어 있다:</p>
<ul>
<li>인터페이스: Smiley -&gt; Circle -&gt; Shape</li>
<li>구현: Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape</li>
</ul>
<p>인터페이스와 구현 양쪽에서 상속받기 때문에 격자 구조(유향 비순환 그래프)를 가지게 된다:</p>
<div class="codehilite"><pre><span></span>    Smiley     -&gt;         Circle     -&gt;  Shape
      ^                     ^               ^
      |                     |               |
    Impl::Smiley -&gt; Impl::Circle -&gt; Impl::Shape
</pre></div>


<p>앞서 언급한 것처럼, 이는 이중 계층을 구현하기 위한 한 방법일 뿐이다.</p>
<p>추상 인터페이스가 아니라 구현 계층을 통해서 바로 사용될수도 있다.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">work_with_shape</span><span class="p">(</span><span class="n">Shape</span><span class="o">&amp;</span><span class="p">);</span>

    <span class="kt">int</span> <span class="nf">user</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">Impl</span><span class="o">::</span><span class="n">Smiley</span> <span class="n">my_smiley</span><span class="p">{</span> <span class="cm">/* args */</span> <span class="p">};</span>   <span class="c1">// create concrete shape</span>
        <span class="c1">// ...</span>
        <span class="n">my_smiley</span><span class="p">.</span><span class="n">some_member</span><span class="p">();</span>        <span class="c1">// use implementation class directly</span>
        <span class="c1">// ...</span>
        <span class="n">work_with_shape</span><span class="p">(</span><span class="n">my_smiley</span><span class="p">);</span>     <span class="c1">// use implementation through abstract interface</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p>추상 인터페이스에서 지원하지 않는 멤버를 구현 클래스에서 지원하는 경우 유용할 수 있다. 
또 멤버를 직접 사용함으로써 최적화의 가능성도 제공한다 (가령, 구현 멤버함수가 <code>final</code>로 선언되었다면)</p>
<h5 id="note_62">Note</h5>
<p>인터페이스와 구현을 분리하기 위한 또 다른 (관련된) 방법은 <a href="../Interfaces/#Ri-pimpl">Pimpl</a>이다.</p>
<h5 id="note_63">Note</h5>
<p>공통적인 기능들은 (이미 구현된) 상위 클래스 함수로 제공하고 구현 namespace에서 자유롭게 선택하도록 할수도 있다.
상위 클래스는 더 짧은 표기를 할 수 있게 만들어주며, 기능적인 측면에서(at the cost of the functionality) 계층구조가 공유하는 데이터에 접근하는 유일한 존재가 될 수 있다. 유일한 접근자가 접근하기가 쉽다.</p>
<h5 id="enforcement_61">Enforcement</h5>
<ul>
<li>데이터와 가상함수에 대해 하위 타입에서 상위 타입으로의 변환을 지적하라<br />
  (상위 클래스 멤버 함수를 호출하는 것을 제외하고)</li>
<li>???</li>
</ul>
<h3 id="c130-clone"><a name="Rh-copy"></a>C.130: 다형적인 클래스에서 깊은 복사를 지원하게 하려면 복사 생성/대입 보다는 가상 <code>clone</code>을 선호하라</h3>
<h5 id="reason_64">Reason</h5>
<p>다형적인 클래스를 복사하는 것은 절단 문제 때문에 권할만한 일이 아니다. <a href="#Rc-copy-virtual">C.67</a>를 보라. 복사 문맥이 정말 필요하다면, 깊은 복사를 수행하라: 가상 <code>clone</code> 함수를 제공해서 실제 하위 타입을 복사하고 새로운 개체를 소유하는 포인터를 반환하라. 그리고 하위 클래스에서는 하위 클래스의 타입을 반환하라 (공변적인 반환 타입을 사용하라)</p>
<blockquote>
<p>공변성: covariance</p>
</blockquote>
<h5 id="example_50">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="n">owner</span><span class="o">&lt;</span><span class="n">B</span><span class="o">*&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">B</span><span class="p">()</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

        <span class="n">B</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
        <span class="n">B</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">B</span><span class="o">&amp;</span><span class="p">)</span> <span class="o">=</span> <span class="k">delete</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">D</span> <span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">owner</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span> <span class="n">clone</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="o">~</span><span class="n">D</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>보편적인 경우, 소유권을 표현하기 위해 스마트 포인터를 사용하는 것이 권장된다.(<a href="../Resource/#Rr-owner">R.20</a> 참고). 하지만, 언어 규칙으로 인해, 공변적인 반환타입은 스마트 포인터가 될 수 없다: <code>D::clone</code>은 <code>unique_ptr&lt;D&gt;</code>을 반환할 수 없는 반면 <code>B::clone</code>는 <code>unique_ptr&lt;B&gt;</code>를 반환할 수 있다. 이로 인해, 모든 재정의에서 항상 <code>unique_ptr&lt;B&gt;</code> 혹은 <a href="../GSL/#SS-views">Guidelines Support Library</a>의 <code>owner&lt;&gt;</code>를 반환할 수 밖에 없다.</p>
<h3 id="c131-getter-setter"><a name="Rh-get"></a>C.131: 자잘한 getter와 setter를 사용하지 말아라</h3>
<h5 id="reason_65">Reason</h5>
<p>사소한 목적으로 작성된 getter와 setter는 의미구조적 가치가 없다; 단순히 <code>public</code>으로 공개해도 될 것이다.</p>
<h5 id="example_51">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Point</span> <span class="p">{</span>   <span class="c1">// Bad: verbose</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">xx</span><span class="p">,</span> <span class="kt">int</span> <span class="n">yy</span><span class="p">)</span> <span class="o">:</span> <span class="n">x</span><span class="p">{</span><span class="n">xx</span><span class="p">},</span> <span class="n">y</span><span class="p">{</span><span class="n">yy</span><span class="p">}</span> <span class="p">{</span> <span class="p">}</span>
        <span class="kt">int</span> <span class="n">get_x</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">x</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">set_x</span><span class="p">(</span><span class="kt">int</span> <span class="n">xx</span><span class="p">)</span> <span class="p">{</span> <span class="n">x</span> <span class="o">=</span> <span class="n">xx</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">int</span> <span class="n">get_y</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">y</span><span class="p">;</span> <span class="p">}</span>
        <span class="kt">void</span> <span class="n">set_y</span><span class="p">(</span><span class="kt">int</span> <span class="n">yy</span><span class="p">)</span> <span class="p">{</span> <span class="n">y</span> <span class="o">=</span> <span class="n">yy</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// no behavioral member functions</span>
    <span class="p">};</span>
</pre></div>


<p>이런 클래스를 <code>struct</code>로 만드는 것을 고려하라 -- 즉, 어떤 행위도 하지 않는 변수들을 public 데이터로 만들고 멤버함수를 가지지 않는 것이다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Point</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
        <span class="kt">int</span> <span class="n">y</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
    <span class="p">};</span>
</pre></div>


<p>멤버 변수들에 기본 초기화를 사용할 수 있다는 점에 유의하라: <a href="#Rc-initialize">C.49: 생성자 안에서의 대입 보다는 초기화를 선호하라</a>.</p>
<h5 id="note_64">Note</h5>
<p>이 규칙의 핵심은 getter/setter의 의미구조가 가치있는지 판단하는 것이다. 이것이 "사소함"에 대한 완전한 정의는 아니지만, 문법을 넘어서 getter/setter가 public 데이터 멤버였을 때를 고려해보라. 사소하지 않은 의미구조의 예를 든다면: 클래스의 불변조건을 유지하거나 내부(internal) 타입과 인터페이스 타입을 변환하는 것을 예로 들 수 있다.</p>
<h5 id="enforcement_62">Enforcement</h5>
<p>별다른 의미구조 없이 단순히 멤버에 접근하기만 하는 <code>get</code>/<code>set</code> 멤버 함수를 여럿 가지고 있으면 지적한다.</p>
<h3 id="c132-virtual"><a name="Rh-virtual"></a>C.132: 이유없이 함수를 <code>virtual</code>로 만들지 말아라</h3>
<h5 id="reason_66">Reason</h5>
<p>중첩된 <code>virtual</code>은 실행 시간과 개체의 코드 크기를 증가시킨다.
가상 함수는 오버라이드 될 수 있고, 그렇기 때문에 파생 클래스에서의 실수에 노출되어있다. 
가상 함수는 템플릿 계층구조에서 코드 복제를 야기한다.</p>
<h5 id="example-bad_32">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Vector</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">size</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">sz</span><span class="p">;</span> <span class="p">}</span>           <span class="c1">// bad: 파생 클래스에서 다른 무슨 일을 하겠는가?</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">elem</span><span class="p">;</span>   <span class="c1">// the elements</span>
        <span class="kt">int</span> <span class="n">sz</span><span class="p">;</span>    <span class="c1">// number of elements</span>
    <span class="p">};</span>
</pre></div>


<p>이런 "vector"는 기본 클래스로 사용되는 것을 전혀 의도하지 않았다.</p>
<h5 id="enforcement_63">Enforcement</h5>
<ul>
<li>가상 함수를 가지지만 파생 클래스가 없으면 지적하라.</li>
<li>모든 멤버 함수가 가상 함수이고 구현을 가지고 있으면 지적하라.</li>
</ul>
<h3 id="c133-protected"><a name="Rh-protected"></a>C.133: <code>protected</code> 데이터를 지양하라</h3>
<h5 id="reason_67">Reason</h5>
<p><code>protected</code> 데이터는 복잡성과 에러의 원인이다.<br />
<code>protected</code> 데이터는 불변조건의 구문을 복잡하게 만든다.<br />
<code>protected</code> 데이터는 상위 클래스에 데이터를 배치함으로써 필연적으로 가상 상속을 처리해야 하는 상황으로 이어질 수 있다.</p>
<h5 id="example-bad_33">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Shape</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ... interface functions ...</span>
    <span class="k">protected</span><span class="o">:</span>
        <span class="c1">// data for use in derived classes:</span>
        <span class="n">Color</span> <span class="n">fill_color</span><span class="p">;</span>
        <span class="n">Color</span> <span class="n">edge_color</span><span class="p">;</span>
        <span class="n">Style</span> <span class="n">st</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<p>이 예에서 모든 <code>Shape</code>의 하위 타입들은 protected 데이터를 정확하게 변경해야만 한다. 흔히 볼수 있으면서 유지보수 문제를 일으키는 주요 원인 중 하나에 해당한다. 클래스 계층구조가 큰 경우, 일관적으로 protected 데이터를 사용하는 것은 코드가 양적으로 많고 분산되어 있기 때문에 관리되기 어렵다.
상속되는 데이터를 변경할 수 있는 클래스는 더 늘어날 수 있다: 새로 클래스를 상속받아 protected 데이터를 변경하기 시작할 수 있다.
경우에 따라선 클래스들의 전체 집합을 찾는 것이 불가능할수도 있다. 이로 인해 클래스를 변경하는 것을 실행할 수 없을 수도 있다. protected 데이터에는 불변조건을 강요할 수 없다; 전역변수 집합과 같다고 할 수 있다. protected 데이터는 코드 규모가 커지면 실제로 전역변수가 된다.</p>
<h5 id="note_65">Note</h5>
<p>데이터를 protected를 사용해 상속하는 것은 임의적으로 개선하도록 할 수 있게 한다는 점에서 매력적으로 보일 수 있다. 하지만 이로 인해 제어되지 않는 변경과 오류를 발생시키게 된다.
잘 정의되고 불변조건을 강요하도록 <a href="#Rc-private"><code>private</code> 데이터를 선호하라</a>
다른 방법으로는, <a href="#Rh-abstract">인터페이스 클래스는 데이터를 가지지 않도록 하라</a>.</p>
<h5 id="note_66">Note</h5>
<p>protected 멤버 함수에는 문제가 없다.</p>
<h5 id="enforcement_64">Enforcement</h5>
<p><code>protected</code> 데이터를 지적하라</p>
<h3 id="c134-const"><a name="Rh-public"></a>C.134: <code>const</code>가 아닌 모든 데이터 멤버들이 같은 접근 레벨을 가지도록 하라</h3>
<h5 id="reason_68">Reason</h5>
<p>생각하기에 혼란스럽지 않아 오류를 예방한다.
<code>const</code> 멤버들이 서로 다른 접근 레벨을 가지고 있다면, 그 타입이 어떤 일을 하는 것인지 혼란스러울 것이다.
타입이 불변조건을 유지하기 위한 것인가? 혹은 단순히 값의 집합을 표현한 것인가?</p>
<h5 id="discussion_2">Discussion</h5>
<p>하나의 변수에 대해 어떤 코드가 유의미하고 정확한 값을 관리하는 책임이 있는지 고민해야 한다.</p>
<p>데이터 멤버에는 2가지 종류가 있다:</p>
<ul>
<li>A: 개체의 불변조건과 무관한 경우. 이 멤버들이 어떤 값(혹은 값의 조합)을 가져도 유효하다</li>
<li>B: 개체의 불변조건으로 기능하는 경우, 모든 값의 조합이 의미를 가지지는 않는다. 따라서 이 변수들의 값을 변경하는 모든 코드는 불변조건을 알고, 유지하기 위한 규칙들을 고려해야 한다.</li>
</ul>
<p>A 그룹에 속하는 데이터 멤버들은 단순히 <code>public</code> (혹은, 드물지만 하위 클래스에서 볼 수 있도록 <code>protected</code>)이면 된다. 캡슐화가 필요하지 않다. 멤버를 볼 수 있는 코드는 이들을 변경할 수 있다.</p>
<p>B 그룹에 속하는 데이터 멤버들은 <code>private</code>혹은 <code>const</code>여야 한다. 이 경우에는 캡슐화가 필요하기 때문이다. 이들이 <code>private</code>이나 <code>const</code>가 아니라는 것은 개체가 자신의 상태를 관리하지 않는다는 의미가 된다: 클래스의 다른 코드들이 불변조건을 알고 정확하게 유지해야 한다. 그리고 그런 코드가 제한없이 늘어날 수 있다. 이 변수들이 <code>public</code>이 되면 모든 사용 코드가 불변조건을 고려해야 하며, <code>protected</code>이라면 (현재와 미래의) 모든 하위 클래스들이 포함된다.
이는 망가지기 쉽고 강하게 결합된 코드를 만들게 된다. 유지보수가 악몽과 같을 것이다. 의도치 않게 어떤 코드가 데이터 멤버를 잘못된(invalid) 값으로 만들면 개체의 현재 상태와 이후의 사용에 영향을 줄 것이다.</p>
<p>대부분의 클래스들은 A와 B로 구분된다:</p>
<ul>
<li><em>All public</em>: 변수들의 불변조건이 없는 집합을 만든다면 모든 변수가 <code>public</code>이 되어야 한다. <a href="#Rc-struct">이런 경우는 <code>class</code> 보다는 <code>struct</code>로 선언하라</a></li>
<li><em>All private</em>: 불변조건이 있다면, 모든 <code>const</code>가 아닌 변수들은 <code>private</code>이 되어야 한다 -- 캡슐화 하라</li>
</ul>
<h5 id="exception_9">Exception</h5>
<p>경우에 따라선 클래스들이 디버깅을 위해 A와 B를 혼합할 수도 있다. 캡슐화된 개체가 <code>const</code>가 아닌 디버깅 정보를 포할 수도 있다. 이는 불변조건에 포함되지 않고 -- 개체가 관리하는 값의 일부가 아니고 관찰되어야 하는 부분이 아니기 때문에 A에 속한다. 이때는 A에 해당하는 영역 (<code>public</code> 혹은 <code>protected</code>)은 A 처럼, 나머지 영역은(<code>private</code> or <code>const</code>) B 그룹 처럼 관리하면 된다.</p>
<h5 id="enforcement_65">Enforcement</h5>
<p><code>const</code>가 아닌 데이터 멤버들이 서로 다른 접근레벨을 가진 클래스를 지적한다.</p>
<h3 id="c135"><a name="Rh-mi-interface"></a>C.135: 서로 다른 인터페이스를 표현하기 위해 다중 상속을 사용하라</h3>
<h5 id="reason_69">Reason</h5>
<p>모든 클래스들이 모든 인터페이스들을 지원하지는 않을 것이다. 그리고 모든 호출자(caller)들이 모든 연산들을 사용하길 원하지도 않을 것이다. (다중 상속은) 특별히 단일한(monolitic) 인터페이스들을 파생 클래스가 지원하는 동작의 "측면"들로 나눌때 사용하라.</p>
<h5 id="example_52">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">iostream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">istream</span><span class="p">,</span> <span class="k">public</span> <span class="n">ostream</span> <span class="p">{</span>   <span class="c1">// 굉장히 단순하다</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>istream</code>은 입력 연산에 필요한 인터페이스를 제공한다. <code>ostream</code>은 출력 연산에 필요한 인터페이스를 제공한다.
<code>iostream</code>은 <code>istream</code>과 <code>ostream</code> 인터페이스를 결합하면서 단일 스트림에서의 입출력 동기화를 제공한다.</p>
<h5 id="note_67">Note</h5>
<p>하나의 구현에 대해 여러 다른 인터페이스가 필요한 경우 쉽게 볼 수 있다. 그런 인터페이스들은 하나의 계층구조로 조직화하기 쉽지 않다.</p>
<h5 id="note_68">Note</h5>
<p>이런 인터페이스들은 보통 추상 클래스들이다.</p>
<h5 id="enforcement_66">Enforcement</h5>
<p>???</p>
<h3 id="c136-attribute"><a name="Rh-mi-implementation"></a>C.136: 구현 특성(attribute)의 결합을 표현하기 위해 다중 상속을 사용하라</h3>
<h5 id="reason_70">Reason</h5>
<p>Some forms of mixins have state and often operations on that state.
If the operations are virtual the use of inheritance is necessary, if not using inheritance can avoid boilerplate and forwarding.</p>
<h5 id="example_53">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">iostream</span> <span class="o">:</span> <span class="k">public</span> <span class="n">istream</span><span class="p">,</span> <span class="k">public</span> <span class="n">ostream</span> <span class="p">{</span>   <span class="c1">// very simplified</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>istream</code>은 입력 연산에 필요한 인터페이스를 제공한다. <code>ostream</code>은 출력 연산에 필요한 인터페이스를 제공한다.
<code>iostream</code>은 <code>istream</code>과 <code>ostream</code> 인터페이스를 결합하면서 단일 스트림에서의 입출력 동기화를 제공한다.</p>
<h5 id="note_69">Note</h5>
<p>이것은 상대적으로 드문 경우인데, 구현은 종종 단일루트(single-root) 계층으로 조직화될 수 있기 때문이다.</p>
<h5 id="example_54">Example</h5>
<p>경우에 따라서는 "구현 특성(implementation attribute)"이 구현체의 행위를 결정하고 구현체가 요구받는 정책을 따르도록 멤버를 주입하는 "혼합(mixin)" 처럼 보인다.
<code>std::enable_shared_from_this</code> 혹은 boost.intrusive의 <code>list_base_hook</code> 혹은 <code>intrusive_ref_counter</code>를 예로 들 수 있다.</p>
<h5 id="enforcement_67">Enforcement</h5>
<p>???</p>
<h3 id="c137-virtual"><a name="Rh-vbase"></a>C.137: 지나치게 일반적인 상위 클래스를 피하기 위해 <code>virtual</code>을 사용하라</h3>
<h5 id="reason_71">Reason</h5>
<p>공유 데이터와 인터페이스의 분리가 가능하게 만든다. 공유 데이터가 최상위 클래스에 배치되는 것을 막는다.</p>
<h5 id="example_55">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">Interface</span> <span class="p">{</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">g</span><span class="p">();</span>
        <span class="c1">// ... no data here ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Utility</span> <span class="p">{</span>  <span class="c1">// with data</span>
        <span class="kt">void</span> <span class="n">utility1</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">utility2</span><span class="p">();</span>    <span class="c1">// customization point</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">int</span> <span class="n">y</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Derive1</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Interface</span><span class="p">,</span> <span class="k">virtual</span> <span class="k">protected</span> <span class="n">Utility</span> <span class="p">{</span>
        <span class="c1">// override Interface functions</span>
        <span class="c1">// Maybe override Utility virtual functions</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Derive2</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Interface</span><span class="p">,</span> <span class="k">virtual</span> <span class="k">protected</span> <span class="n">Utility</span> <span class="p">{</span>
        <span class="c1">// override Interface functions</span>
        <span class="c1">// Maybe override Utility virtual functions</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p><code>Utility</code>를 추출하는 것은 수많은 하위 클래스들이 "구현 내용(implementation details)"의 많은 부분을 공유한다면 이치에 맞는 작업이다.</p>
<h5 id="note_70">Note</h5>
<p>이 예시는 명백히 너무 "이론적"이다. 하지만 <em>작은 규모</em>의 실제적인 예시를 찾기는 어렵다.
<code>Interface</code>는 <a href="#Rh-abstract">인터페이스 계층</a>의 정점이고, <code>Utility</code>는 <a href="#Rh-kind">구현 계층</a>의 정점이다.
설명을 포함한 <a href="https://www.quora.com/What-are-the-uses-and-advantages-of-virtual-base-class-in-C%2B%2B/answer/Lance-Diduck">좀 더 사실적인 예시는 여기에 있다</a>.</p>
<h5 id="note_71">Note</h5>
<p>때로는 계층을 선형화(linearization)하는 것이 나은 방법일 수 있다</p>
<h5 id="enforcement_68">Enforcement</h5>
<p>인터페이스 계층과 구현 계층이 혼재된 경우 지적한다.</p>
<h3 id="c138-using"><a name="Rh-using"></a>C.138: <code>using</code>을 사용해 상위/하위 클래스를 위한 중복 정의 집합을 만들어라</h3>
<h5 id="reason_72">Reason</h5>
<p>using 선언이 없으면, 하위 클래스의 멤버 함수들이 상속받은 중복정의 집합을 덮어쓴다(hide).</p>
<h5 id="example-bad_34">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="cp">#include</span> <span class="cpf">&lt;iostream&gt;</span><span class="cp"></span>
    <span class="k">class</span> <span class="nc">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f(int): &quot;</span><span class="p">;</span> <span class="k">return</span> <span class="n">i</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">virtual</span> <span class="kt">double</span> <span class="n">f</span><span class="p">(</span><span class="kt">double</span> <span class="n">d</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f(double): &quot;</span><span class="p">;</span> <span class="k">return</span> <span class="n">d</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f(int): &quot;</span><span class="p">;</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">};</span>
    <span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>   <span class="c1">// prints &quot;f(int): 3&quot;</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">(</span><span class="mf">2.3</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span> <span class="c1">// prints &quot;f(int): 3&quot;</span>
    <span class="p">}</span>
</pre></div>


<h5 id="example-good_6">Example, good</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">D</span><span class="o">:</span> <span class="k">public</span> <span class="n">B</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">f</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span> <span class="k">override</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;f(int): &quot;</span><span class="p">;</span> <span class="k">return</span> <span class="n">i</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">using</span> <span class="n">B</span><span class="o">::</span><span class="n">f</span><span class="p">;</span> <span class="c1">// exposes f(double)</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note_72">Note</h5>
<p>이 이슈는 가상/비 가상 멤버 함수 모두에 적용된다.</p>
<p>상위 클래스를 가변적으로 결정할 수 있도록, C++17은 가변 using 선언을 추가했다(introduced).</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span> <span class="o">&lt;</span><span class="n">class</span><span class="p">...</span> <span class="n">Ts</span><span class="o">&gt;</span>
    <span class="k">struct</span> <span class="nl">Overloader</span> <span class="p">:</span> <span class="n">Ts</span><span class="p">...</span> <span class="p">{</span>
        <span class="k">using</span> <span class="n">Ts</span><span class="o">::</span><span class="k">operator</span><span class="p">()...;</span> <span class="c1">// exposes operator() from every base</span>
    <span class="p">};</span>
</pre></div>


<h5 id="enforcement_69">Enforcement</h5>
<p>이름을 덮어쓰는 경우를 찾아낸다</p>
<h3 id="c139-final"><a name="Rh-final"></a>C.139: <code>final</code>은 필요한 만큼만 사용하라</h3>
<h5 id="reason_73">Reason</h5>
<p><code>final</code>은 계층구조의 확장성을 저해한다는 점 때문에 필요한 경우가 거의 없다.</p>
<h5 id="example-bad_35">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Widget</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="c1">// nobody will ever want to improve My_widget (or so you thought)</span>
    <span class="k">class</span> <span class="nc">My_widget</span> <span class="k">final</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Widget</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>

    <span class="k">class</span> <span class="nc">My_improved_widget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">My_widget</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>  <span class="c1">// error: can&#39;t do that</span>
</pre></div>


<h5 id="note_73">Note</h5>
<p>모든 클래스가 상위 클래스로써 작성되지는 않는다. 대부분의 표준 라이브러리 클래스들이 이런 경우에 속한다 (예컨대, <code>std::vector</code>와 <code>std::string</code>는 하위 클래스를 고려하지 않는다). 
이 규칙은 클래스 계층구조 내에서 인터페이스로 동작하는 가상 함수들을 가진 클래스들에 <code>final</code>을 사용하는 경우에 대한 것이다.</p>
<h5 id="note_74">Note</h5>
<p>가상 함수들을 <code>final</code>로 마감하는 것은 <code>final</code>이 함수들의 정의/재정의를 찾아내지 못하도록 하기 때문에 오류를 발생시킬 수 있다. 
운좋게도, 컴파일러가 이런 실수를 찾아낸다: 하위 클래스의 <code>final</code>을 다시 선언하거나 재정의할 수 없다.</p>
<h5 id="note_75">Note</h5>
<p><code>final</code>로 성능이 개선될 것이라는 주장에는 근거가 없다. 대부분 그런 주장은 추측이거나 다른 언어에서의 경험에 근거한 것이다.</p>
<p><code>final</code>이 논리적인 이유와 성능 측면에서 중요한 예시가 있다. </p>
<ul>
<li>컴파일러나 언어 분석 도구에서 사용하는 (성능기준이 높은) AST 계층</li>
<li>시간이 지나도 새로운 하위 클래스가 추가되지 않고 라이브러리 구현자에 의해서만 추가된다</li>
</ul>
<p>하지만 잘못 사용하는 경우가 훨씬 더 많다.</p>
<h5 id="enforcement_70">Enforcement</h5>
<p><code>final</code>을 사용하면 지적한다</p>
<h3 id="c140"><a name="Rh-virtual-default-arg"></a>C.140: 가상 함수와 그 구현 함수에 서로 다른 기본 인자를 사용하지 마라</h3>
<h5 id="reason_74">Reason</h5>
<p>혼란을 일으킨다: 재정의한 코드가 기본 인자를 상속받지 않는다.</p>
<h5 id="example-bad_36">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Base</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">virtual</span> <span class="kt">int</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">2</span><span class="p">)</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">Derived</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Base</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="kt">int</span> <span class="n">multiply</span><span class="p">(</span><span class="kt">int</span> <span class="n">value</span><span class="p">,</span> <span class="kt">int</span> <span class="n">factor</span> <span class="o">=</span> <span class="mi">10</span><span class="p">)</span> <span class="k">override</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Derived</span> <span class="n">d</span><span class="p">;</span>
    <span class="n">Base</span><span class="o">&amp;</span> <span class="n">b</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>

    <span class="n">b</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// these two calls will call the same function but</span>
    <span class="n">d</span><span class="p">.</span><span class="n">multiply</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>  <span class="c1">// with different arguments and so different results</span>
</pre></div>


<h5 id="enforcement_71">Enforcement</h5>
<p>가상함수의 기본인자가 상위/하위 클래스의 선언에서 서로 다르면 지적한다</p>
<h2 id="chier-access">C.hier-access: 계층 구조 내 개체 접근</h2>
<h3 id="c145"><a name="Rh-poly"></a>C.145: 다형적인 개체들은 포인터와 참조를 통해 접근하라</h3>
<h5 id="reason_75">Reason</h5>
<p>가상 함수를 가진 클래스가 있다면, 당신은 (일반적으로) 어떤 클래스가 실행될 함수를 제공할지 알 수 없다.</p>
<h5 id="example_56">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">a</span><span class="p">;</span> <span class="k">virtual</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">();</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">b</span><span class="p">;</span> <span class="kt">int</span> <span class="nf">f</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span> <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="n">B</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">B</span> <span class="n">b2</span> <span class="o">=</span> <span class="n">d</span><span class="p">;</span>   <span class="c1">// 복사 손실(slice)</span>
        <span class="n">B</span> <span class="n">b3</span> <span class="o">=</span> <span class="n">b</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">use2</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">use</span><span class="p">(</span><span class="n">d</span><span class="p">);</span>   <span class="c1">// 복사 손실(slice)</span>
    <span class="p">}</span>
</pre></div>


<p>Both <code>d</code>s are sliced.</p>
<h5 id="exception_10">Exception</h5>
<p>개체가 정의된 범위 안에서는 이름이 있는 다형적 개체에 안전하게 접근할 수 있다. 단지 복사 손실이 생기지 않도록 하라.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">use3</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">D</span> <span class="n">d</span><span class="p">;</span>
        <span class="n">d</span><span class="p">.</span><span class="n">f</span><span class="p">();</span>   <span class="c1">// OK</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_72">Enforcement</h5>
<p>모든 절단(slicing)을 지적하라.</p>
<h3 id="c146-dynamic_cast"><a name="Rh-dynamic_cast"></a>C.146: 클래스 계층구조 탐색이 불가피한 경우에만 <code>dynamic_cast</code>를 사용하라</h3>
<h5 id="reason_76">Reason</h5>
<p><code>dynamic_cast</code>는 실행시간에 검사된다.</p>
<h5 id="example_57">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>   <span class="c1">// 인터페이스</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="n">f</span><span class="p">();</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">g</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>   <span class="c1">// 확장된 인터페이스</span>
        <span class="kt">void</span> <span class="n">f</span><span class="p">()</span> <span class="k">override</span><span class="p">;</span>
        <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">h</span><span class="p">();</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">user</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">pb</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">D</span><span class="o">*</span> <span class="n">pd</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">))</span> <span class="p">{</span>
            <span class="c1">// ... D의 인터페이스를 사용한다 ...</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ... B의 인터페이스를 사용한다 ...</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<p>다른 캐스팅 방법은 타입 안전성을 해치고 프로그램이 실제로 <code>X</code>인 변수를 <code>Z</code>처럼 사용하게 만든다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">user2</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">pb</span><span class="p">)</span>   <span class="c1">// bad</span>
    <span class="p">{</span>
        <span class="n">D</span><span class="o">*</span> <span class="n">pd</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>    <span class="c1">// I know that pb really points to a D; trust me</span>
        <span class="c1">// ... use D&#39;s interface ...</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">user3</span><span class="p">(</span><span class="n">B</span><span class="o">*</span> <span class="n">pb</span><span class="p">)</span>    <span class="c1">// unsafe</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">some_condition</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">D</span><span class="o">*</span> <span class="n">pd</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb</span><span class="p">);</span>   <span class="c1">// I know that pb really points to a D; trust me</span>
            <span class="c1">// ... use D&#39;s interface ...</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="c1">// ... make do with B&#39;s interface ...</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">B</span> <span class="n">b</span><span class="p">;</span>
        <span class="n">user</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>   <span class="c1">// OK</span>
        <span class="n">user2</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// bad error</span>
        <span class="n">user3</span><span class="p">(</span><span class="o">&amp;</span><span class="n">b</span><span class="p">);</span>  <span class="c1">// OK *if* the programmer got the some_condition check right</span>
    <span class="p">}</span>
</pre></div>


<h5 id="note_76">Note</h5>
<p>다른 모든 캐스팅처럼, <code>dynamic_cast</code>는 너무 자주 사용된다.</p>
<p><a href="#Rh-use-virtual">캐스팅 보다는 가상 함수들을 사용하라</a>.
가능한 한 클래스 계층을 탐색하는 것보다 <a href="#???">정적 다형성(링크 없음)</a>을 선호하라. 이렇게 하면 실행시간 결정이 필요없다. 그리고 충분히 편리하다.</p>
<h5 id="note_77">Note</h5>
<p><code>typeid</code>가 더 적절한데 <code>dynamic_cast</code>를 쓰는 사람들이 있다;
<code>dynamic_cast</code>는 일반적으로 알려진 (개체에 가장 적합한 인터페이스를 찾기 위한) "is kind of" 연산이다.
반면 <code>typeid</code>는 "이 개체의 정확한 타입을 찾는" 연산이다. 후자는 단순하고 더 빠르게 처리될 것이 분명하다.
<code>typeid</code>는 필요하다면 쉽게 작성할 수 있다(모종의 이유로 RTTI가 지원되지 않는다면). <code>dynamic_cast</code>는 보통 정확하게 구현하기 훨씬 어렵다.</p>
<p>다음과 같은 예를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="p">{</span><span class="s">&quot;B&quot;</span><span class="p">};</span>
        <span class="c1">// if pb1-&gt;id() == pb2-&gt;id() *pb1 is the same type as *pb2</span>
        <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">id</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span> <span class="p">{</span><span class="s">&quot;D&quot;</span><span class="p">};</span>
        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="nf">id</span><span class="p">()</span> <span class="k">const</span> <span class="k">override</span> <span class="p">{</span> <span class="k">return</span> <span class="n">name</span><span class="p">;</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="n">B</span><span class="o">*</span> <span class="n">pb1</span> <span class="o">=</span> <span class="k">new</span> <span class="n">B</span><span class="p">;</span>
        <span class="n">B</span><span class="o">*</span> <span class="n">pb2</span> <span class="o">=</span> <span class="k">new</span> <span class="n">D</span><span class="p">;</span>

        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb1</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span> <span class="c1">// &quot;B&quot;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">pb2</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">();</span> <span class="c1">// &quot;D&quot;</span>


        <span class="k">if</span> <span class="p">(</span><span class="n">pb1</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;D&quot;</span><span class="p">)</span> <span class="p">{</span>         <span class="c1">// looks innocent</span>
            <span class="n">D</span><span class="o">*</span> <span class="n">pd</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">D</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">pb1</span><span class="p">);</span>
            <span class="c1">// ...</span>
        <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p><code>pb2-&gt;id() == "D"</code>의 결과는 실제로는 구현에 의해 결정된 것이다. 이는 직접 작성한 RTTI의 위험을 경고하기 위한 예시다.
수년간 이 코드가 기대한 대로 동작할수도 있지만, 새로운 기계, 컴파일러, 혹은 링커에서 소스코드 내 문자(character literals)를 통일하지 않으면 실패하게 된다.</p>
<p>RTTI를 직접 구현하고자 한다면, 주의하라.</p>
<h5 id="exception_11">Exception</h5>
<p>만약 당신의 구현 코드에 정말로 느린 <code>dynamic_cast</code>가 있다면, 다른 방법을 찾아야 할 것이다.
하지만, 정적으로 클래스를 결정할 수 없는 모든 대안은 명시적 캐스팅(일반적으로 <code>static_cast</code>)을 포함하고, 에러에 취약하다.  </p>
<p>당신만의 특별한 <code>dynamic_cast</code>를 만들수도 있을 것이다. 그러니, <code>dynamic_cast</code>가 정말로 당신이 생각하는 것 만큼 느리다는 것을 확실히하라. (근거 없는 루머들이 꽤 있다.) 그리고 <code>dynamic_cast</code>의 사용이 정말로 성능에 치명적이라는 것 또한 확인하라.</p>
<p>이는 <code>dynamic_cast</code>의 현재 구현이 불필요하게 느린 경우에 대한 것이다. 
예를 들어, 적절한 조건 하에서는, <code>dynamic_cast</code>를 <a href="http://www.stroustrup.com/fast_dynamic_casting.pdf">O(1)시간 내로 수행</a>할 수 있다. 하지만, 최적화를 위해 노력할 가치가 있다는데 모두가 동의하지 않으면 호환성은 코드 변경을 어렵게 한다.</p>
<p>매우 드물게, <code>dynamic_cast</code>의 오버헤드가 문제가 된다면, 하향 캐스팅이 성공한다고 정적으로 보장되는 다른 방법을 쓸 수도 있다 (예를 들어 Curiously Recurring Template Pattern을 주의해서 쓰는 방법처럼). 
가상 상속을 사용하지 않는다면, 확실한 주석과 함께 <code>static_cast</code>에 의존하거나 시스템이 정확성을 검증할 수 없기 때문에 유지보수에 사람이 필요하다는 조항을 작성하라.
그렇게 하더라도, 우리 경험으로 미루어 "나는 지금 뭘 하는지 몰라요"는 버그의 근원이다.</p>
<h5 id="exception_12">Exception</h5>
<p>다음과 같은 코드는 예외로 볼 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">B</span><span class="o">&gt;</span>
    <span class="k">class</span> <span class="nc">Dx</span> <span class="o">:</span> <span class="n">B</span> <span class="p">{</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="enforcement_73">Enforcement</h5>
<ul>
<li>모든 하위 타입으로의 <code>static_cast</code>를 지적하라. <code>static_cast</code>를 수행하는 C 스타일 변환도 포함하라</li>
<li>이 규칙은 <a href="../Profile/#Pro-type-downcast">타입 안전성</a> 규칙들의 일부이다</li>
</ul>
<h3 id="c147-dynamic_cast"><a name="Rh-ref-cast"></a>C.147: 필요한 클래스를 찾지 못한 경우가 오류에 해당하는 경우 <code>dynamic_cast</code>를 참조 타입에 사용하라</h3>
<h5 id="reason_77">Reason</h5>
<p>참조자에 대한 캐스팅은 당신이 정상적인 개체를 얻는 것을 의도했음을 표현한다. 따라서 캐스팅은 반드시 성공해야만 한다. <code>dynamic_cast</code>는 만약 실패한다면 예외를 던질 것이다.</p>
<h5 id="example_58">Example</h5>
<div class="codehilite"><pre><span></span>    ???
</pre></div>


<h5 id="enforcement_74">Enforcement</h5>
<p>???</p>
<h3 id="c148-dynamic_cast"><a name="Rh-ptr-cast"></a>C.148: 필요한 클래스를 찾지 못한 경우가 대안으로 사용된다면 <code>dynamic_cast</code>를 포인터 타입에 사용하라</h3>
<h5 id="reason_78">Reason</h5>
<p><code>dynamic_cast</code>는 포인터가 계층구조 내에서 다형적 개체를 가리키고 있는지 검사할 수 있도록 해준다.
해당 클래스를 찾는데 실패할 경우 단순히 null 값을 반환하기 때문에, 실행시간에 검사하는 것이 가능하다. 이 덕분에 참색 결과에 따라 다른 방법을 선택하는 코드를 작성하는 것이 가능하다.</p>
<p><a href="#Rh-ptr-cast">C.147</a> 항목과 반대로, 탐색 실패가 오류라면, 조건부 실행에서 사용되어선 안된다.</p>
<h5 id="example_59">Example</h5>
<p>아래의 예시는 <code>Shape_owner</code>의 <code>add</code> 함수가 생성된 <code>Shape</code>의 소유권을 가져가는 것을 보여준다. 개체들은 기하학적 특성에 따라 정렬된다.</p>
<p>이 예시에선, <code>Shape</code>는 <code>Geometric_attributes</code>를 상속하지 않는다.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">add</span><span class="p">(</span><span class="n">Shape</span><span class="o">*</span> <span class="k">const</span> <span class="n">item</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// Ownership is always taken</span>
        <span class="n">owned_shapes</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">item</span><span class="p">);</span>

        <span class="c1">// Check the Geometric_attributes and add the shape to none/one/some/all of the views</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">even</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Even_sided</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">view_of_evens</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">even</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="k">auto</span> <span class="n">trisym</span> <span class="o">=</span> <span class="k">dynamic_cast</span><span class="o">&lt;</span><span class="n">Trilaterally_symmetrical</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">item</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="n">view_of_trisyms</span><span class="p">.</span><span class="n">emplace_back</span><span class="p">(</span><span class="n">trisym</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</pre></div>


<h5 id="notes_1">Notes</h5>
<p>탐색 실패로 인해 <code>dynamic_cast</code>이 null을 반환하기 때문에, null 포인터 참조가 발생하고 미정의 동작으로 이어질 것이다.
따라서 <code>dynamic_cast</code>의 결과는 항상 null 값인지 검사되어야 한다.</p>
<h5 id="enforcement_75">Enforcement</h5>
<ul>
<li>(복잡함) <code>dynamic_cast</code>의 포인터 타입 반환을 검사하는 코드가 없으면, 그 포인터의 사용을 경고하라</li>
</ul>
<h3 id="c149-unique_ptr-shared_ptr"><a name="Rh-smart"></a>C.149: 동적 할당한 개체의 소멸을 잊지 않도록 <code>unique_ptr</code> 혹은 <code>shared_ptr</code>를 사용하라</h3>
<h5 id="reason_79">Reason</h5>
<p>자원 누수를 방지한다.</p>
<h5 id="example_60">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="kt">int</span> <span class="n">i</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">int</span> <span class="p">{</span><span class="mi">7</span><span class="p">};</span>           <span class="c1">// bad: initialize local pointers with new</span>
        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">9</span><span class="p">);</span>   <span class="c1">// ok: guarantee the release of the memory-allocated for 9</span>
        <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">&lt;</span> <span class="n">i</span><span class="p">)</span> <span class="k">return</span><span class="p">;</span>              <span class="c1">// maybe return and leak</span>
        <span class="k">delete</span> <span class="n">p</span><span class="p">;</span>                       <span class="c1">// too late</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_76">Enforcement</h5>
<ul>
<li><code>new</code>를 사용한 일반(naked) 포인터의 초기화를 지적하라</li>
<li>지역 변수의 <code>delete</code>처리를 지적하라</li>
</ul>
<h3 id="c150-unique_ptr-make_unique"><a name="Rh-make_unique"></a>C.150: <code>unique_ptr</code>로 소유되는 개체를 생성하기 위해서는 <code>make_unique()</code>를 사용하라</h3>
<h5 id="reason_80">Reason</h5>
<p><code>make_unique</code>는 생성에 대한 보다 정확한 구문을 제공한다. 복잡한 표현식에서 예외 안전성을 보장한다.</p>
<h5 id="example_61">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span> <span class="n">p</span> <span class="p">{</span><span class="k">new</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">7</span><span class="p">}};</span>   <span class="c1">// OK: but repetitive</span>

    <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>      <span class="c1">// Better: no repetition of Foo</span>

    <span class="c1">// Not exception-safe: the compiler may interleave the computations of arguments as follows:</span>
    <span class="c1">//</span>
    <span class="c1">// 1. allocate memory for Foo,</span>
    <span class="c1">// 2. construct Foo,</span>
    <span class="c1">// 3. call bar,</span>
    <span class="c1">// 4. construct unique_ptr&lt;Foo&gt;.</span>
    <span class="c1">//</span>
    <span class="c1">// If bar throws, Foo will not be destroyed, and the memory-allocated for it will leak.</span>
    <span class="n">f</span><span class="p">(</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">Foo</span><span class="p">()),</span> <span class="n">bar</span><span class="p">());</span>

    <span class="c1">// Exception-safe: calls to functions are never interleaved.</span>
    <span class="n">f</span><span class="p">(</span><span class="n">make_unique</span><span class="o">&lt;</span><span class="n">Foo</span><span class="o">&gt;</span><span class="p">(),</span> <span class="n">bar</span><span class="p">());</span>
</pre></div>


<h5 id="enforcement_77">Enforcement</h5>
<ul>
<li>반복적인 템플릿 특수화 <code>&lt;Foo&gt;</code>의 사용을 지적한다</li>
<li><code>unique_ptr&lt;Foo&gt;</code>로 선언된 변수들을 지적한다</li>
</ul>
<h3 id="c151-shared_ptr-make_shared"><a name="Rh-make_shared"></a>C.151: <code>shared_ptr</code>로 소유되는 개체를 생성하기 위해서는 <code>make_shared()</code>를 사용하라</h3>
<h5 id="reason_81">Reason</h5>
<p><code>make_shared</code>는 생성에 대한 보다 정확한 구문을 제공한다. 참조 카운트에 대한 별도의 공간 할당이 필요없게 된다. <code>shared_ptr</code>는 개체의 옆(다음 영역)에 참조 카운트를 배치해 사용한다.</p>
<h5 id="example_62">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">test</span><span class="p">()</span> <span class="p">{</span>
        <span class="c1">// OK: but repetitive; and separate allocations for the Bar and shared_ptr&#39;s use count</span>
        <span class="n">shared_ptr</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span> <span class="n">p</span> <span class="p">{</span><span class="k">new</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">{</span><span class="mi">7</span><span class="p">}};</span>

        <span class="k">auto</span> <span class="n">q</span> <span class="o">=</span> <span class="n">make_shared</span><span class="o">&lt;</span><span class="n">Bar</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">7</span><span class="p">);</span>   <span class="c1">// Better: no repetition of Bar; one object</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_78">Enforcement</h5>
<ul>
<li>반복적인 템플릿 특수화 <code>&lt;Bar&gt;</code>의 사용을 지적한다</li>
<li><code>shared_ptr&lt;Bar&gt;</code>로 선언된 변수들을 지적한다</li>
</ul>
<h3 id="c152"><a name="Rh-array"></a>C.152: 절대로 하위 클래스의 포인터에 상위 클래스 포인터를 대입하지 마라</h3>
<h5 id="reason_82">Reason</h5>
<p>상위 타입 포인터를 대입하면 부적절한 개체 접근이 발생하고 아마도 메모리 손상을 일으킬 것이다.</p>
<h5 id="example_63">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">B</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">x</span><span class="p">;</span> <span class="p">};</span>
    <span class="k">struct</span> <span class="nl">D</span> <span class="p">:</span> <span class="n">B</span> <span class="p">{</span> <span class="kt">int</span> <span class="n">y</span><span class="p">;</span> <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">use</span><span class="p">(</span><span class="n">B</span><span class="o">*</span><span class="p">);</span>

    <span class="n">D</span> <span class="n">a</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">},</span> <span class="p">{</span><span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">},</span> <span class="p">{</span><span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">}};</span>
    <span class="n">B</span><span class="o">*</span> <span class="n">p</span> <span class="o">=</span> <span class="n">a</span><span class="p">;</span>     <span class="c1">// bad: a decays to &amp;a[0] which is converted to a B*</span>
    <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">x</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span>   <span class="c1">// overwrite D[0].y</span>

    <span class="n">use</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>       <span class="c1">// bad: a decays to &amp;a[0] which is converted to a B*</span>
</pre></div>


<h5 id="enforcement_79">Enforcement</h5>
<ul>
<li>배열 포인터의 변환이나 상위 타입에서 하위 타입으로의 변환을 지적한다</li>
<li>배열은 포인터보다는 <code>span</code>을 사용해서 전달하라. 그리고 <code>span</code>을 생성하기  전까지는 하위 타입에서 상위 타입으로 변환되지 않도록 하라</li>
</ul>
<h3 id="c153"><a name="Rh-use-virtual"></a>C.153: 타입 캐스팅보다 가상 함수를 선호하라</h3>
<h5 id="reason_83">Reason</h5>
<p>타입 캐스팅이 오류에 취약한 반면 가상함수 호출은 안전하디. 가상 함수 호출은 최종 구현을 사용하는 반면, 타입 캐스팅은 중간 클래스에 적용될수도 있다. 이로 인해 잘못된 결과를 반환할 수 있다 (계층 구조가 유지보수 과정에서 변경되었다면).</p>
<h5 id="example_64">Example</h5>
<div class="codehilite"><pre><span></span>    ???
</pre></div>


<h5 id="enforcement_80">Enforcement</h5>
<p><a href="#Rh-dynamic_cast">C.146</a>를 참고하라</p>
<h2 id="cover-overloading"><a name="SS-overload"></a>C.over: 중복정의(Overloading)</h2>
<p>일반 함수, 템플릿 함수, 연산자를 중복 정의할 수 있다. 함수 개체는 중복정의할 수 없다.</p>
<p>중복정의 규칙 요약:</p>
<ul>
<li><a href="#Ro-conventional">C.160: 연산자를 정의할때는 전통적인 사용을 모방하라</a></li>
<li><a href="#Ro-symmetric">C.161: 대칭적인 연산자는 비멤버 함수로 정의하라</a></li>
<li><a href="#Ro-equivalent">C.162: 거의 동등한 연산들을 중복정의하라</a></li>
<li><a href="#Ro-equivalent-2">C.163: 거의 동등한 연산들'만' 중복정의하라</a></li>
<li><a href="#Ro-conversion">C.164: 암묵적 형변환 연산자들을 지양하라</a></li>
<li><a href="#Ro-custom">C.165: 커스터마이징이 필요하면 <code>using</code>을 사용하라</a></li>
<li><a href="#Ro-address-of">C.166: 단항 연산자 <code>&amp;</code>는 스마트 포인터와 참조 체계를 따르는 경우에만 중복정의하라</a></li>
<li><a href="#Ro-overload">C.167: 연산자는 전통적인 의미를 수행하는데 사용하라</a></li>
<li><a href="#Ro-namespace">C.168: 연산자를 중복정의는 피연산자의 네임스페이스에 하라</a></li>
<li><a href="#Ro-lambda">C.170: 람다를 중복 정의하고 싶다면, 제네릭 람다를 사용하라</a></li>
</ul>
<h3 id="c160"><a name="Ro-conventional"></a>C.160: 연산자를 정의할때는 전통적인 사용을 모방하라</h3>
<h5 id="reason_84">Reason</h5>
<p>예상을 벗어나지 않게 한다.</p>
<h5 id="example_65">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="c1">// ...</span>
        <span class="n">X</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// member function defining assignment</span>
        <span class="k">friend</span> <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span> <span class="c1">// == needs access to representation</span>
                                                    <span class="c1">// after a = b we have a == b</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<p>이 예시에선 전통적인 의미구조를 따른다: <a href="#SS-copy">복사된 개체는 동등한 값을 가진다</a>.</p>
<h5 id="example-bad_37">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="n">X</span> <span class="k">operator</span><span class="o">+</span><span class="p">(</span><span class="n">X</span> <span class="n">a</span><span class="p">,</span> <span class="n">X</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">v</span> <span class="o">-</span> <span class="n">b</span><span class="p">.</span><span class="n">v</span><span class="p">;</span> <span class="p">}</span>   <span class="c1">// bad: makes + subtract</span>
</pre></div>


<h5 id="note_78">Note</h5>
<p>멤버가 아닌 연산자들은 friend이거나 <a href="#Ro-namespace">피연산자들과 같은 네임스페이스에 정의되어야 한다</a>.
<a href="#Ro-symmetric">이항 연산자들은 피연산자를 동등하게 다뤄야 한다</a>.</p>
<h5 id="enforcement_81">Enforcement</h5>
<p>거의 불가능하다</p>
<h3 id="c161"><a name="Ro-symmetric"></a>C.161: 대칭적인 연산자는 비멤버 함수로 정의하라</h3>
<h5 id="reason_85">Reason</h5>
<p>연산자 정의에 멤버함수를 사용하면 피연산자 타입마다 멤버함수가 필요하다.
가령 <code>==</code> 연산자에 비 멤버 함수를 사용하지 않는다면, <code>a == b</code>와 <code>b == a</code>가 미묘하게 다를 것이다.</p>
<h5 id="example_66">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">Point</span> <span class="n">a</span><span class="p">,</span> <span class="n">Point</span> <span class="n">b</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="n">a</span><span class="p">.</span><span class="n">x</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;&amp;</span> <span class="n">a</span><span class="p">.</span><span class="n">y</span> <span class="o">==</span> <span class="n">b</span><span class="p">.</span><span class="n">y</span><span class="p">;</span> <span class="p">}</span>
</pre></div>


<h5 id="enforcement_82">Enforcement</h5>
<p>멤버 함수인 연산자들을 지적하라.</p>
<h3 id="c162"><a name="Ro-equivalent"></a>C.162: 거의 동등한 연산들을 중복정의하라</h3>
<h5 id="reason_86">Reason</h5>
<p>논리적으로 같은 연산이 다른 타입에 다른 이름을 가지는 것은 혼란스럽고, 타입 정보를 함수 이름에 집어넣게 된다. 제네릭 프로그래밍에도 방해된다.</p>
<h5 id="example_67">Example</h5>
<p>다음과 같은 예를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">print</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>


<p>이 세 함수들은 인자를 출력한다. 다른 경우:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">print_int</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">print_based</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">base</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">print_string</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>


<p>이 세 함수들은 인자를 출력한다. 인자 타입을 이름에 붙이는 것은 불필요하고 일반적인 코드를 작성하지 못하게 한다.</p>
<h5 id="enforcement_83">Enforcement</h5>
<p>???</p>
<h3 id="c163"><a name="Ro-equivalent-2"></a>C.163: 거의 동등한 연산들'만' 중복정의하라</h3>
<h5 id="reason_87">Reason</h5>
<p>논리적으로 다른 함수가 같은 이름을 가지는 것은 혼란을 일으키고 제네릭 프로그래밍에서 오류로 이어진다.</p>
<h5 id="example_68">Example</h5>
<p>다음과 같은 예를 생각해보라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">open_gate</span><span class="p">(</span><span class="n">Gate</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">);</span>   <span class="c1">// remove obstacle from garage exit lane</span>
    <span class="kt">void</span> <span class="nf">fopen</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span><span class="p">);</span>   <span class="c1">// open file</span>
</pre></div>


<p>이 두 함수는 근본적으로 다르고 연관성이 없다. 따라서 다른 이름을 가지는 것이 좋다. 다른 경우:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">open</span><span class="p">(</span><span class="n">Gate</span><span class="o">&amp;</span> <span class="n">g</span><span class="p">);</span>   <span class="c1">// remove obstacle from garage exit lane</span>
    <span class="kt">void</span> <span class="nf">open</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">name</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">mode</span> <span class="o">=</span><span class="s">&quot;r&quot;</span><span class="p">);</span>   <span class="c1">// open file</span>
</pre></div>


<p>이 두 연산은 여전히 근본적으로 다르고 연관성을 가지지 않는다. 하지만 이름이 축약되었고 혼란의 가능성을 만든다. 다행히도, 이들의 시그니처가 다르기 때문에 타입시스템이 실수를 잡아낼 것이다.</p>
<h5 id="note_79">Note</h5>
<p><code>open</code>, <code>move</code>, <code>+</code>, <code>==</code>과 같이 일반적이고 많이 쓰이는 이름에는 특히 주의하라. </p>
<h5 id="enforcement_84">Enforcement</h5>
<p>???</p>
<h3 id="c164"><a name="Ro-conversion"></a>C.164: 암묵적 형변환 연산자들을 지양하라</h3>
<h5 id="reason_88">Reason</h5>
<p>묵시적 변환이 필수적일 수 있다 (<code>double</code>에서 <code>int</code>로 바꾼다던지). 하지만 (<code>String</code>에서 C-style 문자열이 되는 것처럼) 의도치 않은 동작이 생기기도 한다. </p>
<h5 id="note_80">Note</h5>
<p>정말 필요한 경우가 발생하지 않는다면 명시적 변환을 선호하라.
"정말 필요한"은 응용 프로그램의 영역에서 기본적이고 자연스러우며 자주 필요한 경우를 의미한다. (가령 정수를 복소수로 변환하는 것처럼) 
(변환 연산자 또는 암묵적 생성자를 통해서) 암묵적 변환을 사용하지 마라. 약간의 편안함만 얻을 수 있을 뿐이다.</p>
<h5 id="example_69">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">S1</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="k">operator</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="p">}</span>  <span class="c1">// BAD, likely to cause surprises</span>
    <span class="p">};</span>

    <span class="k">struct</span> <span class="n">S2</span> <span class="p">{</span>
        <span class="n">string</span> <span class="n">s</span><span class="p">;</span>
        <span class="c1">// ...</span>
        <span class="k">explicit</span> <span class="k">operator</span> <span class="kt">char</span><span class="o">*</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">s</span><span class="p">.</span><span class="n">data</span><span class="p">();</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="n">S1</span> <span class="n">s1</span><span class="p">,</span> <span class="n">S2</span> <span class="n">s2</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">x1</span> <span class="o">=</span> <span class="n">s1</span><span class="p">;</span>     <span class="c1">// OK, but can cause surprises in many contexts</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">x2</span> <span class="o">=</span> <span class="n">s2</span><span class="p">;</span>     <span class="c1">// error (and that&#39;s usually a good thing)</span>
        <span class="kt">char</span><span class="o">*</span> <span class="n">x3</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">s2</span><span class="p">);</span> <span class="c1">// we can be explicit (on your head be it)</span>
    <span class="p">}</span>
</pre></div>


<p>이런 놀랍고 잠재적 피해가 발생할 수 있는 암묵적 변환은 찾아내기 어려운 문맥 속에서 발생할 수 있다. 예를 들어,</p>
<div class="codehilite"><pre><span></span>    <span class="n">S1</span> <span class="nf">ff</span><span class="p">();</span>

    <span class="kt">char</span><span class="o">*</span> <span class="nf">g</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">ff</span><span class="p">();</span>
    <span class="p">}</span>
</pre></div>


<p><code>ff()</code>에서 반환된 문자열이 포인터가 사용되기 전에 파괴된다.</p>
<h5 id="enforcement_85">Enforcement</h5>
<p>모든 형변환 연산자를 지적하라</p>
<h3 id="c165-using"><a name="Ro-custom"></a>C.165: 커스터마이징이 필요하면 <code>using</code>을 사용하라</h3>
<h5 id="reason_89">Reason</h5>
<p>다른 네임스페이스에 위치한 함수 개체와 함수들을 찾고 보편적인 함수로 "커스터마이즈" 할 수 있다.</p>
<h5 id="example_70">Example</h5>
<p><code>swap</code>을 생각해보라. 이 함수는 일반적인 (표준 라이브러리) 함수이고, 어떤 타입에 대해서도 동작한다.
하지만, 어떤 타입들은 특별한 <code>swap()</code>을 정의할 필요가 있다.
예를 들어, 일반적인 <code>vector</code>의 <code>swap()</code>은 컨테이너 내 원소들을 복사한다. 좋은 구현이라면 복사를 수행하지 않을 것이다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
        <span class="n">My_type</span> <span class="n">X</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
        <span class="kt">void</span> <span class="nf">swap</span><span class="p">(</span><span class="n">X</span><span class="o">&amp;</span><span class="p">,</span> <span class="n">X</span><span class="o">&amp;</span><span class="p">);</span>   <span class="c1">// optimized swap for N::X</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">f1</span><span class="p">(</span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>   <span class="c1">// probably not what we wanted: calls std::swap()</span>
    <span class="p">}</span>
</pre></div>


<p><code>f1()</code>함수 안에서 <code>std::swap()</code>을 사용하는 것은 코드 그대로 실행된다: <code>std</code> 네임스페이스의 <code>swap()</code>을 호출할 것이다.
불행히도, 그게 우리가 원하는 것은 아니다. <code>N::X</code> 타입에 맞게 호출되게 하려면 어떻게 해야 할까?</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f2</span><span class="p">(</span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>   <span class="c1">// calls N::swap</span>
    <span class="p">}</span>
</pre></div>


<p>이 방법은 우리가 원하는 일반화된 코드가 아닐 수 있다. 
우리는 보통 특별히 작성된 함수가 있으면 그 함수를 쓰고 그렇지 않은 경우에는 범용 함수(general function)를 호출하기를 원한다. 이는 함수 탐색에 범용 함수를 포함하는 것으로 해결할 수 있다:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f3</span><span class="p">(</span><span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">a</span><span class="p">,</span> <span class="n">N</span><span class="o">::</span><span class="n">X</span><span class="o">&amp;</span> <span class="n">b</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">using</span> <span class="n">std</span><span class="o">::</span><span class="n">swap</span><span class="p">;</span>  <span class="c1">// std::swap이 탐색되도록 한다</span>
        <span class="n">swap</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>       <span class="c1">// N 네임스페이스에 swap이 존재하면 호출하고, 그렇지 않으면 std::swap을 호출한다</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_86">Enforcement</h5>
<p><code>swap</code>같이 잘 알려진 커스터마이징을 제외하면 할 수 있는게 거의 없다.
문제는 qualified 탐색과 unqualified 탐색이 함께 사용된다는 것이다.</p>
<blockquote>
<p>역주:<br />
<a href="https://github.com/CppKorea/CppTemplateStudy/blob/master/7th%20Study/Chap13.md#2-이름-탐색">이름 탐색</a> - C++ Korea Template Study</p>
</blockquote>
<h3 id="c166-amp"><a name="Ro-address-of"></a>C.166: 단항 연산자 <code>&amp;</code>는 스마트 포인터와 참조 체계를 따르는 경우에만 중복정의하라</h3>
<h5 id="reason_90">Reason</h5>
<p><code>&amp;</code> 연산자는 C++에서 필수적이다. C++ 에서 사용되는 의미구조의 많은 부분이 기본적인 의미를 전제하고 있다.</p>
<h5 id="example_71">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Ptr</span> <span class="p">{</span> <span class="c1">// a somewhat smart pointer</span>
        <span class="n">Ptr</span><span class="p">(</span><span class="n">X</span><span class="o">*</span> <span class="n">pp</span><span class="p">)</span> <span class="o">:</span><span class="n">p</span><span class="p">(</span><span class="n">pp</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* check */</span> <span class="p">}</span>
        <span class="n">X</span><span class="o">*</span> <span class="k">operator</span><span class="o">-&gt;</span><span class="p">()</span> <span class="p">{</span> <span class="cm">/* check */</span> <span class="k">return</span> <span class="n">p</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">X</span> <span class="k">operator</span><span class="p">[](</span><span class="kt">int</span> <span class="n">i</span><span class="p">);</span>
        <span class="n">X</span> <span class="k">operator</span><span class="o">*</span><span class="p">();</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="n">T</span><span class="o">*</span> <span class="n">p</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="k">class</span> <span class="nc">X</span> <span class="p">{</span>
        <span class="n">Ptr</span> <span class="k">operator</span><span class="o">&amp;</span><span class="p">()</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Ptr</span><span class="p">{</span><span class="k">this</span><span class="p">};</span> <span class="p">}</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>
</pre></div>


<h5 id="note_81">Note</h5>
<p><code>&amp;</code> 연산자로 "뭔가 하려면" <code>-&gt;</code>, <code>[]</code>, <code>*</code>, <code>.</code> 연산자들에 적합한 정의(반환 타입)를 가지도록 하라. <code>.</code> 연산자는 현재로써는 중복정의할 수 없기 때문에 완벽한 체계를 갖추는 것은 불가능하다.</p>
<p>다음 문서를 보기를 권한다: <a href="http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf">http://www.open-std.org/jtc1/sc22/wg21/docs/papers/2015/n4477.pdf</a>.
<code>std::addressof()</code>는 항상 내장 포인터 타입을 반환한다는 점에 유의하라.</p>
<h5 id="enforcement_87">Enforcement</h5>
<p>까다롭다. <code>&amp;</code> 연산자가 <code>-&gt;</code>와 함께 사용자 정의되지 않았다면 경고한다.</p>
<h3 id="c167"><a name="Ro-overload"></a>C.167: 연산자는 전통적인 의미를 수행하는데 사용하라</h3>
<h5 id="reason_91">Reason</h5>
<p>가독성, 관례적 의미, 재사용성, 일반화된 코드에 도움이 된다</p>
<h5 id="example_72">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">cout_my_class</span><span class="p">(</span><span class="k">const</span> <span class="n">My_class</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="c1">// confusing, not conventional,not generic</span>
    <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="cm">/* class members here */</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">&lt;&lt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">ostream</span><span class="o">&amp;</span> <span class="n">os</span><span class="p">,</span> <span class="k">const</span> <span class="n">my_class</span><span class="o">&amp;</span> <span class="n">c</span><span class="p">)</span> <span class="c1">// OK</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">os</span> <span class="o">&lt;&lt;</span> <span class="cm">/* class members here */</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>그 자체로, <code>cout_my_class</code>는 문제가 없다. 하지만 관례적으로 출력에 사용하는 <code>&lt;&lt;</code> 연산자에 맞게 작성할 수 없다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">My_class</span> <span class="n">var</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
    <span class="c1">// ...</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;var = &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">var</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
</pre></div>


<h5 id="note_82">Note</h5>
<p>대부분의 연산자들은 강력하고 흔히 사용되는 의미를 가지고 있다</p>
<ul>
<li>비교 (<code>==</code>, <code>!=</code>, <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code>, <code>&gt;=</code>),</li>
<li>산술 연산 (<code>+</code>, <code>-</code>, <code>*</code>, <code>/</code>, <code>%</code>)</li>
<li>접근 연산 (<code>.</code>, <code>-&gt;</code>, 단항 <code>*</code>, <code>[]</code>)</li>
<li>대입 (<code>=</code>)</li>
</ul>
<p>관례적으로 사용되어온 의미와 다르게 정의하거나 새롭게 의미를 부여해서 사용하지 말아라.</p>
<h5 id="enforcement_88">Enforcement</h5>
<p>까다롭다. 의미구조에 대한 통찰이 필요하다.</p>
<h3 id="c168"><a name="Ro-namespace"></a>C.168: 연산자를 중복정의는 피연산자의 네임스페이스에 하라</h3>
<h5 id="reason_92">Reason</h5>
<p>가독성. 인자 기반 탐색(ADL)이 가능하다. 다른 네임스페이스에 정의하는 것은 일관적이지 않다.</p>
<h5 id="example_73">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="p">};</span>
    <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S</span><span class="p">);</span>   <span class="c1">// OK: in the same namespace as S, and even next to S</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span>
</pre></div>


<p>기본적인 <code>==</code> 연산자가 하는 일이다.</p>
<h5 id="example_74">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
        <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="p">};</span>
        <span class="kt">bool</span> <span class="k">operator</span><span class="o">==</span><span class="p">(</span><span class="n">S</span><span class="p">,</span> <span class="n">S</span><span class="p">);</span>   <span class="c1">// OK: in the same namespace as S, and even next to S</span>
    <span class="p">}</span>

    <span class="n">N</span><span class="o">::</span><span class="n">S</span> <span class="n">s</span><span class="p">;</span>

    <span class="kt">bool</span> <span class="n">x</span> <span class="o">=</span> <span class="p">(</span><span class="n">s</span> <span class="o">==</span> <span class="n">s</span><span class="p">);</span>  <span class="c1">// finds N::operator==() by ADL</span>
</pre></div>


<h5 id="example-bad_38">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">struct</span> <span class="n">S</span> <span class="p">{</span> <span class="p">};</span>
    <span class="n">S</span> <span class="n">s</span><span class="p">;</span>

    <span class="k">namespace</span> <span class="n">N</span> <span class="p">{</span>
        <span class="n">S</span><span class="o">::</span><span class="k">operator</span><span class="o">!</span><span class="p">(</span><span class="n">S</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">S</span> <span class="n">not_s</span> <span class="o">=</span> <span class="o">!</span><span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">namespace</span> <span class="n">M</span> <span class="p">{</span>
        <span class="n">S</span><span class="o">::</span><span class="k">operator</span><span class="o">!</span><span class="p">(</span><span class="n">S</span> <span class="n">a</span><span class="p">)</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>
        <span class="n">S</span> <span class="n">not_s</span> <span class="o">=</span> <span class="o">!</span><span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>
</pre></div>


<p>네임스페이스 <code>N</code>과 <code>M</code> 에서 <code>!s</code>의 의미가 달라진다. 굉장히 혼란스러울 수 있다. <code>namespace M</code>의 정의를 제거하면 실수가 발생할 가능성의 사라진다.</p>
<h5 id="note_83">Note</h5>
<p>이항 연산자가 다른 네임스페이스에 있는 두 타입에 대해서 정의되었다면, 이 규칙을 따를 수 없다.
예를 들어:</p>
<div class="codehilite"><pre><span></span>    <span class="n">Vec</span><span class="o">::</span><span class="n">Vector</span> <span class="k">operator</span><span class="o">*</span><span class="p">(</span><span class="k">const</span> <span class="n">Vec</span><span class="o">::</span><span class="n">Vector</span><span class="o">&amp;</span><span class="p">,</span> <span class="k">const</span> <span class="n">Mat</span><span class="o">::</span><span class="n">Matrix</span><span class="o">&amp;</span><span class="p">);</span>
</pre></div>


<p>이런 경우는 피하는 것이 최선이다.</p>
<h5 id="see-also_9">See also</h5>
<p><a href="#Rc-helper">보조 함수들은 관련 클래스와 같은 namespace에 배치하라</a>는 규칙의 특별한 경우에 해당한다</p>
<h5 id="enforcement_89">Enforcement</h5>
<ul>
<li>피연산자의 네임스페이스에 위치하지 않은 연산자 정의를 지적한다</li>
</ul>
<h3 id="c170"><a name="Ro-lambda"></a>C.170: 람다를 중복 정의하고 싶다면, 제네릭 람다를 사용하라</h3>
<h5 id="reason_93">Reason</h5>
<p>같은 이름으로 두개의 서로 다른 람다를 중복 정의할 수 없다.</p>
<h5 id="example_75">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">int</span><span class="p">);</span>
    <span class="kt">void</span> <span class="nf">f</span><span class="p">(</span><span class="kt">double</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">f</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">char</span><span class="p">);</span>   <span class="c1">// error: cannot overload variable and function</span>

    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">int</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>
    <span class="k">auto</span> <span class="n">g</span> <span class="o">=</span> <span class="p">[](</span><span class="kt">double</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>   <span class="c1">// error: cannot overload variables</span>

    <span class="k">auto</span> <span class="n">h</span> <span class="o">=</span> <span class="p">[](</span><span class="k">auto</span><span class="p">)</span> <span class="p">{</span> <span class="cm">/* ... */</span> <span class="p">};</span>   <span class="c1">// OK</span>
</pre></div>


<h5 id="enforcement_90">Enforcement</h5>
<p>컴파일러가 람다를 중복 정의하려는 시도를 잡아낸다.</p>
<h2 id="cunion-union"><a name="SS-union"></a>C.union: 공용체(Union)</h2>
<p><code>union</code>은 모든 멤버가 같은 주소에서 시작하는 <code>struct</code>라고 할 수 있다. 따라서 한 시점에 하나의 멤버만 가지고 있다.
<code>union</code>은 어떤 멤버가 저장되었는지 추적하지 않기 때문에 프로그래머가 정확하게 사용해야 한다; 이는 필연적으로 오류를 발생시키지만, 이를 보완할 방법은 있다</p>
<p><code>union</code>에 어떤 멤버가 사용되고 있는지 알려주도록 표지(indicator)가 추가된 것을 <em>tagged union</em>, <em>discriminated union</em>, 혹은 <em>variant</em>이라고 부른다. </p>
<p>공용체(Unions) 규칙 요약:</p>
<ul>
<li><a href="#Ru-union">C.180: <code>union</code>은 메모리를 절약하기 위해 사용하라</a></li>
<li><a href="#Ru-naked">C.181: 표지 없는(naked) <code>union</code>을 사용하지 말아라</a></li>
<li><a href="#Ru-anonymous">C.182: Tagged union 구현에는 익명 <code>union</code>을 사용하라</a></li>
<li><a href="#Ru-pun">C.183: 타입 재해석(type punning)을 위해 <code>union</code>을 사용하지 말아라</a></li>
<li>???</li>
</ul>
<h3 id="c180-union"><a name="Ru-union"></a>C.180: <code>union</code>은 메모리를 절약하기 위해 사용하라</h3>
<h5 id="reason_94">Reason</h5>
<p><code>union</code>은 하나의 메모리 조각이 다른 시각에 다른 타입의 개체들로 사용될 수 있도록 해준다. 결과적으로, 다른 개체들이 동시에 사용되지 않는다면 메모리를 절약하는데 사용할 수 있다.</p>
<h5 id="example_76">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="k">union</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Value</span> <span class="n">v</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">123</span> <span class="p">};</span>  <span class="c1">// now v holds an int</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// write 123</span>
    <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mf">987.654</span><span class="p">;</span>  <span class="c1">// now v holds a double</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// write 987.654</span>
</pre></div>


<p>하지만 경고를 유심히 보라: <a href="#Ru-naked">표지 없는(naked) <code>union</code>을 사용하지 말아라</a></p>
<h5 id="example_77">Example</h5>
<div class="codehilite"><pre><span></span>    <span class="c1">// Short-string optimization</span>

    <span class="k">constexpr</span> <span class="kt">size_t</span> <span class="n">buffer_size</span> <span class="o">=</span> <span class="mi">16</span><span class="p">;</span> <span class="c1">// Slightly larger than the size of a pointer</span>

    <span class="k">class</span> <span class="nc">Immutable_string</span> <span class="p">{</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="n">Immutable_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">str</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">size</span><span class="p">(</span><span class="n">strlen</span><span class="p">(</span><span class="n">str</span><span class="p">))</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="n">strcpy_s</span><span class="p">(</span><span class="n">string_buffer</span><span class="p">,</span> <span class="n">buffer_size</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
            <span class="k">else</span> <span class="p">{</span>
                <span class="n">string_ptr</span> <span class="o">=</span> <span class="k">new</span> <span class="kt">char</span><span class="p">[</span><span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">];</span>
                <span class="n">strcpy_s</span><span class="p">(</span><span class="n">string_ptr</span><span class="p">,</span> <span class="n">size</span> <span class="o">+</span> <span class="mi">1</span><span class="p">,</span> <span class="n">str</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="o">~</span><span class="n">Immutable_string</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">size</span> <span class="o">&gt;=</span> <span class="n">buffer_size</span><span class="p">)</span>
                <span class="k">delete</span> <span class="n">string_ptr</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">get_str</span><span class="p">()</span> <span class="k">const</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">size</span> <span class="o">&lt;</span> <span class="n">buffer_size</span><span class="p">)</span> <span class="o">?</span> <span class="nl">string_buffer</span> <span class="p">:</span> <span class="n">string_ptr</span><span class="p">;</span>
        <span class="p">}</span>

    <span class="k">private</span><span class="o">:</span>
        <span class="c1">// If the string is short enough, we store the string itself</span>
        <span class="c1">// instead of a pointer to the string.</span>
        <span class="k">union</span> <span class="p">{</span>
            <span class="kt">char</span><span class="o">*</span> <span class="n">string_ptr</span><span class="p">;</span>
            <span class="kt">char</span> <span class="n">string_buffer</span><span class="p">[</span><span class="n">buffer_size</span><span class="p">];</span>
        <span class="p">};</span>

        <span class="k">const</span> <span class="kt">size_t</span> <span class="n">size</span><span class="p">;</span>
    <span class="p">};</span>
</pre></div>


<h5 id="enforcement_91">Enforcement</h5>
<p>???</p>
<h3 id="c181-naked-union"><a name="Ru-naked"></a>C.181: 표지 없는(naked) <code>union</code>을 사용하지 말아라</h3>
<h5 id="reason_95">Reason</h5>
<p><em>표지 없는(naked) union</em>은 어떤 멤버를 사용하는지 알 수 없는 union을 의미한다. 이런 경우 프로그래머가 계속 추적해야 한다. 타입 오류의 원인이 된다.</p>
<h5 id="example-bad_39">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">union</span> <span class="n">Value</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">double</span> <span class="n">d</span><span class="p">;</span>
    <span class="p">};</span>

    <span class="n">Value</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">=</span> <span class="mf">987.654</span><span class="p">;</span>  <span class="c1">// v holds a double</span>
</pre></div>


<p>여기까진 문제가 없다. 하지만 <code>union</code>은 잘못 사용하기 쉽다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// BAD, undefined behavior: v holds a double, but we read it as an int</span>
</pre></div>


<p>명시적 변환이 없음에도 타입 오류가 발생한 점에 주목하라.
마지막으로 이 프로그램을 테스트 했을떄 출력된 값은 <code>987.654</code>의 비트 패턴을 정수로 해석한 <code>1683627180</code>이었다.
이 예시에서는 코드에는 문제 없어 보이지만 "보이지 않는(invisible)" 타입 오류가 발생하는 것을 보여준다.</p>
<p>그리고, "보이지 않는" 오류로, 이 코드는 아무것도 출력하지 않는다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">v</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>
    <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">v</span><span class="p">.</span><span class="n">d</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>    <span class="c1">// BAD: undefined behavior</span>
</pre></div>


<h5 id="alternative_2">Alternative</h5>
<p>타입 필드를 추가해서 <code>union</code>을 클래스로 감싼다.</p>
<p><code>&lt;variant&gt;</code> 헤더의 표준 <code>variant</code> 타입이 이 일을 대신 해준다:</p>
<div class="codehilite"><pre><span></span>    <span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">v</span><span class="p">;</span>
    <span class="n">v</span> <span class="o">=</span> <span class="mi">123</span><span class="p">;</span>        <span class="c1">// v holds an int</span>
    <span class="kt">int</span> <span class="n">x</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
    <span class="n">v</span> <span class="o">=</span> <span class="mf">123.456</span><span class="p">;</span>    <span class="c1">// v holds a double</span>
    <span class="n">w</span> <span class="o">=</span> <span class="n">get</span><span class="o">&lt;</span><span class="kt">double</span><span class="o">&gt;</span><span class="p">(</span><span class="n">v</span><span class="p">);</span>
</pre></div>


<h5 id="enforcement_92">Enforcement</h5>
<p>???</p>
<h3 id="c182-tagged-union-union"><a name="Ru-anonymous"></a>C.182: Tagged union 구현에는 익명 <code>union</code>을 사용하라</h3>
<h5 id="reason_96">Reason</h5>
<p>잘 설계된 Tagged union은 타입 안전성을 가지고 있다.
<em>익명(anonymous)</em> union은 (tag, union) 형태의 클래스 정의를 쉽게 만들어준다.</p>
<h5 id="example_78">Example</h5>
<p>이 예제는 대부분 TC++PL4 pp216-218 에서 발췌한 것이다. 설명을 원한다면 해당 문서를 참고하라.</p>
<p>예시 코드는 상세한 편이다. 이 타입에서 사용자가 정의한 대입 연산과 소멸자를 다루는 것은 꽤 신경써야 하는 작업이다. 
이런 작업을 프로그래머가 하지 않도록 하는 것이 <code>variant</code>가 표준에 추가된 이유 중 하나다.</p>
<div class="codehilite"><pre><span></span>    <span class="k">class</span> <span class="nc">Value</span> <span class="p">{</span> <span class="c1">// two alternative representations represented as a union</span>
    <span class="k">private</span><span class="o">:</span>
        <span class="k">enum</span> <span class="k">class</span> <span class="nc">Tag</span> <span class="p">{</span> <span class="n">number</span><span class="p">,</span> <span class="n">text</span> <span class="p">};</span>
        <span class="n">Tag</span> <span class="n">type</span><span class="p">;</span> <span class="c1">// discriminant</span>

        <span class="k">union</span> <span class="p">{</span> <span class="c1">// representation (note: anonymous union)</span>
            <span class="kt">int</span> <span class="n">i</span><span class="p">;</span>
            <span class="n">string</span> <span class="n">s</span><span class="p">;</span> <span class="c1">// string has default constructor, copy operations, and destructor</span>
        <span class="p">};</span>
    <span class="k">public</span><span class="o">:</span>
        <span class="k">struct</span> <span class="n">Bad_entry</span> <span class="p">{</span> <span class="p">};</span> <span class="c1">// used for exceptions</span>

        <span class="o">~</span><span class="n">Value</span><span class="p">();</span>
        <span class="n">Value</span><span class="o">&amp;</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span><span class="p">);</span>   <span class="c1">// necessary because of the string variant</span>
        <span class="n">Value</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span><span class="p">);</span>
        <span class="c1">// ...</span>
        <span class="kt">int</span> <span class="nf">number</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
        <span class="n">string</span> <span class="nf">text</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

        <span class="kt">void</span> <span class="nf">set_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
        <span class="kt">void</span> <span class="nf">set_text</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span><span class="p">);</span>
        <span class="c1">// ...</span>
    <span class="p">};</span>

    <span class="kt">int</span> <span class="n">Value</span><span class="o">::</span><span class="n">number</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Tag</span><span class="o">::</span><span class="n">number</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad_entry</span><span class="p">{};</span>
        <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">string</span> <span class="n">Value</span><span class="o">::</span><span class="n">text</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">!=</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">)</span> <span class="k">throw</span> <span class="n">Bad_entry</span><span class="p">{};</span>
        <span class="k">return</span> <span class="n">s</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Value</span><span class="o">::</span><span class="n">set_number</span><span class="p">(</span><span class="kt">int</span> <span class="n">n</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span><span class="p">.</span><span class="o">~</span><span class="n">string</span><span class="p">();</span>      <span class="c1">// explicitly destroy string</span>
            <span class="n">type</span> <span class="o">=</span> <span class="n">Tag</span><span class="o">::</span><span class="n">number</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">i</span> <span class="o">=</span> <span class="n">n</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">void</span> <span class="n">Value</span><span class="o">::</span><span class="n">set_text</span><span class="p">(</span><span class="k">const</span> <span class="n">string</span><span class="o">&amp;</span> <span class="n">ss</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">)</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">ss</span><span class="p">;</span>
        <span class="k">else</span> <span class="p">{</span>
            <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)</span> <span class="n">string</span><span class="p">{</span><span class="n">ss</span><span class="p">};</span>   <span class="c1">// placement new: explicitly construct string</span>
            <span class="n">type</span> <span class="o">=</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="n">Value</span><span class="o">&amp;</span> <span class="n">Value</span><span class="o">::</span><span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Value</span><span class="o">&amp;</span> <span class="n">e</span><span class="p">)</span>   <span class="c1">// necessary because of the string variant</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span> <span class="o">&amp;&amp;</span> <span class="n">e</span><span class="p">.</span><span class="n">type</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">s</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">s</span><span class="p">;</span>    <span class="c1">// usual string assignment</span>
            <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="o">~</span><span class="n">string</span><span class="p">();</span> <span class="c1">// explicit destroy</span>

        <span class="k">switch</span> <span class="p">(</span><span class="n">e</span><span class="p">.</span><span class="n">type</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">case</span> <span class="n">Tag</span><span class="o">::</span><span class="nl">number</span><span class="p">:</span>
            <span class="n">i</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">i</span><span class="p">;</span>
            <span class="k">break</span><span class="p">;</span>
        <span class="k">case</span> <span class="n">Tag</span><span class="o">::</span><span class="nl">text</span><span class="p">:</span>
            <span class="k">new</span><span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">)(</span><span class="n">e</span><span class="p">.</span><span class="n">s</span><span class="p">);</span>   <span class="c1">// placement new: explicit construct</span>
            <span class="n">type</span> <span class="o">=</span> <span class="n">e</span><span class="p">.</span><span class="n">type</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">return</span> <span class="o">*</span><span class="k">this</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="n">Value</span><span class="o">::~</span><span class="n">Value</span><span class="p">()</span>
    <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">type</span> <span class="o">==</span> <span class="n">Tag</span><span class="o">::</span><span class="n">text</span><span class="p">)</span> <span class="n">s</span><span class="p">.</span><span class="o">~</span><span class="n">string</span><span class="p">();</span> <span class="c1">// explicit destroy</span>
    <span class="p">}</span>
</pre></div>


<h5 id="enforcement_93">Enforcement</h5>
<p>???</p>
<h3 id="c183-type-punning-union"><a name="Ru-pun"></a>C.183: 타입 재해석(type punning)을 위해 <code>union</code>을 사용하지 말아라</h3>
<h5 id="reason_97">Reason</h5>
<p><code>union</code>의 멤버를 한 타입으로 값을 쓰고 다른 타입으로 읽는 것은 미정의 동작(undefined behavior)이다.
이런 해석은 보이지 않고, 타입 이름을 사용하는 것보다 찾아내기 어렵다.
<code>union</code>을 사용한 타입 재해석은(type punning)은 오류의 원인이다.</p>
<h5 id="example-bad_40">Example, bad</h5>
<div class="codehilite"><pre><span></span>    <span class="k">union</span> <span class="n">Pun</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">x</span><span class="p">;</span>
        <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">c</span><span class="p">[</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)];</span>
    <span class="p">};</span>
</pre></div>


<p><code>Pun</code> 타입의 의도는 <code>int</code>를 <code>char</code> 형태로 접근하는 것이다.</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">bad</span><span class="p">(</span><span class="n">Pun</span><span class="o">&amp;</span> <span class="n">u</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">u</span><span class="p">.</span><span class="n">x</span> <span class="o">=</span> <span class="sc">&#39;x&#39;</span><span class="p">;</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">u</span><span class="p">.</span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>     <span class="c1">// undefined behavior</span>
    <span class="p">}</span>
</pre></div>


<p><code>int</code>의 바이트를 확인하고 싶다면, 타입 이름을 사용한 형변환(named cast)를 사용하라:</p>
<div class="codehilite"><pre><span></span>    <span class="kt">void</span> <span class="nf">if_you_must_pun</span><span class="p">(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">x</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="k">auto</span> <span class="n">p</span> <span class="o">=</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">*&gt;</span><span class="p">(</span><span class="o">&amp;</span><span class="n">x</span><span class="p">);</span>
        <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>     <span class="c1">// OK; better</span>
        <span class="c1">// ...</span>
    <span class="p">}</span>
</pre></div>


<p><code>reinterpret_cast</code>을 사용해 타입을 바꿔서 접근하는 것은 정의된 행동(defined behavior)이다(비록  <code>reinterpret_cast</code>이 권장되지는 않지만).
이러면 최소한 신경을 많이 써야하는 것들이 사라진 것을 보여준다.</p>
<h5 id="note_84">Note</h5>
<p>불행하게도 <code>union</code>은 타입 재해석에 꽤 많이 사용된다.
"보통의 경우, 기대한 대로 동작한다"는 것은 강한 주장이라고 생각할 수 없다.</p>
<p>C++17 에서는 있는 그대로의 비트에 대해 연산을 수행할 수 있도록 <code>std::byte</code> 타입을 추가하였다. <code>unsigned char</code> 혹은 <code>char</code> 대신에 이 타입을 사용하라</p>
<h5 id="enforcement_94">Enforcement</h5>
<p>???</p>
                
                  
                
                
              
              
                


              
            </article>
          </div>
        </div>
      </main>
      
        
<footer class="md-footer">
  
    <div class="md-footer-nav">
      <nav class="md-footer-nav__inner md-grid">
        
          <a href="../Architecture/" title="Architecture" class="md-flex md-footer-nav__link md-footer-nav__link--prev" rel="prev">
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-back md-footer-nav__button"></i>
            </div>
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Previous
                </span>
                Architecture
              </span>
            </div>
          </a>
        
        
          <a href="../Concurrency/" title="Concurrency" class="md-flex md-footer-nav__link md-footer-nav__link--next" rel="next">
            <div class="md-flex__cell md-flex__cell--stretch md-footer-nav__title">
              <span class="md-flex__ellipsis">
                <span class="md-footer-nav__direction">
                  Next
                </span>
                Concurrency
              </span>
            </div>
            <div class="md-flex__cell md-flex__cell--shrink">
              <i class="md-icon md-icon--arrow-forward md-footer-nav__button"></i>
            </div>
          </a>
        
      </nav>
    </div>
  
  <div class="md-footer-meta md-typeset">
    <div class="md-footer-meta__inner md-grid">
      <div class="md-footer-copyright">
        
          <div class="md-footer-copyright__highlight">
            Copyright (c) Standard C++ Foundation and its contributors
          </div>
        
        powered by
        <a href="https://www.mkdocs.org">MkDocs</a>
        and
        <a href="https://squidfunk.github.io/mkdocs-material/">
          Material for MkDocs</a>
      </div>
      
    </div>
  </div>
</footer>
      
    </div>
    
      <script src="../assets/javascripts/application.808e90bb.js"></script>
      
      <script>app.initialize({version:"1.0.4",url:{base:".."}})</script>
      
    
  </body>
</html>